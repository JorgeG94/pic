var tipuesearch = {"pages":[{"title":" PIC ","text":"PIC PIC is named after the Huastec word PIC which means otter. A work in progress on writing a cool backend for Fortan applications focused on Quantum Chemistry software. Building and dependencies There’s two build systems included in the present version, CMake and the Fortran Package Manager . The dependencies of the project are, as of now, CMake (if using cmake), MPI, OpenMP, and a BLAS/LAPACK library. CMake mkdir build\ncd build\ncmake ../\nmake -j FPM Install the FPM following the instructions and then simply: fpm build Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"logger_type – PIC ","text":"type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info Type-Bound Procedures procedure, public, pass(self) :: close_log_file private  subroutine close_log_file(self) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self procedure, public, pass(self) :: configuration private pure subroutine configuration(self, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level procedure, public, pass(self) :: configure private pure subroutine configure(self, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: configure_file_output private  subroutine configure_file_output(self, filename, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: debug private  subroutine debug(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: error private  subroutine error(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: info private  subroutine info(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: log private  subroutine log(self, level, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: performance private  subroutine performance(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: verbose private  subroutine verbose(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: warning private  subroutine warning(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: configure_file_output procedure , public , pass ( self ) :: close_log_file procedure , public , pass ( self ) :: log procedure , public , pass ( self ) :: debug procedure , public , pass ( self ) :: verbose procedure , public , pass ( self ) :: info procedure , public , pass ( self ) :: performance procedure , public , pass ( self ) :: warning procedure , public , pass ( self ) :: error end type logger_type","tags":"","url":"type/logger_type.html"},{"title":"pic_comm – PIC ","text":"type, public :: pic_comm custom data type that holds the MPI communicators Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: dummy_comm if we don’t use MPI use an integer for a comm integer(kind=default_int), public :: m_rank MPI rank integer(kind=default_int), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize public  subroutine pic_comm_finalize (self) finalize the MPI library Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self procedure, public :: init => pic_comm_init public  subroutine pic_comm_init (self) initilalize the MPI library and get the size and rank variables Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self Source Code type :: pic_comm !! custom data type that holds the MPI communicators private #ifdef USE_MPI type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface #else integer ( default_int ), public :: dummy_comm !! if we don't use MPI use an integer for a comm #endif integer ( default_int ), public :: m_rank !! MPI rank integer ( default_int ), public :: m_size !! MPI size contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm","tags":"","url":"type/pic_comm.html"},{"title":"print_matrix – PIC","text":"public  subroutine print_matrix(mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type Variables Type Visibility Attributes Name Initial character(len=20), public :: format_selected Source Code subroutine print_matrix ( mat , format_type ) !! print a matrix in a given format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_matrix ( mat ) else call print_matrix_in_format ( mat , format_selected ) end if end subroutine print_matrix","tags":"","url":"proc/print_matrix.html"},{"title":"print_matrix_in_format – PIC","text":"public  subroutine print_matrix_in_format(mat, format_type, n_cols, n_rows) private subroutine to print a matrix in format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows Variables Type Visibility Attributes Name Initial character(len=1), public :: close_bracket integer(kind=default_int), public :: i integer(kind=default_int), public :: j integer(kind=default_int), public :: loop_bound_i integer(kind=default_int), public :: loop_bound_j character(len=1), public :: open_bracket Source Code subroutine print_matrix_in_format ( mat , format_type , n_cols , n_rows ) !! private subroutine to print a matrix in format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if ! Select brackets based on format type if ( format_type == 'NUMPY' ) then open_bracket = '[' close_bracket = ']' else if ( format_type == 'MATHEMATICA' ) then open_bracket = '{' close_bracket = '}' else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = '[' close_bracket = ']' end if ! Print the matrix in the selected format print * , \"Matrix (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i write ( * , '(A)' , advance = \"no\" ) open_bracket ! Start of a row do j = 1 , loop_bound_j if ( j == loop_bound_j ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) mat ( i , j ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) end if end do if ( i == loop_bound_i ) then print * , close_bracket ! Close bracket without a comma for the last row else print * , close_bracket , \",\" ! Close bracket with a comma for all other rows end if end do print * , close_bracket end subroutine print_matrix_in_format","tags":"","url":"proc/print_matrix_in_format.html"},{"title":"print_matrix_m_n – PIC","text":"public  subroutine print_matrix_m_n(mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type Variables Type Visibility Attributes Name Initial character(len=20), public :: format_selected Source Code subroutine print_matrix_m_n ( mat , n_cols , n_rows , format_type ) !! Print a matrix of n_cols by n_rows implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array integer ( kind = default_int ), intent ( in ) :: n_cols , n_rows character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_matrix ( mat , n_cols , n_rows ) else call print_matrix_in_format ( mat , format_selected , n_cols , n_rows ) end if end subroutine print_matrix_m_n","tags":"","url":"proc/print_matrix_m_n.html"},{"title":"print_plain_matrix – PIC","text":"public  subroutine print_plain_matrix(mat, n_cols, n_rows) private subroutine that prints a plain matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows Variables Type Visibility Attributes Name Initial integer(kind=default_int), public :: i integer(kind=default_int), public :: j integer(kind=default_int), public :: loop_bound_i integer(kind=default_int), public :: loop_bound_j Source Code subroutine print_plain_matrix ( mat , n_cols , n_rows ) !! private subroutine that prints a plain matrix of n_cols by n_rows implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if print * , \"Matrix (Plain format):\" do i = 1 , loop_bound_i do j = 1 , loop_bound_j if ( j == loop_bound_j ) then write ( * , fmt_edge , advance = \"yes\" ) mat ( i , j ) ! Last element in the row, new line else write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) ! In-between elements end if end do end do end subroutine print_plain_matrix","tags":"","url":"proc/print_plain_matrix.html"},{"title":"print_plain_vector – PIC","text":"public  subroutine print_plain_vector(vec, n_elements) private subroutine that prints a vector of n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in), optional :: n_elements Variables Type Visibility Attributes Name Initial integer(kind=default_int), public :: i integer(kind=default_int), public :: loop_bound Source Code subroutine print_plain_vector ( vec , n_elements ) !! private subroutine that prints a vector of n_elements implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) integer ( kind = default_int ), intent ( in ), optional :: n_elements integer ( kind = default_int ) :: i , loop_bound if ( present ( n_elements )) then loop_bound = n_elements else loop_bound = size ( vec ) end if print * , \"Vector (Plain format):\" do i = 1 , loop_bound write ( * , fmt_edge ) vec ( i ) end do end subroutine print_plain_vector","tags":"","url":"proc/print_plain_vector.html"},{"title":"print_vector – PIC","text":"public  subroutine print_vector(vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type Variables Type Visibility Attributes Name Initial character(len=20), public :: format_selected Source Code subroutine print_vector ( vec , format_type ) !! print a vector implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) ! 1D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_vector ( vec ) else call print_vector_in_format ( vec , format_selected ) end if end subroutine print_vector","tags":"","url":"proc/print_vector.html"},{"title":"print_vector_in_format – PIC","text":"public  subroutine print_vector_in_format(vec, format_type, n_elements) private subroutine that prints a vector in a format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_elements Variables Type Visibility Attributes Name Initial character(len=1), public :: close_bracket integer(kind=default_int), public :: i integer(kind=default_int), public :: loop_bound_i character(len=1), public :: open_bracket Source Code subroutine print_vector_in_format ( vec , format_type , n_elements ) !! private subroutine that prints a vector in a format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy integer ( kind = default_int ), intent ( in ), optional :: n_elements character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ) :: i , loop_bound_i if ( present ( n_elements )) then loop_bound_i = n_elements else loop_bound_i = size ( vec ) end if ! Select brackets based on format type if ( format_type == 'NUMPY' ) then open_bracket = '[' close_bracket = ']' else if ( format_type == 'MATHEMATICA' ) then open_bracket = '{' close_bracket = '}' else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = '[' close_bracket = ']' end if ! Print the vector in the selected format print * , \"Vector (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) vec ( i ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) vec ( i ) end if end do print * , close_bracket end subroutine print_vector_in_format","tags":"","url":"proc/print_vector_in_format.html"},{"title":"print_vector_n – PIC","text":"public  subroutine print_vector_n(vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Variables Type Visibility Attributes Name Initial character(len=20), public :: format_selected Source Code subroutine print_vector_n ( vec , n_elements , format_type ) !! print a vector from start up to n_elements implicit none ( type , external ) real ( dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected integer ( kind = default_int ), intent ( in ) :: n_elements ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_vector ( vec , n_elements ) else call print_vector_in_format ( vec , format_selected , n_elements ) end if end subroutine print_vector_n","tags":"","url":"proc/print_vector_n.html"},{"title":"print_array – PIC","text":"public interface print_array general interface for printing a one or two dimensional array Module Procedures public  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type public  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array.html"},{"title":"print_array_with_bounds – PIC","text":"public interface print_array_with_bounds general interface to print an array within certain bounds Module Procedures public  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type public  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array_with_bounds.html"},{"title":"pic_print_banner – PIC","text":"public  subroutine pic_print_banner() Arguments None Source Code subroutine pic_print_banner implicit none print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"\" print * , \"========================================\" print * , \"\" end subroutine pic_print_banner","tags":"","url":"proc/pic_print_banner.html"},{"title":"pic_comm_finalize – PIC","text":"public  subroutine pic_comm_finalize(self) finalize the MPI library Type Bound pic_comm Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self Source Code subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm ), intent ( inout ) :: self #ifdef USE_MPI integer ( default_int ) :: ierr call MPI_Finalize ( ierr ) #endif end subroutine pic_comm_finalize","tags":"","url":"proc/pic_comm_finalize.html"},{"title":"pic_comm_init – PIC","text":"public  subroutine pic_comm_init(self) initilalize the MPI library and get the size and rank variables Type Bound pic_comm Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self Variables Type Visibility Attributes Name Initial integer(kind=default_int), public :: ierr integer(kind=default_int), public :: rank integer(kind=default_int), public :: size Source Code subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm ), intent ( inout ) :: self integer ( default_int ) :: ierr , rank , size #ifdef USE_MPI call MPI_Init ( ierr ) self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank #else self % m_size = 1 self % m_rank = 0 #endif end subroutine pic_comm_init","tags":"","url":"proc/pic_comm_init.html"},{"title":"get_first_arg_from_command_line – PIC","text":"public  function get_first_arg_from_command_line() result(filename) obtain the first argument from the command line Arguments None Return Value character(len=255) Variables Type Visibility Attributes Name Initial character(len=255), public :: arg integer(kind=default_int), public :: num_args Source Code function get_first_arg_from_command_line () result ( filename ) !! obtain the first argument from the command line character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , '(A)' ) 'Usage: ./my_executable <filename>' stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line","tags":"","url":"proc/get_first_arg_from_command_line.html"},{"title":"to_string_char – PIC","text":"public  function to_string_char(c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=500), public :: str Source Code function to_string_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_string_char","tags":"","url":"proc/to_string_char.html"},{"title":"to_string_dp – PIC","text":"public  function to_string_dp(r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=50), public :: str Source Code function to_string_dp ( r ) result ( trimmed_str ) !! transform a real to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(F0.12)' ) r ! Convert real to string with 3 decimal places trimmed_str = trim ( str ) end function to_string_dp","tags":"","url":"proc/to_string_dp.html"},{"title":"to_string_int32 – PIC","text":"public  function to_string_int32(i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=50), public :: str Source Code function to_string_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(I0)' ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int32","tags":"","url":"proc/to_string_int32.html"},{"title":"to_string_int64 – PIC","text":"public  function to_string_int64(i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=50), public :: str Source Code function to_string_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(I0)' ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int64","tags":"","url":"proc/to_string_int64.html"},{"title":"to_string_logical – PIC","text":"public  function to_string_logical(l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=5), public :: str Source Code function to_string_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = 'TRUE' else str = 'FALSE' end if trimmed_str = trim ( str ) end function to_string_logical","tags":"","url":"proc/to_string_logical.html"},{"title":"to_string – PIC","text":"public interface to_string public interface to transform variables to strings Module Procedures public  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_dp (r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable public  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable public  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable","tags":"","url":"interface/to_string.html"},{"title":"collect_pic_string_utils_tests – PIC","text":"public  subroutine collect_pic_string_utils_tests(testsuite2) Arguments Type Intent Optional Attributes Name type(unittest_type), intent(out), allocatable :: testsuite2 (:) Source Code subroutine collect_pic_string_utils_tests ( testsuite2 ) type ( unittest_type ), allocatable , intent ( out ) :: testsuite2 (:) integer , parameter :: ntests = 5 allocate ( testsuite2 ( ntests )) testsuite2 ( 1 ) = new_unittest ( \"test_to_string_int32\" , test_to_string_int32 ) testsuite2 ( 2 ) = new_unittest ( \"test_to_string_int64\" , test_to_string_int64 ) testsuite2 ( 3 ) = new_unittest ( \"test_to_string_dp\" , test_to_string_dp ) testsuite2 ( 4 ) = new_unittest ( \"test_to_string_char\" , test_to_string_char ) testsuite2 ( 5 ) = new_unittest ( \"test_to_string_logical\" , test_to_string_logical ) end subroutine collect_pic_string_utils_tests","tags":"","url":"proc/collect_pic_string_utils_tests.html"},{"title":"collect_suite1 – PIC","text":"public  subroutine collect_suite1(testsuite) Collect all exported unit tests Arguments Type Intent Optional Attributes Name type(unittest_type), intent(out), allocatable :: testsuite (:) Collection of tests Source Code subroutine collect_suite1 ( testsuite ) !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) integer , parameter :: ntests = 2 allocate ( testsuite ( ntests )) testsuite ( 1 ) = new_unittest ( \"valid\" , test_valid ) testsuite ( 2 ) = new_unittest ( \"invalid\" , test_invalid , should_fail = . true .) end subroutine collect_suite1","tags":"","url":"proc/collect_suite1.html"},{"title":"print_asterisk_row – PIC","text":"public  subroutine print_asterisk_row(n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print Variables Type Visibility Attributes Name Initial integer(kind=default_int), public :: i Source Code subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , '(A)' , advance = 'no' ) '*' end do write ( * , * ) end subroutine print_asterisk_row","tags":"","url":"proc/print_asterisk_row.html"},{"title":"pic_logger – PIC","text":"this is the logger module Uses pic_types pic_global_definitions Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: debug_level = 10 integer(kind=default_int), public, parameter :: error_level = 5 type( logger_type ), public :: global_logger integer(kind=default_int), public, parameter :: info_level = 8 integer(kind=default_int), public, parameter :: performance_level = 7 integer(kind=default_int), public, parameter :: verbose_level = 9 integer(kind=default_int), public, parameter :: warning_level = 6 Derived Types type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info Type-Bound Procedures procedure, public, pass(self) :: close_log_file procedure, public, pass(self) :: configuration procedure, public, pass(self) :: configure procedure, public, pass(self) :: configure_file_output procedure, public, pass(self) :: debug procedure, public, pass(self) :: error procedure, public, pass(self) :: info procedure, public, pass(self) :: log procedure, public, pass(self) :: performance procedure, public, pass(self) :: verbose procedure, public, pass(self) :: warning","tags":"","url":"module/pic_logger.html"},{"title":"pic_debugging_tools – PIC","text":"simple single include for printing routines Uses pic_string_utils pic_matrix_printer","tags":"","url":"module/pic_debugging_tools.html"},{"title":"pic_matrix_printer – PIC","text":"Matrix printing module Uses pic_types pic_string_utils Variables Type Visibility Attributes Name Initial character(len=*), public, parameter :: fmt_edge = '(F14.10)' no comma format character(len=*), public, parameter :: fmt_in = '(F14.10, \", \")' comma format for between arrays Interfaces public        interface print_array general interface for printing a one or two dimensional array public  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type public  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type public        interface print_array_with_bounds general interface to print an array within certain bounds public  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type public  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type Subroutines public  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type public  subroutine print_matrix_in_format (mat, format_type, n_cols, n_rows) private subroutine to print a matrix in format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows public  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type public  subroutine print_plain_matrix (mat, n_cols, n_rows) private subroutine that prints a plain matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows public  subroutine print_plain_vector (vec, n_elements) private subroutine that prints a vector of n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in), optional :: n_elements public  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type public  subroutine print_vector_in_format (vec, format_type, n_elements) private subroutine that prints a vector in a format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_elements public  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type","tags":"","url":"module/pic_matrix_printer.html"},{"title":"pic – PIC","text":"Subroutines public  subroutine pic_print_banner () Arguments None","tags":"","url":"module/pic.html"},{"title":"pic_types – PIC","text":"main module for defining types for integer and double precision Uses iso_fortran_env Variables Type Visibility Attributes Name Initial integer, public, parameter :: default_complex = dp default complex is double precision integer, public, parameter :: default_int = int32 default integer kind, be careful if you are using fdefault-size=8 integer, public, parameter :: default_real = dp naturally, our default real is double precision integer, public, parameter :: dp = SELECTED_REAL_KIND(15, 307) double precision variable integer, public, parameter :: qp = SELECTED_REAL_KIND(33, 4931) quadruple precision variable integer, public, parameter :: sp = SELECTED_REAL_KIND(6, 37) single precision variable","tags":"","url":"module/pic_types.html"},{"title":"pic_mpi – PIC","text":"General MPI interface module Uses pic_types Variables Type Visibility Attributes Name Initial type( pic_comm ), public :: world_comm our world comm Derived Types type, public :: pic_comm custom data type that holds the MPI communicators Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: dummy_comm if we don’t use MPI use an integer for a comm integer(kind=default_int), public :: m_rank MPI rank integer(kind=default_int), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize procedure, public :: init => pic_comm_init Subroutines public  subroutine pic_comm_finalize (self) finalize the MPI library Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self public  subroutine pic_comm_init (self) initilalize the MPI library and get the size and rank variables Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self","tags":"","url":"module/pic_mpi.html"},{"title":"pic_command_line – PIC","text":"command line interaction module Uses pic_types Functions public  function get_first_arg_from_command_line () result(filename) obtain the first argument from the command line Arguments None Return Value character(len=255)","tags":"","url":"module/pic_command_line.html"},{"title":"pic_string_utils – PIC","text":"General string utilities Uses pic_types Interfaces public        interface to_string public interface to transform variables to strings public  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_dp (r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable public  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable public  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable Functions public  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable public  function to_string_dp (r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable public  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable public  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable","tags":"","url":"module/pic_string_utils.html"},{"title":"test_pic_string_utils – PIC","text":"Uses pic_types testdrive pic_string_utils Subroutines public  subroutine collect_pic_string_utils_tests (testsuite2) Arguments Type Intent Optional Attributes Name type(unittest_type), intent(out), allocatable :: testsuite2 (:)","tags":"","url":"module/test_pic_string_utils.html"},{"title":"test_suite1 – PIC","text":"Uses testdrive iso_fortran_env Subroutines public  subroutine collect_suite1 (testsuite) Collect all exported unit tests Arguments Type Intent Optional Attributes Name type(unittest_type), intent(out), allocatable :: testsuite (:) Collection of tests","tags":"","url":"module/test_suite1.html"},{"title":"pic_global_definitions – PIC","text":"Global definitions for input output Uses pic_types Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: logfile_unit = 99 assign output unit 99 for the logfile integer(kind=default_int), public, parameter :: stdout = 6 assign output unit 6 for stdout","tags":"","url":"module/pic_global_definitions.html"},{"title":"pic_output_helpers – PIC","text":"Assorted output helper routines Uses pic_types Subroutines public  subroutine print_asterisk_row (n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print","tags":"","url":"module/pic_output_helpers.html"},{"title":"pic_tester – PIC","text":"Uses test_pic_string_utils testdrive iso_fortran_env test_suite1 Variables Type Attributes Name Initial character(len=*), parameter :: fmt = '(\"#\", *(1x, a))' integer :: is integer, parameter :: ntest_suites = 2 number of tests, this number needs to be modified and equal to the number of files we have with unit tests integer :: stat character(len=:), allocatable :: suite_name character(len=:), allocatable :: test_name type(testsuite_type), allocatable :: testsuites (:) Source Code program pic_tester use , intrinsic :: iso_fortran_env , only : error_unit use testdrive , only : run_testsuite , new_testsuite , testsuite_type , & & select_suite , run_selected , get_argument use test_suite1 , only : collect_suite1 use test_pic_string_utils , only : collect_pic_string_utils_tests ! add here the module you want to test implicit none integer :: stat , is integer , parameter :: ntest_suites = 2 !! number of tests, this number needs to be modified and equal to the number of files we have with unit tests character ( len = :), allocatable :: suite_name , test_name type ( testsuite_type ), allocatable :: testsuites (:) character ( len =* ), parameter :: fmt = '(\"#\", *(1x, a))' stat = 0 allocate ( testsuites ( ntest_suites )) ! here you add another test suite to the array testsuites ( 1 ) = new_testsuite ( \"base_utils\" , collect_suite1 ) testsuites ( 2 ) = new_testsuite ( \"pic_string_utils\" , collect_pic_string_utils_tests ) !testsuites(3) = new_testsuite(\"suite3\", collect_integrator_tests) !testsuites(4) = new_testsuite(\"suite4\", collect_pic_math_utils_test) call get_argument ( 1 , suite_name ) call get_argument ( 2 , test_name ) if ( allocated ( suite_name )) then is = select_suite ( testsuites , suite_name ) if ( is > 0 . and . is <= size ( testsuites )) then if ( allocated ( test_name )) then write ( error_unit , fmt ) \"Suite:\" , testsuites ( is )% name call run_selected ( testsuites ( is )% collect , test_name , error_unit , stat ) if ( stat < 0 ) then error stop 1 end if else write ( error_unit , fmt ) \"Testing:\" , testsuites ( is )% name call run_testsuite ( testsuites ( is )% collect , error_unit , stat ) end if else write ( error_unit , fmt ) \"Available testsuites\" do is = 1 , size ( testsuites ) write ( error_unit , fmt ) \"-\" , testsuites ( is )% name end do error stop 1 end if else do is = 1 , size ( testsuites ) write ( error_unit , fmt ) \"Testing all:\" , testsuites ( is )% name call run_testsuite ( testsuites ( is )% collect , error_unit , stat ) end do end if if ( stat > 0 ) then write ( error_unit , '(i0, 1x, a)' ) stat , \"test(s) failed!\" error stop 1 end if end program pic_tester","tags":"","url":"program/pic_tester.html"},{"title":"main_tests.f90 – PIC","text":"Source Code program pic_tester use , intrinsic :: iso_fortran_env , only : error_unit use testdrive , only : run_testsuite , new_testsuite , testsuite_type , & & select_suite , run_selected , get_argument use test_suite1 , only : collect_suite1 use test_pic_string_utils , only : collect_pic_string_utils_tests ! add here the module you want to test implicit none integer :: stat , is integer , parameter :: ntest_suites = 2 !! number of tests, this number needs to be modified and equal to the number of files we have with unit tests character ( len = :), allocatable :: suite_name , test_name type ( testsuite_type ), allocatable :: testsuites (:) character ( len =* ), parameter :: fmt = '(\"#\", *(1x, a))' stat = 0 allocate ( testsuites ( ntest_suites )) ! here you add another test suite to the array testsuites ( 1 ) = new_testsuite ( \"base_utils\" , collect_suite1 ) testsuites ( 2 ) = new_testsuite ( \"pic_string_utils\" , collect_pic_string_utils_tests ) !testsuites(3) = new_testsuite(\"suite3\", collect_integrator_tests) !testsuites(4) = new_testsuite(\"suite4\", collect_pic_math_utils_test) call get_argument ( 1 , suite_name ) call get_argument ( 2 , test_name ) if ( allocated ( suite_name )) then is = select_suite ( testsuites , suite_name ) if ( is > 0 . and . is <= size ( testsuites )) then if ( allocated ( test_name )) then write ( error_unit , fmt ) \"Suite:\" , testsuites ( is )% name call run_selected ( testsuites ( is )% collect , test_name , error_unit , stat ) if ( stat < 0 ) then error stop 1 end if else write ( error_unit , fmt ) \"Testing:\" , testsuites ( is )% name call run_testsuite ( testsuites ( is )% collect , error_unit , stat ) end if else write ( error_unit , fmt ) \"Available testsuites\" do is = 1 , size ( testsuites ) write ( error_unit , fmt ) \"-\" , testsuites ( is )% name end do error stop 1 end if else do is = 1 , size ( testsuites ) write ( error_unit , fmt ) \"Testing all:\" , testsuites ( is )% name call run_testsuite ( testsuites ( is )% collect , error_unit , stat ) end do end if if ( stat > 0 ) then write ( error_unit , '(i0, 1x, a)' ) stat , \"test(s) failed!\" error stop 1 end if end program pic_tester","tags":"","url":"sourcefile/main_tests.f90.html"},{"title":"pic_logger.f90 – PIC","text":"the pic_logger.f90 is the base file that defines the logger function\nthis is heavily inspired by the logger from the standard library\nbut with some key changes for my purposes.\nThe logger will be the way in which the code interacts\nwith the output to console and files Source Code !! the pic_logger.f90 is the base file that defines the logger function !! this is heavily inspired by the logger from the standard library !! but with some key changes for my purposes. !! The logger will be the way in which the code interacts !! with the output to console and files module pic_logger !! this is the logger module use pic_types , only : default_int use pic_global_definitions , only : stdout , logfile_unit implicit none ( type , external ) private public :: global_logger , logger_type character ( * ), parameter :: name = 'pic_logger' integer ( default_int ), parameter , public :: & debug_level = 10 , & verbose_level = 9 , & info_level = 8 , & performance_level = 7 , & warning_level = 6 , & error_level = 5 type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: configure_file_output procedure , public , pass ( self ) :: close_log_file procedure , public , pass ( self ) :: log procedure , public , pass ( self ) :: debug procedure , public , pass ( self ) :: verbose procedure , public , pass ( self ) :: info procedure , public , pass ( self ) :: performance procedure , public , pass ( self ) :: warning procedure , public , pass ( self ) :: error end type logger_type type ( logger_type ) :: global_logger contains pure subroutine configuration ( self , level ) class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration pure subroutine configure ( self , level ) class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure subroutine configure_file_output ( self , filename , level ) class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = 'replace' , action = 'write' , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) 'ERROR: Failed to open log file: ' , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output subroutine close_log_file ( self ) class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file subroutine debug ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug subroutine verbose ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose subroutine info ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info subroutine warning ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning subroutine performance ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance subroutine error ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error subroutine write_log_line ( unit , level , message , module , procedure ) integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line subroutine log ( self , level , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( 'DEBUG' ) log_level_value = debug_level case ( 'VERBOSE' ) log_level_value = verbose_level case ( 'INFO' ) log_level_value = info_level case ( 'WARNING' ) log_level_value = warning_level case ( 'PERFORMANCE' ) log_level_value = performance_level case ( 'ERROR' ) log_level_value = error_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log end module pic_logger","tags":"","url":"sourcefile/pic_logger.f90.html"},{"title":"pic_debugging_tools.f90 – PIC","text":"This file is intended to contain tools that can be useful when debugging\nlarge programs, simple printing routines, extracting data from an array etc. Source Code !! This file is intended to contain tools that can be useful when debugging !! large programs, simple printing routines, extracting data from an array etc. module pic_debugging_tools !! simple single include for printing routines use pic_matrix_printer , only : print_array , print_array_with_bounds use pic_string_utils , only : to_string implicit none ( type , external ) public contains end module pic_debugging_tools","tags":"","url":"sourcefile/pic_debugging_tools.f90.html"},{"title":"pic_matrix_printer.f90 – PIC","text":"Routines to print vectors and matrices, currently no support for higher\ndimensional arrays. Need to fix that! Source Code !! Routines to print vectors and matrices, currently no support for higher !! dimensional arrays. Need to fix that! module pic_matrix_printer !! Matrix printing module use pic_types , only : dp , default_int use pic_string_utils , only : to_string implicit none ( type , external ) public interface print_array !! general interface for printing a one or two dimensional array module procedure print_vector module procedure print_matrix end interface print_array interface print_array_with_bounds !! general interface to print an array within certain bounds module procedure print_vector_n module procedure print_matrix_m_n end interface print_array_with_bounds character ( len =* ), parameter :: fmt_edge = '(F14.10)' !! no comma format character ( len =* ), parameter :: fmt_in = '(F14.10, \", \")' !! comma format for between arrays contains subroutine print_vector_n ( vec , n_elements , format_type ) !! print a vector from start up to n_elements implicit none ( type , external ) real ( dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected integer ( kind = default_int ), intent ( in ) :: n_elements ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_vector ( vec , n_elements ) else call print_vector_in_format ( vec , format_selected , n_elements ) end if end subroutine print_vector_n subroutine print_vector ( vec , format_type ) !! print a vector implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) ! 1D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_vector ( vec ) else call print_vector_in_format ( vec , format_selected ) end if end subroutine print_vector subroutine print_matrix_m_n ( mat , n_cols , n_rows , format_type ) !! Print a matrix of n_cols by n_rows implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array integer ( kind = default_int ), intent ( in ) :: n_cols , n_rows character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_matrix ( mat , n_cols , n_rows ) else call print_matrix_in_format ( mat , format_selected , n_cols , n_rows ) end if end subroutine print_matrix_m_n subroutine print_matrix ( mat , format_type ) !! print a matrix in a given format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = 'PLAIN' end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == 'PLAIN' ) then call print_plain_matrix ( mat ) else call print_matrix_in_format ( mat , format_selected ) end if end subroutine print_matrix subroutine print_plain_vector ( vec , n_elements ) !! private subroutine that prints a vector of n_elements implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) integer ( kind = default_int ), intent ( in ), optional :: n_elements integer ( kind = default_int ) :: i , loop_bound if ( present ( n_elements )) then loop_bound = n_elements else loop_bound = size ( vec ) end if print * , \"Vector (Plain format):\" do i = 1 , loop_bound write ( * , fmt_edge ) vec ( i ) end do end subroutine print_plain_vector subroutine print_plain_matrix ( mat , n_cols , n_rows ) !! private subroutine that prints a plain matrix of n_cols by n_rows implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if print * , \"Matrix (Plain format):\" do i = 1 , loop_bound_i do j = 1 , loop_bound_j if ( j == loop_bound_j ) then write ( * , fmt_edge , advance = \"yes\" ) mat ( i , j ) ! Last element in the row, new line else write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) ! In-between elements end if end do end do end subroutine print_plain_matrix subroutine print_vector_in_format ( vec , format_type , n_elements ) !! private subroutine that prints a vector in a format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy integer ( kind = default_int ), intent ( in ), optional :: n_elements character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ) :: i , loop_bound_i if ( present ( n_elements )) then loop_bound_i = n_elements else loop_bound_i = size ( vec ) end if ! Select brackets based on format type if ( format_type == 'NUMPY' ) then open_bracket = '[' close_bracket = ']' else if ( format_type == 'MATHEMATICA' ) then open_bracket = '{' close_bracket = '}' else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = '[' close_bracket = ']' end if ! Print the vector in the selected format print * , \"Vector (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) vec ( i ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) vec ( i ) end if end do print * , close_bracket end subroutine print_vector_in_format subroutine print_matrix_in_format ( mat , format_type , n_cols , n_rows ) !! private subroutine to print a matrix in format implicit none ( type , external ) real ( kind = dp ), intent ( in ) :: mat (:, :) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if ! Select brackets based on format type if ( format_type == 'NUMPY' ) then open_bracket = '[' close_bracket = ']' else if ( format_type == 'MATHEMATICA' ) then open_bracket = '{' close_bracket = '}' else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = '[' close_bracket = ']' end if ! Print the matrix in the selected format print * , \"Matrix (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i write ( * , '(A)' , advance = \"no\" ) open_bracket ! Start of a row do j = 1 , loop_bound_j if ( j == loop_bound_j ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) mat ( i , j ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) end if end do if ( i == loop_bound_i ) then print * , close_bracket ! Close bracket without a comma for the last row else print * , close_bracket , \",\" ! Close bracket with a comma for all other rows end if end do print * , close_bracket end subroutine print_matrix_in_format end module pic_matrix_printer","tags":"","url":"sourcefile/pic_matrix_printer.f90.html"},{"title":"pic.f90 – PIC","text":"Source Code module pic implicit none contains subroutine pic_print_banner implicit none print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"\" print * , \"========================================\" print * , \"\" end subroutine pic_print_banner end module pic","tags":"","url":"sourcefile/pic.f90.html"},{"title":"pic_types.F90 – PIC","text":"pic_types.F90 controls the standarized sizes for the datatypes across\npic, this is key for interfacing with other codes specially those that\nuse default sizes Source Code !! pic_types.F90 controls the standarized sizes for the datatypes across !! pic, this is key for interfacing with other codes specially those that !! use default sizes module pic_types !! main module for defining types for integer and double precision use iso_fortran_env , only : int32 , int64 implicit none ( type , external ) public ! Define kinds for different data types ! int32 and int64 are defined in the iso_fortran_env, if you need to change things please do so here integer , parameter :: sp = SELECTED_REAL_KIND ( 6 , 37 ) !! single precision variable integer , parameter :: dp = SELECTED_REAL_KIND ( 15 , 307 ) !! double precision variable integer , parameter :: qp = SELECTED_REAL_KIND ( 33 , 4931 ) !! quadruple precision variable ! Define default types #ifdef USE_INT8 integer , parameter :: default_int = int64 #else integer , parameter :: default_int = int32 #endif !! default integer kind, be careful if you are using fdefault-size=8 integer , parameter :: default_real = dp !! naturally, our default real is double precision integer , parameter :: default_complex = dp !! default complex is double precision end module pic_types","tags":"","url":"sourcefile/pic_types.f90.html"},{"title":"pic_mpi.F90 – PIC","text":"The pic_mpi.F90 file is the main interface to the MPI implementation, it should\nbe done in such a way that we can compile the library with and without MPI\nit will be a pain in general, but meh, let’s see what we can do Source Code !! The pic_mpi.F90 file is the main interface to the MPI implementation, it should !! be done in such a way that we can compile the library with and without MPI !! it will be a pain in general, but meh, let's see what we can do module pic_mpi !! General MPI interface module use pic_types , only : default_int #ifdef USE_MPI use mpi_f08 #endif implicit none type :: pic_comm !! custom data type that holds the MPI communicators private #ifdef USE_MPI type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface #else integer ( default_int ), public :: dummy_comm !! if we don't use MPI use an integer for a comm #endif integer ( default_int ), public :: m_rank !! MPI rank integer ( default_int ), public :: m_size !! MPI size contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm type ( pic_comm ), public :: world_comm !! our world comm contains subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm ), intent ( inout ) :: self integer ( default_int ) :: ierr , rank , size #ifdef USE_MPI call MPI_Init ( ierr ) self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank #else self % m_size = 1 self % m_rank = 0 #endif end subroutine pic_comm_init subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm ), intent ( inout ) :: self #ifdef USE_MPI integer ( default_int ) :: ierr call MPI_Finalize ( ierr ) #endif end subroutine pic_comm_finalize end module pic_mpi","tags":"","url":"sourcefile/pic_mpi.f90.html"},{"title":"pic_command_line.f90 – PIC","text":"The pic_command_line.f90 file will contain all routines that will interact with the command line Source Code !! The pic_command_line.f90 file will contain all routines that will interact with the command line module pic_command_line !! command line interaction module use pic_types , only : default_int implicit none ( type , external ) public contains function get_first_arg_from_command_line () result ( filename ) !! obtain the first argument from the command line character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , '(A)' ) 'Usage: ./my_executable <filename>' stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line end module pic_command_line","tags":"","url":"sourcefile/pic_command_line.f90.html"},{"title":"pic_string_utils.f90 – PIC","text":"Life is easier when we have strings. This file\ncontains the necessary routines to transform key data\ntypes into strings Source Code !! Life is easier when we have strings. This file !! contains the necessary routines to transform key data !! types into strings module pic_string_utils !! General string utilities use pic_types , only : sp , dp , int32 , int64 implicit none ( type , external ) ! Generic interface for to_string to handle different types public interface to_string !! public interface to transform variables to strings module procedure to_string_int32 module procedure to_string_int64 module procedure to_string_dp module procedure to_string_char module procedure to_string_logical end interface contains function to_string_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(I0)' ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int32 function to_string_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(I0)' ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int64 function to_string_dp ( r ) result ( trimmed_str ) !! transform a real to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , '(F0.12)' ) r ! Convert real to string with 3 decimal places trimmed_str = trim ( str ) end function to_string_dp function to_string_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_string_char function to_string_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = 'TRUE' else str = 'FALSE' end if trimmed_str = trim ( str ) end function to_string_logical end module pic_string_utils","tags":"","url":"sourcefile/pic_string_utils.f90.html"},{"title":"test_pic_string_utils.f90 – PIC","text":"Source Code module test_pic_string_utils use testdrive , only : new_unittest , unittest_type , error_type , check use pic_string_utils , only : to_string use pic_types , only : int32 , int64 , dp implicit none private public :: collect_pic_string_utils_tests contains subroutine collect_pic_string_utils_tests ( testsuite2 ) type ( unittest_type ), allocatable , intent ( out ) :: testsuite2 (:) integer , parameter :: ntests = 5 allocate ( testsuite2 ( ntests )) testsuite2 ( 1 ) = new_unittest ( \"test_to_string_int32\" , test_to_string_int32 ) testsuite2 ( 2 ) = new_unittest ( \"test_to_string_int64\" , test_to_string_int64 ) testsuite2 ( 3 ) = new_unittest ( \"test_to_string_dp\" , test_to_string_dp ) testsuite2 ( 4 ) = new_unittest ( \"test_to_string_char\" , test_to_string_char ) testsuite2 ( 5 ) = new_unittest ( \"test_to_string_logical\" , test_to_string_logical ) end subroutine collect_pic_string_utils_tests subroutine test_to_string_int32 ( error ) type ( error_type ), allocatable , intent ( out ) :: error character ( len = 50 ) :: result result = to_string ( int ( 123 , kind = int32 )) call check ( error , result == \"123\" ) end subroutine test_to_string_int32 subroutine test_to_string_int64 ( error ) type ( error_type ), allocatable , intent ( out ) :: error character ( len = 50 ) :: result result = to_string ( int ( 12345678 , kind = int64 )) call check ( error , result == \"12345678\" ) end subroutine test_to_string_int64 subroutine test_to_string_dp ( error ) type ( error_type ), allocatable , intent ( out ) :: error character ( len = 50 ) :: result result = to_string ( 12 3.456_dp ) call check ( error , result == \"123.456000000000\" ) end subroutine test_to_string_dp subroutine test_to_string_char ( error ) type ( error_type ), allocatable , intent ( out ) :: error character ( len = 500 ) :: result result = to_string ( \"Hello, world!\" ) call check ( error , result == \"Hello, world!\" ) end subroutine test_to_string_char subroutine test_to_string_logical ( error ) type ( error_type ), allocatable , intent ( out ) :: error character ( len = 5 ) :: result result = to_string (. true .) call check ( error , result == \"TRUE\" ) if ( allocated ( error )) return result = to_string (. false .) call check ( error , result == \"FALSE\" ) end subroutine test_to_string_logical end module test_pic_string_utils","tags":"","url":"sourcefile/test_pic_string_utils.f90.html"},{"title":"test_base_utils.f90 – PIC","text":"Source Code module test_suite1 use testdrive , only : new_unittest , unittest_type , error_type , check , test_failed use , intrinsic :: iso_fortran_env , only : error_unit implicit none private public :: collect_suite1 contains !> Collect all exported unit tests subroutine collect_suite1 ( testsuite ) !> Collection of tests type ( unittest_type ), allocatable , intent ( out ) :: testsuite (:) integer , parameter :: ntests = 2 allocate ( testsuite ( ntests )) testsuite ( 1 ) = new_unittest ( \"valid\" , test_valid ) testsuite ( 2 ) = new_unittest ( \"invalid\" , test_invalid , should_fail = . true .) end subroutine collect_suite1 subroutine test_valid ( error ) type ( error_type ), allocatable , intent ( out ) :: error call check ( error , 1 + 2 == 3 ) if ( allocated ( error )) return end subroutine test_valid subroutine test_invalid ( error ) type ( error_type ), allocatable , intent ( out ) :: error integer :: i = 1 ! ... if ( i . eq . 1 ) then call test_failed ( error , \"Custom check failed\" ) return end if end subroutine test_invalid end module test_suite1","tags":"","url":"sourcefile/test_base_utils.f90.html"},{"title":"pic_global_definitions.f90 – PIC","text":"this is an experimental file that contains definitions\nthat will be uses across the program, for example input/output units\nthat PIC will use across things. Source Code !! this is an experimental file that contains definitions !! that will be uses across the program, for example input/output units !! that PIC will use across things. module pic_global_definitions !! Global definitions for input output use pic_types , only : default_int implicit none public integer ( default_int ), parameter :: stdout = 6 !! assign output unit 6 for stdout integer ( default_int ), parameter :: logfile_unit = 99 !! assign output unit 99 for the logfile end module pic_global_definitions","tags":"","url":"sourcefile/pic_global_definitions.f90.html"},{"title":"pic_output_helpers.f90 – PIC","text":"this file contains “helper” routines, for example printing\na set amount of x characters to creates tables, etc. Source Code !! this file contains \"helper\" routines, for example printing !! a set amount of x characters to creates tables, etc. module pic_output_helpers !! Assorted output helper routines use pic_types , only : default_int implicit none ( type , external ) public contains subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , '(A)' , advance = 'no' ) '*' end do write ( * , * ) end subroutine print_asterisk_row end module pic_output_helpers","tags":"","url":"sourcefile/pic_output_helpers.f90.html"}]}