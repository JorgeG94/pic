var tipuesearch = {"pages":[{"title":" PIC ","text":"PIC PIC is named after the Huastec word PIC which means otter. A work in progress on writing a cool backend for Fortan applications focused on Quantum Chemistry software. Building and dependencies There’s two build systems included in the present version, CMake and the Fortran Package Manager . The dependencies of the project are, as of now, CMake (if using cmake), MPI, OpenMP, and a BLAS/LAPACK library. Documentation The code itself is documented using FORD and the documentation is available here . Comments in the code that are prefixed with !! are considered documentation comments and will be processed by FORD. Comments without that prefix are considered regular comments and will not be processed by FORD. So, please do not use !! for your comments unless you want them to be included in the documentation. CMake CMake offers a very modular build of PIC, the following options are available and can be triggered by -DPIC_ENABLE_XYZ=ON/OFF Option Name Default Description PIC_DEFAULT_INT8 OFF Use 8-byte integers as default PIC_ENABLE_MPI OFF Enable the use of MPI in PIC PIC_ENABLE_OMP OFF Enable the use of OpenMP in PIC PIC_ENABLE_BLAS OFF Enable BLAS/LAPACK libraries in PIC PIC_ENABLE_TESTING ON Enable testing for PIC PIC_ENABLE_JONQUIL OFF Enable Jonquil for JSON/TOML handling Advanced options: Option Name Default Description PIC_USE_VAPAA OFF Use vapaa for binding to MPI Information on vapaa see here which is my\npersonal fork which is pulled from here, and Jeff’s project . Will update to use the orignal project at a later date. Building: mkdir build\ncd build\ncmake ../\nmake -j\nctest FPM Install the FPM following the instructions and then simply: fpm build Contributing Please see the contributing guidelines for information on how to contribute to the project. Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"flop_recorder_type – PIC ","text":"type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Inherited by type~~flop_recorder_type~~InheritedByGraph type~flop_recorder_type flop_recorder_type type~flop_rate_type flop_rate_type type~flop_rate_type->type~flop_recorder_type m_flops Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int64), private :: flop_count = 0_int64 Type-Bound Procedures procedure, public, non_overridable :: add => add_flops private  subroutine add_flops (self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public, non_overridable :: get => get_flops private  function get_flops (self) result(flops) Get the int64 number of FLOPs we currently have in the counter Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public, non_overridable :: reset => reset_flop_counter private  subroutine reset_flop_counter (self) Resets the flop counter to 0_int64 Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self Source Code type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure , non_overridable :: add => add_flops procedure , non_overridable :: get => get_flops procedure , non_overridable :: reset => reset_flop_counter end type flop_recorder_type","tags":"","url":"type/flop_recorder_type.html"},{"title":"string_type – PIC ","text":"type, public :: string_type sequence String type holding an arbitrary sequence of characters. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw Constructor public        interface string_type Constructor for new string instances private elemental module function new_string(string) result(new) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental module function new_string_from_integer_int32(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_integer_int64(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_logical_fbool(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: val Return Value type( string_type ) Source Code type :: string_type ! Use the sequence statement below as a hack to prevent extending this type. ! It is not used for storage association. sequence private character ( len = :), allocatable :: raw end type string_type","tags":"","url":"type/string_type.html"},{"title":"run_type – PIC ","text":"type, private :: run_type Used to pass state around in a stack among helper functions for the ORD_SORT and SORT_INDEX algorithms Components Type Visibility Attributes Name Initial integer(kind=int_index), public :: base = 0 integer(kind=int_index), public :: len = 0 Source Code type run_type !! Used to pass state around in a stack among helper functions for the !! `ORD_SORT` and `SORT_INDEX` algorithms integer ( int_index ) :: base = 0 integer ( int_index ) :: len = 0 end type run_type","tags":"","url":"type/run_type.html"},{"title":"device_type – PIC ","text":"type, public :: device_type general device container, contains the id, free, total , and used memory Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: device_id = -1_c_int real(kind=dp), public :: free_mb = 0.0_dp real(kind=dp), public :: total_mb = 0.0_dp real(kind=dp), public :: used_mb = 0.0_dp Type-Bound Procedures procedure, public, non_overridable :: get_device_info => get_gpu_information public  subroutine get_gpu_information (self) call my_device%get_gpu_informatio() style subroutine to populate the object Arguments Type Intent Optional Attributes Name class( device_type ), intent(inout) :: self Source Code type :: device_type !! general device container, contains the id, free, total , and used memory real ( dp ) :: free_mb = 0.0_dp real ( dp ) :: total_mb = 0.0_dp real ( dp ) :: used_mb = 0.0_dp integer ( c_int ) :: device_id = - 1_c_int contains procedure , non_overridable :: get_device_info => get_gpu_information end type device_type","tags":"","url":"type/device_type.html"},{"title":"logger_type – PIC ","text":"type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info logical, private :: log_file_open = .false. integer(kind=default_int), private :: log_file_unit = -1 Type-Bound Procedures procedure, public, pass(self), non_overridable :: close_log_file Close the log file, needs to be called at the end of the program.\nUsage: call my_logger%close_log_file() private  subroutine close_log_file (self) Close the log file, needs to be called at the end of the program Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self procedure, public, pass(self), non_overridable :: configuration Get the current logger verbosity configuration.\nUsage: call my_logger%configuration(level) private pure subroutine configuration (self, level) Get the current logger verbosity configuration Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level procedure, public, pass(self), non_overridable :: configure Configure the logger to be a certain verbosity level.\nUsage: call my_logger%configure(level) private pure subroutine configure (self, level) Configure the logger to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self), non_overridable :: configure_file_output Configure the logger to file to be a certain verbosity level.\nUsage: call my_logger%configure_file_output(filename, level) private  subroutine configure_file_output (self, filename, level) Configure the logger to file to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self), non_overridable :: debug Log a message that will only be printed at the debug level of verbosity.\nUsage: call my_logger%debug(“MESSAGE”) private  subroutine debug (self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: error Log a message that will only be printed at the error level of verbosity.\nUsage: call my_logger%error(“MESSAGE”) private  subroutine error (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: info Log a message that will only be printed at the info level of verbosity.\nUsage: call my_logger%info(“MESSAGE”) private  subroutine info (self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: knowledge Log a message that will only be printed at the knowledge level of verbosity.\nUsage: call my_logger%knowledge(“MESSAGE”) private  subroutine knowledge (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: performance Log a message that will only be printed at the performance level of verbosity.\nUsage: call my_logger%performance(“MESSAGE”) private  subroutine performance (self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: verbose Log a message that will only be printed at the verbose level of verbosity.\nUsage: call my_logger%verbose(“MESSAGE”) private  subroutine verbose (self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self), non_overridable :: warning Log a message that will only be printed at the warning level of verbosity.\nUsage: call my_logger%warning(“MESSAGE”) private  subroutine warning (self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, private, pass(self), non_overridable :: log Processes the message and filters it according to the verbosity level set by the user or the default private  subroutine log (self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ), non_overridable :: configuration !! Get the current logger verbosity configuration. !! Usage: call my_logger%configuration(level) procedure , public , pass ( self ), non_overridable :: configure !! Configure the logger to be a certain verbosity level. !! Usage: call my_logger%configure(level) procedure , public , pass ( self ), non_overridable :: configure_file_output !! Configure the logger to file to be a certain verbosity level. !! Usage: call my_logger%configure_file_output(filename, level) procedure , public , pass ( self ), non_overridable :: close_log_file !! Close the log file, needs to be called at the end of the program. !! Usage: call my_logger%close_log_file() procedure , public , pass ( self ), non_overridable :: debug !! Log a message that will only be printed at the debug level of verbosity. !! Usage: call my_logger%debug(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: verbose !! Log a message that will only be printed at the verbose level of verbosity. !! Usage: call my_logger%verbose(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: info !! Log a message that will only be printed at the info level of verbosity. !! Usage: call my_logger%info(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: performance !! Log a message that will only be printed at the performance level of verbosity. !! Usage: call my_logger%performance(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: warning !! Log a message that will only be printed at the warning level of verbosity. !! Usage: call my_logger%warning(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: error !! Log a message that will only be printed at the error level of verbosity. !! Usage: call my_logger%error(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: knowledge !! Log a message that will only be printed at the knowledge level of verbosity. !! Usage: call my_logger%knowledge(\"MESSAGE\") procedure , private , pass ( self ), non_overridable :: log !! Processes the message and filters it according to the verbosity level set by the user or the default end type logger_type","tags":"","url":"type/logger_type.html"},{"title":"flop_rate_type – PIC ","text":"type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Inherits type~~flop_rate_type~~InheritsGraph type~flop_rate_type flop_rate_type type~flop_recorder_type flop_recorder_type type~flop_rate_type->type~flop_recorder_type m_flops type~timer_type timer_type type~flop_rate_type->type~timer_type m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), private :: m_flop_rate private by default so that people use the accessor functions type( flop_recorder_type ), private :: m_flops type( timer_type ), private :: m_timer Type-Bound Procedures procedure, public, non_overridable :: add_flops => flop_rate_add_flops private  subroutine flop_rate_add_flops (self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public, non_overridable :: get_flop_rate => flop_rate_get_flop_rate private  function flop_rate_get_flop_rate (self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) procedure, public, non_overridable :: get_flops => flop_rate_get_flops private  function flop_rate_get_flops (self) result(flops) get the number of flops recorded in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public, non_overridable :: get_time => flop_rate_get_time private  function flop_rate_get_time (self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) procedure, public, non_overridable :: report => flop_rate_report private  subroutine flop_rate_report (self) report the flop rate, this will print the flop rate in GFLOP/s Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public, non_overridable :: reset => flop_rate_reset private  subroutine flop_rate_reset (self) reset the flop rate type, this will reset the timer and the flop recorder Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public, non_overridable :: start_time => flop_rate_start_time private  subroutine flop_rate_start_time (self) Calls the start method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public, non_overridable :: stop_time => flop_rate_stop_time private  subroutine flop_rate_stop_time (self) Calls the stop method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Source Code type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( timer_type ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure , non_overridable :: start_time => flop_rate_start_time procedure , non_overridable :: stop_time => flop_rate_stop_time procedure , non_overridable :: add_flops => flop_rate_add_flops procedure , non_overridable :: get_flops => flop_rate_get_flops procedure , non_overridable :: get_time => flop_rate_get_time procedure , non_overridable :: get_flop_rate => flop_rate_get_flop_rate procedure , non_overridable :: report => flop_rate_report procedure , non_overridable :: reset => flop_rate_reset end type flop_rate_type","tags":"","url":"type/flop_rate_type.html"},{"title":"run_type – PIC ","text":"type, private :: run_type Used to pass state around in a stack among helper functions for the ORD_SORT and SORT_INDEX algorithms Components Type Visibility Attributes Name Initial integer(kind=int_index), public :: base = 0 integer(kind=int_index), public :: len = 0 Source Code type run_type !! Used to pass state around in a stack among helper functions for the !! `ORD_SORT` and `SORT_INDEX` algorithms integer ( int_index ) :: base = 0 integer ( int_index ) :: len = 0 end type run_type","tags":"","url":"type/run_type~2.html"},{"title":"timer_type – PIC ","text":"type, public :: timer_type derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp. If PIC is compiled with OpenMP the default\ntimer will be the omp time. This is mostly to minimize problems with threading\nand system clock Inherited by type~~timer_type~~InheritedByGraph type~timer_type timer_type type~flop_rate_type flop_rate_type type~flop_rate_type->type~timer_type m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=default_int), private :: count_rate = 1_default_int logical, private :: is_running = .false. integer(kind=default_int), private :: start_count = 0_default_int real(kind=dp), private :: start_time = 0.0_dp integer(kind=default_int), private :: stop_count = 0_default_int real(kind=dp), private :: stop_time = 0.0_dp real(kind=dp), private :: walltime Type-Bound Procedures procedure, public, non_overridable :: get_elapsed_time => timer_get_elapsed_time private  function timer_get_elapsed_time (self) result(elapsed) Returns the elapsed time as a real(dp) variable Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self Return Value real(kind=dp) procedure, public, non_overridable :: print_time => timer_print_time private  subroutine timer_print_time (self) Prints the elapsed time at the time of calling Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self procedure, public, non_overridable :: start => timer_start private  subroutine timer_start (self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self procedure, public, non_overridable :: stop => timer_stop private  subroutine timer_stop (self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self Source Code type :: timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp. If PIC is compiled with OpenMP the default !! timer will be the omp time. This is mostly to minimize problems with threading !! and system clock private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure , non_overridable :: start => timer_start procedure , non_overridable :: stop => timer_stop procedure , non_overridable :: print_time => timer_print_time procedure , non_overridable :: get_elapsed_time => timer_get_elapsed_time end type timer_type","tags":"","url":"type/timer_type.html"},{"title":"char_decrease_sort – PIC","text":"private pure subroutine char_decrease_sort(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) Calls proc~~char_decrease_sort~~CallsGraph proc~char_decrease_sort char_decrease_sort none~introsort~10 introsort proc~char_decrease_sort->none~introsort~10 none~introsort~10->none~introsort~10 none~heap_sort~10 heap_sort none~introsort~10->none~heap_sort~10 none~insertion_sort~10 insertion_sort none~introsort~10->none~insertion_sort~10 none~partition~10 partition none~introsort~10->none~partition~10 none~max_heapify~10 max_heapify none~heap_sort~10->none~max_heapify~10 none~max_heapify~10->none~max_heapify~10 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~char_decrease_sort~~CalledByGraph proc~char_decrease_sort char_decrease_sort proc~char_sort char_sort proc~char_sort->proc~char_decrease_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine char_decrease_sort ( array ) ! `char_decrease_sort( array )` sorts the input `ARRAY` of type `character(len=*)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `char_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index character ( len = len ( array )) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size character ( len = len ( array )) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest character ( len = len ( array )) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine char_decrease_sort","tags":"","url":"proc/char_decrease_sort.html"},{"title":"char_increase_sort – PIC","text":"private pure subroutine char_increase_sort(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) Calls proc~~char_increase_sort~~CallsGraph proc~char_increase_sort char_increase_sort none~introsort~5 introsort proc~char_increase_sort->none~introsort~5 none~introsort~5->none~introsort~5 none~heap_sort~5 heap_sort none~introsort~5->none~heap_sort~5 none~insertion_sort~5 insertion_sort none~introsort~5->none~insertion_sort~5 none~partition~5 partition none~introsort~5->none~partition~5 none~max_heapify~5 max_heapify none~heap_sort~5->none~max_heapify~5 none~max_heapify~5->none~max_heapify~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~char_increase_sort~~CalledByGraph proc~char_increase_sort char_increase_sort proc~char_sort char_sort proc~char_sort->proc~char_increase_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine char_increase_sort ( array ) ! `char_increase_sort( array )` sorts the input `ARRAY` of type `character(len=*)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `char_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index character ( len = len ( array )) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size character ( len = len ( array )) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest character ( len = len ( array )) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine char_increase_sort","tags":"","url":"proc/char_increase_sort.html"},{"title":"char_sort – PIC","text":"private pure module subroutine char_sort(array, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Calls proc~~char_sort~~CallsGraph proc~char_sort char_sort interface~pic_optional pic_optional proc~char_sort->interface~pic_optional proc~char_decrease_sort char_decrease_sort proc~char_sort->proc~char_decrease_sort proc~char_increase_sort char_increase_sort proc~char_sort->proc~char_increase_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~introsort~10 introsort proc~char_decrease_sort->none~introsort~10 none~introsort~5 introsort proc~char_increase_sort->none~introsort~5 none~introsort~10->none~introsort~10 none~heap_sort~10 heap_sort none~introsort~10->none~heap_sort~10 none~insertion_sort~10 insertion_sort none~introsort~10->none~insertion_sort~10 none~partition~10 partition none~introsort~10->none~partition~10 none~introsort~5->none~introsort~5 none~heap_sort~5 heap_sort none~introsort~5->none~heap_sort~5 none~insertion_sort~5 insertion_sort none~introsort~5->none~insertion_sort~5 none~partition~5 partition none~introsort~5->none~partition~5 none~max_heapify~10 max_heapify none~heap_sort~10->none~max_heapify~10 none~max_heapify~5 max_heapify none~heap_sort~5->none~max_heapify~5 none~max_heapify~10->none~max_heapify~10 none~max_heapify~5->none~max_heapify~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure module subroutine char_sort ( array , reverse ) !! `char_sort( array[, reverse] )` sorts the input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort","tags":"","url":"proc/char_sort.html"},{"title":"dp_decrease_sort – PIC","text":"private pure subroutine dp_decrease_sort(array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) Calls proc~~dp_decrease_sort~~CallsGraph proc~dp_decrease_sort dp_decrease_sort none~introsort~9 introsort proc~dp_decrease_sort->none~introsort~9 none~introsort~9->none~introsort~9 none~heap_sort~9 heap_sort none~introsort~9->none~heap_sort~9 none~insertion_sort~9 insertion_sort none~introsort~9->none~insertion_sort~9 none~partition~9 partition none~introsort~9->none~partition~9 none~max_heapify~9 max_heapify none~heap_sort~9->none~max_heapify~9 none~max_heapify~9->none~max_heapify~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dp_decrease_sort~~CalledByGraph proc~dp_decrease_sort dp_decrease_sort proc~dp_sort dp_sort proc~dp_sort->proc~dp_decrease_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine dp_decrease_sort ( array ) ! `dp_decrease_sort( array )` sorts the input `ARRAY` of type `real(dp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `dp_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( dp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( dp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( dp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine dp_decrease_sort","tags":"","url":"proc/dp_decrease_sort.html"},{"title":"dp_increase_sort – PIC","text":"private pure subroutine dp_increase_sort(array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) Calls proc~~dp_increase_sort~~CallsGraph proc~dp_increase_sort dp_increase_sort none~introsort~4 introsort proc~dp_increase_sort->none~introsort~4 none~introsort~4->none~introsort~4 none~heap_sort~4 heap_sort none~introsort~4->none~heap_sort~4 none~insertion_sort~4 insertion_sort none~introsort~4->none~insertion_sort~4 none~partition~4 partition none~introsort~4->none~partition~4 none~max_heapify~4 max_heapify none~heap_sort~4->none~max_heapify~4 none~max_heapify~4->none~max_heapify~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dp_increase_sort~~CalledByGraph proc~dp_increase_sort dp_increase_sort proc~dp_sort dp_sort proc~dp_sort->proc~dp_increase_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine dp_increase_sort ( array ) ! `dp_increase_sort( array )` sorts the input `ARRAY` of type `real(dp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `dp_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( dp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( dp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( dp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine dp_increase_sort","tags":"","url":"proc/dp_increase_sort.html"},{"title":"dp_sort – PIC","text":"private pure module subroutine dp_sort(array, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Calls proc~~dp_sort~~CallsGraph proc~dp_sort dp_sort interface~pic_optional pic_optional proc~dp_sort->interface~pic_optional proc~dp_decrease_sort dp_decrease_sort proc~dp_sort->proc~dp_decrease_sort proc~dp_increase_sort dp_increase_sort proc~dp_sort->proc~dp_increase_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~introsort~9 introsort proc~dp_decrease_sort->none~introsort~9 none~introsort~4 introsort proc~dp_increase_sort->none~introsort~4 none~introsort~4->none~introsort~4 none~heap_sort~4 heap_sort none~introsort~4->none~heap_sort~4 none~insertion_sort~4 insertion_sort none~introsort~4->none~insertion_sort~4 none~partition~4 partition none~introsort~4->none~partition~4 none~introsort~9->none~introsort~9 none~heap_sort~9 heap_sort none~introsort~9->none~heap_sort~9 none~insertion_sort~9 insertion_sort none~introsort~9->none~insertion_sort~9 none~partition~9 partition none~introsort~9->none~partition~9 none~max_heapify~4 max_heapify none~heap_sort~4->none~max_heapify~4 none~max_heapify~9 max_heapify none~heap_sort~9->none~max_heapify~9 none~max_heapify~4->none~max_heapify~4 none~max_heapify~9->none~max_heapify~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure module subroutine dp_sort ( array , reverse ) !! `dp_sort( array[, reverse] )` sorts the input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort","tags":"","url":"proc/dp_sort.html"},{"title":"int32_decrease_sort – PIC","text":"private pure subroutine int32_decrease_sort(array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) Calls proc~~int32_decrease_sort~~CallsGraph proc~int32_decrease_sort int32_decrease_sort none~introsort~6 introsort proc~int32_decrease_sort->none~introsort~6 none~introsort~6->none~introsort~6 none~heap_sort~6 heap_sort none~introsort~6->none~heap_sort~6 none~insertion_sort~6 insertion_sort none~introsort~6->none~insertion_sort~6 none~partition~6 partition none~introsort~6->none~partition~6 none~max_heapify~6 max_heapify none~heap_sort~6->none~max_heapify~6 none~max_heapify~6->none~max_heapify~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int32_decrease_sort~~CalledByGraph proc~int32_decrease_sort int32_decrease_sort proc~int32_sort int32_sort proc~int32_sort->proc~int32_decrease_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine int32_decrease_sort ( array ) ! `int32_decrease_sort( array )` sorts the input `ARRAY` of type `integer(int32)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int32_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int32 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int32 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int32 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int32_decrease_sort","tags":"","url":"proc/int32_decrease_sort.html"},{"title":"int32_increase_sort – PIC","text":"private pure subroutine int32_increase_sort(array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) Calls proc~~int32_increase_sort~~CallsGraph proc~int32_increase_sort int32_increase_sort none~introsort introsort proc~int32_increase_sort->none~introsort none~introsort->none~introsort none~heap_sort heap_sort none~introsort->none~heap_sort none~insertion_sort insertion_sort none~introsort->none~insertion_sort none~partition partition none~introsort->none~partition none~max_heapify max_heapify none~heap_sort->none~max_heapify none~max_heapify->none~max_heapify Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int32_increase_sort~~CalledByGraph proc~int32_increase_sort int32_increase_sort proc~int32_sort int32_sort proc~int32_sort->proc~int32_increase_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine int32_increase_sort ( array ) ! `int32_increase_sort( array )` sorts the input `ARRAY` of type `integer(int32)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int32_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int32 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int32 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int32 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int32_increase_sort","tags":"","url":"proc/int32_increase_sort.html"},{"title":"int32_sort – PIC","text":"private pure module subroutine int32_sort(array, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Calls proc~~int32_sort~~CallsGraph proc~int32_sort int32_sort interface~pic_optional pic_optional proc~int32_sort->interface~pic_optional proc~int32_decrease_sort int32_decrease_sort proc~int32_sort->proc~int32_decrease_sort proc~int32_increase_sort int32_increase_sort proc~int32_sort->proc~int32_increase_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~introsort~6 introsort proc~int32_decrease_sort->none~introsort~6 none~introsort introsort proc~int32_increase_sort->none~introsort none~introsort->none~introsort none~heap_sort heap_sort none~introsort->none~heap_sort none~insertion_sort insertion_sort none~introsort->none~insertion_sort none~partition partition none~introsort->none~partition none~introsort~6->none~introsort~6 none~heap_sort~6 heap_sort none~introsort~6->none~heap_sort~6 none~insertion_sort~6 insertion_sort none~introsort~6->none~insertion_sort~6 none~partition~6 partition none~introsort~6->none~partition~6 none~max_heapify max_heapify none~heap_sort->none~max_heapify none~max_heapify~6 max_heapify none~heap_sort~6->none~max_heapify~6 none~max_heapify->none~max_heapify none~max_heapify~6->none~max_heapify~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure module subroutine int32_sort ( array , reverse ) !! `int32_sort( array[, reverse] )` sorts the input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort","tags":"","url":"proc/int32_sort.html"},{"title":"int64_decrease_sort – PIC","text":"private pure subroutine int64_decrease_sort(array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) Calls proc~~int64_decrease_sort~~CallsGraph proc~int64_decrease_sort int64_decrease_sort none~introsort~7 introsort proc~int64_decrease_sort->none~introsort~7 none~introsort~7->none~introsort~7 none~heap_sort~7 heap_sort none~introsort~7->none~heap_sort~7 none~insertion_sort~7 insertion_sort none~introsort~7->none~insertion_sort~7 none~partition~7 partition none~introsort~7->none~partition~7 none~max_heapify~7 max_heapify none~heap_sort~7->none~max_heapify~7 none~max_heapify~7->none~max_heapify~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int64_decrease_sort~~CalledByGraph proc~int64_decrease_sort int64_decrease_sort proc~int64_sort int64_sort proc~int64_sort->proc~int64_decrease_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine int64_decrease_sort ( array ) ! `int64_decrease_sort( array )` sorts the input `ARRAY` of type `integer(int64)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int64_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int64 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int64 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int64 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int64_decrease_sort","tags":"","url":"proc/int64_decrease_sort.html"},{"title":"int64_increase_sort – PIC","text":"private pure subroutine int64_increase_sort(array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) Calls proc~~int64_increase_sort~~CallsGraph proc~int64_increase_sort int64_increase_sort none~introsort~2 introsort proc~int64_increase_sort->none~introsort~2 none~introsort~2->none~introsort~2 none~heap_sort~2 heap_sort none~introsort~2->none~heap_sort~2 none~insertion_sort~2 insertion_sort none~introsort~2->none~insertion_sort~2 none~partition~2 partition none~introsort~2->none~partition~2 none~max_heapify~2 max_heapify none~heap_sort~2->none~max_heapify~2 none~max_heapify~2->none~max_heapify~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int64_increase_sort~~CalledByGraph proc~int64_increase_sort int64_increase_sort proc~int64_sort int64_sort proc~int64_sort->proc~int64_increase_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine int64_increase_sort ( array ) ! `int64_increase_sort( array )` sorts the input `ARRAY` of type `integer(int64)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int64_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int64 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int64 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int64 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int64_increase_sort","tags":"","url":"proc/int64_increase_sort.html"},{"title":"int64_sort – PIC","text":"private pure module subroutine int64_sort(array, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Calls proc~~int64_sort~~CallsGraph proc~int64_sort int64_sort interface~pic_optional pic_optional proc~int64_sort->interface~pic_optional proc~int64_decrease_sort int64_decrease_sort proc~int64_sort->proc~int64_decrease_sort proc~int64_increase_sort int64_increase_sort proc~int64_sort->proc~int64_increase_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~introsort~7 introsort proc~int64_decrease_sort->none~introsort~7 none~introsort~2 introsort proc~int64_increase_sort->none~introsort~2 none~introsort~2->none~introsort~2 none~heap_sort~2 heap_sort none~introsort~2->none~heap_sort~2 none~insertion_sort~2 insertion_sort none~introsort~2->none~insertion_sort~2 none~partition~2 partition none~introsort~2->none~partition~2 none~introsort~7->none~introsort~7 none~heap_sort~7 heap_sort none~introsort~7->none~heap_sort~7 none~insertion_sort~7 insertion_sort none~introsort~7->none~insertion_sort~7 none~partition~7 partition none~introsort~7->none~partition~7 none~max_heapify~2 max_heapify none~heap_sort~2->none~max_heapify~2 none~max_heapify~7 max_heapify none~heap_sort~7->none~max_heapify~7 none~max_heapify~2->none~max_heapify~2 none~max_heapify~7->none~max_heapify~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure module subroutine int64_sort ( array , reverse ) !! `int64_sort( array[, reverse] )` sorts the input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort","tags":"","url":"proc/int64_sort.html"},{"title":"sp_decrease_sort – PIC","text":"private pure subroutine sp_decrease_sort(array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) Calls proc~~sp_decrease_sort~~CallsGraph proc~sp_decrease_sort sp_decrease_sort none~introsort~8 introsort proc~sp_decrease_sort->none~introsort~8 none~introsort~8->none~introsort~8 none~heap_sort~8 heap_sort none~introsort~8->none~heap_sort~8 none~insertion_sort~8 insertion_sort none~introsort~8->none~insertion_sort~8 none~partition~8 partition none~introsort~8->none~partition~8 none~max_heapify~8 max_heapify none~heap_sort~8->none~max_heapify~8 none~max_heapify~8->none~max_heapify~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sp_decrease_sort~~CalledByGraph proc~sp_decrease_sort sp_decrease_sort proc~sp_sort sp_sort proc~sp_sort->proc~sp_decrease_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine sp_decrease_sort ( array ) ! `sp_decrease_sort( array )` sorts the input `ARRAY` of type `real(sp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `sp_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( sp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( sp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( sp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine sp_decrease_sort","tags":"","url":"proc/sp_decrease_sort.html"},{"title":"sp_increase_sort – PIC","text":"private pure subroutine sp_increase_sort(array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) Calls proc~~sp_increase_sort~~CallsGraph proc~sp_increase_sort sp_increase_sort none~introsort~3 introsort proc~sp_increase_sort->none~introsort~3 none~introsort~3->none~introsort~3 none~heap_sort~3 heap_sort none~introsort~3->none~heap_sort~3 none~insertion_sort~3 insertion_sort none~introsort~3->none~insertion_sort~3 none~partition~3 partition none~introsort~3->none~partition~3 none~max_heapify~3 max_heapify none~heap_sort~3->none~max_heapify~3 none~max_heapify~3->none~max_heapify~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sp_increase_sort~~CalledByGraph proc~sp_increase_sort sp_increase_sort proc~sp_sort sp_sort proc~sp_sort->proc~sp_increase_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: depth_limit Subroutines pure subroutine heap_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure recursive subroutine introsort (array, depth_limit) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int32), intent(in) :: depth_limit pure recursive subroutine max_heapify (array, i, heap_size) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: i integer(kind=int_index), intent(in) :: heap_size pure subroutine partition (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index Source Code pure subroutine sp_increase_sort ( array ) ! `sp_increase_sort( array )` sorts the input `ARRAY` of type `real(sp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `sp_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( sp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( sp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( sp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine sp_increase_sort","tags":"","url":"proc/sp_increase_sort.html"},{"title":"sp_sort – PIC","text":"private pure module subroutine sp_sort(array, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Calls proc~~sp_sort~~CallsGraph proc~sp_sort sp_sort interface~pic_optional pic_optional proc~sp_sort->interface~pic_optional proc~sp_decrease_sort sp_decrease_sort proc~sp_sort->proc~sp_decrease_sort proc~sp_increase_sort sp_increase_sort proc~sp_sort->proc~sp_increase_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~introsort~8 introsort proc~sp_decrease_sort->none~introsort~8 none~introsort~3 introsort proc~sp_increase_sort->none~introsort~3 none~introsort~3->none~introsort~3 none~heap_sort~3 heap_sort none~introsort~3->none~heap_sort~3 none~insertion_sort~3 insertion_sort none~introsort~3->none~insertion_sort~3 none~partition~3 partition none~introsort~3->none~partition~3 none~introsort~8->none~introsort~8 none~heap_sort~8 heap_sort none~introsort~8->none~heap_sort~8 none~insertion_sort~8 insertion_sort none~introsort~8->none~insertion_sort~8 none~partition~8 partition none~introsort~8->none~partition~8 none~max_heapify~3 max_heapify none~heap_sort~3->none~max_heapify~3 none~max_heapify~8 max_heapify none~heap_sort~8->none~max_heapify~8 none~max_heapify~3->none~max_heapify~3 none~max_heapify~8->none~max_heapify~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure module subroutine sp_sort ( array , reverse ) !! `sp_sort( array[, reverse] )` sorts the input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort","tags":"","url":"proc/sp_sort.html"},{"title":"sort – PIC","text":"public interface sort The generic subroutine interface implementing the SORT algorithm, based\non the introsort of David Musser.\n( Specification ) Subroutines private pure module subroutine char_sort(array, reverse) Implementation → char_sort( array[, reverse] ) sorts the input ARRAY of type character(len=*) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine dp_sort(array, reverse) Implementation → dp_sort( array[, reverse] ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine int32_sort(array, reverse) Implementation → int32_sort( array[, reverse] ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine int64_sort(array, reverse) Implementation → int64_sort( array[, reverse] ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine sp_sort(array, reverse) Implementation → sp_sort( array[, reverse] ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse","tags":"","url":"interface/sort.html"},{"title":"get_flops – PIC","text":"private  function get_flops(self) result(flops) Get the int64 number of FLOPs we currently have in the counter Usage: flops = my_flop_recorder%get() Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) Called by proc~~get_flops~~CalledByGraph proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_get_flop_rate->proc~get_flops proc~flop_rate_get_flops flop_rate_type%flop_rate_get_flops proc~flop_rate_get_flops->proc~get_flops proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_flops ( self ) result ( flops ) !! Get the int64 number of FLOPs we currently have in the counter !! !! Usage: flops = my_flop_recorder%get() !! class ( flop_recorder_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % flop_count end function get_flops","tags":"","url":"proc/get_flops.html"},{"title":"add_flops – PIC","text":"private  subroutine add_flops(self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Usage: call my_flop_recorder%add(flops) Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops Called by proc~~add_flops~~CalledByGraph proc~add_flops flop_recorder_type%add_flops proc~flop_rate_add_flops flop_rate_type%flop_rate_add_flops proc~flop_rate_add_flops->proc~add_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_flops ( self , flops ) !! Add an int64 variable which contains the FLOPs !! we use int64 since we might reach very large FLOP counts !! !! Usage: call my_flop_recorder%add(flops) !! class ( flop_recorder_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops self % flop_count = self % flop_count + flops end subroutine add_flops","tags":"","url":"proc/add_flops.html"},{"title":"reset_flop_counter – PIC","text":"private  subroutine reset_flop_counter(self) Resets the flop counter to 0_int64 Usage: call my_flop_recorder%reset() Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self Called by proc~~reset_flop_counter~~CalledByGraph proc~reset_flop_counter flop_recorder_type%reset_flop_counter proc~flop_rate_reset flop_rate_type%flop_rate_reset proc~flop_rate_reset->proc~reset_flop_counter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine reset_flop_counter ( self ) !! Resets the flop counter to 0_int64 !! !! Usage: call my_flop_recorder%reset() !! class ( flop_recorder_type ), intent ( inout ) :: self self % flop_count = 0_int64 end subroutine reset_flop_counter","tags":"","url":"proc/reset_flop_counter.html"},{"title":"is_equal_dp – PIC","text":"private elemental function is_equal_dp(a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical Called by proc~~is_equal_dp~~CalledByGraph proc~is_equal_dp is_equal_dp interface~is_equal is_equal interface~is_equal->proc~is_equal_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function is_equal_dp ( a , b ) result ( res ) real ( dp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_dp end function is_equal_dp","tags":"","url":"proc/is_equal_dp.html"},{"title":"is_equal_sp – PIC","text":"private elemental function is_equal_sp(a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical Called by proc~~is_equal_sp~~CalledByGraph proc~is_equal_sp is_equal_sp interface~is_equal is_equal interface~is_equal->proc~is_equal_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function is_equal_sp ( a , b ) result ( res ) real ( sp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_sp end function is_equal_sp","tags":"","url":"proc/is_equal_sp.html"},{"title":"dummy_work – PIC","text":"public  subroutine dummy_work() this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely Usage: call dummy_work() it will simply do a 256 by 256 dgemm, woo Arguments None Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: A (:,:) real(kind=dp), private, allocatable :: B (:,:) real(kind=dp), private, allocatable :: C (:,:) integer(kind=int64), private :: i integer(kind=int64), private :: j integer(kind=int64), private :: k integer(kind=default_int), private :: m Source Code subroutine dummy_work () !! this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely !! !! Usage: call dummy_work() !! !! it will simply do a 256 by 256 dgemm, woo integer ( int64 ) :: i , j , k integer ( default_int ) :: m real ( dp ), allocatable :: A (:, :), B (:, :), C (:, :) m = 256_default_int allocate ( A ( m , m ), B ( m , m ), C ( m , m )) A = 1.0_dp B = 1.0_dp C = 0.0_dp do i = 1 , m do j = 1 , m do k = 1 , m C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do print * , C ( 1 , 1 ) deallocate ( A , B , C ) end subroutine dummy_work","tags":"","url":"proc/dummy_work.html"},{"title":"is_equal – PIC","text":"public interface is_equal The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about\ncomparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that\nthe two reals are exactly equal due to floating point precision issues. The functions are defined as elemental Usage: if (is_equal(a, b)) then\nwhere a and b are real numbers, and the function will return true if they are\nequal within the tolerance defined in pic_global_definitions. Calls interface~~is_equal~~CallsGraph interface~is_equal is_equal proc~is_equal_dp is_equal_dp interface~is_equal->proc~is_equal_dp proc~is_equal_sp is_equal_sp interface~is_equal->proc~is_equal_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical","tags":"","url":"interface/is_equal.html"},{"title":"adjustl_string – PIC","text":"private elemental function adjustl_string(string) result(adjusted_string) Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~adjustl_string~~CallsGraph proc~adjustl_string adjustl_string proc~maybe maybe proc~adjustl_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~adjustl_string~~CalledByGraph proc~adjustl_string adjustl_string interface~adjustl adjustl interface~adjustl->proc~adjustl_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function adjustl_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustl ( maybe ( string )) end function adjustl_string","tags":"","url":"proc/adjustl_string.html"},{"title":"adjustr_string – PIC","text":"private elemental function adjustr_string(string) result(adjusted_string) Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~adjustr_string~~CallsGraph proc~adjustr_string adjustr_string proc~maybe maybe proc~adjustr_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~adjustr_string~~CalledByGraph proc~adjustr_string adjustr_string interface~adjustr adjustr interface~adjustr->proc~adjustr_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function adjustr_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustr ( maybe ( string )) end function adjustr_string","tags":"","url":"proc/adjustr_string.html"},{"title":"char_string – PIC","text":"private pure function char_string(string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) Calls proc~~char_string~~CallsGraph proc~char_string char_string proc~maybe maybe proc~char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~char_string~~CalledByGraph proc~char_string char_string interface~char char interface~char->proc~char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function char_string ( string ) result ( character_string ) type ( string_type ), intent ( in ) :: string character ( len = slen ( string )) :: character_string character_string = maybe ( string ) end function char_string","tags":"","url":"proc/char_string.html"},{"title":"char_string_pos – PIC","text":"private elemental function char_string_pos(string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) Called by proc~~char_string_pos~~CalledByGraph proc~char_string_pos char_string_pos interface~char char interface~char->proc~char_string_pos Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function char_string_pos ( string , pos ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: pos character ( len = 1 ) :: character_string character_string = merge ( string % raw ( pos : pos ), ' ' , allocated ( string % raw )) end function char_string_pos","tags":"","url":"proc/char_string_pos.html"},{"title":"char_string_range – PIC","text":"private pure function char_string_range(string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last) Called by proc~~char_string_range~~CalledByGraph proc~char_string_range char_string_range interface~char char interface~char->proc~char_string_range Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function char_string_range ( string , start , last ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: last character ( len = last - start + 1 ) :: character_string character_string = merge ( string % raw ( int ( start , long ): int ( last , long )), & repeat ( ' ' , int ( len ( character_string ), long )), allocated ( string % raw )) end function char_string_range","tags":"","url":"proc/char_string_range.html"},{"title":"concat_char_string – PIC","text":"private elemental function concat_char_string(lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) Calls proc~~concat_char_string~~CallsGraph proc~concat_char_string concat_char_string proc~maybe maybe proc~concat_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~concat_char_string~~CalledByGraph proc~concat_char_string concat_char_string interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~concat_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function concat_char_string ( lhs , rhs ) result ( string ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = lhs // maybe ( rhs ) end function concat_char_string","tags":"","url":"proc/concat_char_string.html"},{"title":"concat_string_char – PIC","text":"private elemental function concat_string_char(lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) Calls proc~~concat_string_char~~CallsGraph proc~concat_string_char concat_string_char proc~maybe maybe proc~concat_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~concat_string_char~~CalledByGraph proc~concat_string_char concat_string_char interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~concat_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function concat_string_char ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( lhs ) // rhs end function concat_string_char","tags":"","url":"proc/concat_string_char.html"},{"title":"concat_string_string – PIC","text":"private elemental function concat_string_string(lhs, rhs) result(string) Concatenate two character sequences.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) Calls proc~~concat_string_string~~CallsGraph proc~concat_string_string concat_string_string proc~maybe maybe proc~concat_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~concat_string_string~~CalledByGraph proc~concat_string_string concat_string_string interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~concat_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function concat_string_string ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( lhs ) // maybe ( rhs ) end function concat_string_string","tags":"","url":"proc/concat_string_string.html"},{"title":"eq_char_string – PIC","text":"private elemental function eq_char_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~eq_char_string~~CalledByGraph proc~eq_char_string eq_char_string interface~operator(==) operator(==) interface~operator(==)->proc~eq_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function eq_char_string ( lhs , rhs ) result ( is_eq ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_char_string","tags":"","url":"proc/eq_char_string.html"},{"title":"eq_string_char – PIC","text":"private elemental function eq_string_char(lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Called by proc~~eq_string_char~~CalledByGraph proc~eq_string_char eq_string_char interface~operator(==) operator(==) interface~operator(==)->proc~eq_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function eq_string_char ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_string_char","tags":"","url":"proc/eq_string_char.html"},{"title":"eq_string_string – PIC","text":"private elemental function eq_string_string(lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~eq_string_string~~CalledByGraph proc~eq_string_string eq_string_string interface~operator(==) operator(==) interface~operator(==)->proc~eq_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function eq_string_string ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_string_string","tags":"","url":"proc/eq_string_string.html"},{"title":"ge_char_string – PIC","text":"private elemental function ge_char_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~ge_char_string~~CalledByGraph proc~ge_char_string ge_char_string interface~operator(gt=) operator(>=) interface~operator(gt=)->proc~ge_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ge_char_string ( lhs , rhs ) result ( is_ge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_char_string","tags":"","url":"proc/ge_char_string.html"},{"title":"ge_string_char – PIC","text":"private elemental function ge_string_char(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Called by proc~~ge_string_char~~CalledByGraph proc~ge_string_char ge_string_char interface~operator(gt=) operator(>=) interface~operator(gt=)->proc~ge_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ge_string_char ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_char","tags":"","url":"proc/ge_string_char.html"},{"title":"ge_string_string – PIC","text":"private elemental function ge_string_string(lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~ge_string_string~~CalledByGraph proc~ge_string_string ge_string_string interface~operator(gt=) operator(>=) interface~operator(gt=)->proc~ge_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ge_string_string ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_string","tags":"","url":"proc/ge_string_string.html"},{"title":"gt_char_string – PIC","text":"private elemental function gt_char_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~gt_char_string~~CallsGraph proc~gt_char_string gt_char_string proc~maybe maybe proc~gt_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gt_char_string~~CalledByGraph proc~gt_char_string gt_char_string interface~operator(gt) operator(>) interface~operator(gt)->proc~gt_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function gt_char_string ( lhs , rhs ) result ( is_gt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = lhs > maybe ( rhs ) end function gt_char_string","tags":"","url":"proc/gt_char_string.html"},{"title":"gt_string_char – PIC","text":"private elemental function gt_string_char(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Calls proc~~gt_string_char~~CallsGraph proc~gt_string_char gt_string_char proc~maybe maybe proc~gt_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gt_string_char~~CalledByGraph proc~gt_string_char gt_string_char interface~operator(gt) operator(>) interface~operator(gt)->proc~gt_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function gt_string_char ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > rhs end function gt_string_char","tags":"","url":"proc/gt_string_char.html"},{"title":"gt_string_string – PIC","text":"private elemental function gt_string_string(lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~gt_string_string~~CallsGraph proc~gt_string_string gt_string_string proc~maybe maybe proc~gt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~gt_string_string~~CalledByGraph proc~gt_string_string gt_string_string interface~operator(gt) operator(>) interface~operator(gt)->proc~gt_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function gt_string_string ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > maybe ( rhs ) end function gt_string_string","tags":"","url":"proc/gt_string_string.html"},{"title":"iachar_string – PIC","text":"private elemental function iachar_string(string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer Calls proc~~iachar_string~~CallsGraph proc~iachar_string iachar_string interface~slen slen proc~iachar_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~iachar_string~~CalledByGraph proc~iachar_string iachar_string interface~iachar iachar interface~iachar->proc~iachar_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function iachar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . slen ( string ) > 0 ) then ich = iachar ( string % raw ( 1 : 1 )) else ich = 0 end if end function iachar_string","tags":"","url":"proc/iachar_string.html"},{"title":"ichar_string – PIC","text":"private elemental function ichar_string(string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer Calls proc~~ichar_string~~CallsGraph proc~ichar_string ichar_string interface~slen slen proc~ichar_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ichar_string~~CalledByGraph proc~ichar_string ichar_string interface~ichar ichar interface~ichar->proc~ichar_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ichar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . slen ( string ) > 0 ) then ich = ichar ( string % raw ( 1 : 1 )) else ich = 0 end if end function ichar_string","tags":"","url":"proc/ichar_string.html"},{"title":"index_char_string – PIC","text":"private elemental function index_char_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Calls proc~~index_char_string~~CallsGraph proc~index_char_string index_char_string interface~pic_optional pic_optional proc~index_char_string->interface~pic_optional proc~maybe maybe proc~index_char_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~index_char_string~~CalledByGraph proc~index_char_string index_char_string interface~index index interface~index->proc~index_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function index_char_string ( string , substring , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( string , maybe ( substring ), pic_optional ( back , . false .)) end function index_char_string","tags":"","url":"proc/index_char_string.html"},{"title":"index_string_char – PIC","text":"private elemental function index_string_char(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Calls proc~~index_string_char~~CallsGraph proc~index_string_char index_string_char interface~pic_optional pic_optional proc~index_string_char->interface~pic_optional proc~maybe maybe proc~index_string_char->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~index_string_char~~CalledByGraph proc~index_string_char index_string_char interface~index index interface~index->proc~index_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function index_string_char ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), substring , pic_optional ( back , . false .)) end function index_string_char","tags":"","url":"proc/index_string_char.html"},{"title":"index_string_string – PIC","text":"private elemental function index_string_string(string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer Calls proc~~index_string_string~~CallsGraph proc~index_string_string index_string_string interface~pic_optional pic_optional proc~index_string_string->interface~pic_optional proc~maybe maybe proc~index_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~index_string_string~~CalledByGraph proc~index_string_string index_string_string interface~index index interface~index->proc~index_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function index_string_string ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), maybe ( substring ), pic_optional ( back , . false .)) end function index_string_string","tags":"","url":"proc/index_string_string.html"},{"title":"le_char_string – PIC","text":"private elemental function le_char_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~le_char_string~~CalledByGraph proc~le_char_string le_char_string interface~operator(lt=) operator(<=) interface~operator(lt=)->proc~le_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function le_char_string ( lhs , rhs ) result ( is_le ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_char_string","tags":"","url":"proc/le_char_string.html"},{"title":"le_string_char – PIC","text":"private elemental function le_string_char(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Called by proc~~le_string_char~~CalledByGraph proc~le_string_char le_string_char interface~operator(lt=) operator(<=) interface~operator(lt=)->proc~le_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function le_string_char ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_char","tags":"","url":"proc/le_string_char.html"},{"title":"le_string_string – PIC","text":"private elemental function le_string_string(lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~le_string_string~~CalledByGraph proc~le_string_string le_string_string interface~operator(lt=) operator(<=) interface~operator(lt=)->proc~le_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function le_string_string ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_string","tags":"","url":"proc/le_string_string.html"},{"title":"len_string – PIC","text":"private elemental function len_string(string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer Called by proc~~len_string~~CalledByGraph proc~len_string len_string interface~slen slen interface~slen->proc~len_string proc~iachar_string iachar_string proc~iachar_string->interface~slen proc~ichar_string ichar_string proc~ichar_string->interface~slen proc~to_c_char_from_string to_c_char_from_string proc~to_c_char_from_string->interface~slen proc~write_unformatted write_unformatted proc~write_unformatted->interface~slen interface~iachar iachar interface~iachar->proc~iachar_string interface~ichar ichar interface~ichar->proc~ichar_string interface~to_c_char to_c_char interface~to_c_char->proc~to_c_char_from_string interface~write (unformatted) write (unformatted) interface~write (unformatted)->proc~write_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function len_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length if ( allocated ( string % raw )) then length = len ( string % raw ) else length = 0 end if end function len_string","tags":"","url":"proc/len_string.html"},{"title":"len_trim_string – PIC","text":"private elemental function len_trim_string(string) result(length) Returns the length of the character sequence without trailing spaces\nrepresented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer Called by proc~~len_trim_string~~CalledByGraph proc~len_trim_string len_trim_string interface~len_trim len_trim interface~len_trim->proc~len_trim_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function len_trim_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length length = merge ( len_trim ( string % raw ), 0 , allocated ( string % raw )) end function len_trim_string","tags":"","url":"proc/len_trim_string.html"},{"title":"lge_char_string – PIC","text":"private elemental function lge_char_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lge_char_string~~CallsGraph proc~lge_char_string lge_char_string proc~maybe maybe proc~lge_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lge_char_string~~CalledByGraph proc~lge_char_string lge_char_string interface~lge lge interface~lge->proc~lge_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lge_char_string ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( lhs , maybe ( rhs )) end function lge_char_string","tags":"","url":"proc/lge_char_string.html"},{"title":"lge_string_char – PIC","text":"private elemental function lge_string_char(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Calls proc~~lge_string_char~~CallsGraph proc~lge_string_char lge_string_char proc~maybe maybe proc~lge_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lge_string_char~~CalledByGraph proc~lge_string_char lge_string_char interface~lge lge interface~lge->proc~lge_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lge_string_char ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), rhs ) end function lge_string_char","tags":"","url":"proc/lge_string_char.html"},{"title":"lge_string_string – PIC","text":"private elemental function lge_string_string(lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lge_string_string~~CallsGraph proc~lge_string_string lge_string_string proc~maybe maybe proc~lge_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lge_string_string~~CalledByGraph proc~lge_string_string lge_string_string interface~lge lge interface~lge->proc~lge_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lge_string_string ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), maybe ( rhs )) end function lge_string_string","tags":"","url":"proc/lge_string_string.html"},{"title":"lgt_char_string – PIC","text":"private elemental function lgt_char_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lgt_char_string~~CallsGraph proc~lgt_char_string lgt_char_string proc~maybe maybe proc~lgt_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lgt_char_string~~CalledByGraph proc~lgt_char_string lgt_char_string interface~lgt lgt interface~lgt->proc~lgt_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lgt_char_string ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( lhs , maybe ( rhs )) end function lgt_char_string","tags":"","url":"proc/lgt_char_string.html"},{"title":"lgt_string_char – PIC","text":"private elemental function lgt_string_char(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Calls proc~~lgt_string_char~~CallsGraph proc~lgt_string_char lgt_string_char proc~maybe maybe proc~lgt_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lgt_string_char~~CalledByGraph proc~lgt_string_char lgt_string_char interface~lgt lgt interface~lgt->proc~lgt_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lgt_string_char ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), rhs ) end function lgt_string_char","tags":"","url":"proc/lgt_string_char.html"},{"title":"lgt_string_string – PIC","text":"private elemental function lgt_string_string(lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lgt_string_string~~CallsGraph proc~lgt_string_string lgt_string_string proc~maybe maybe proc~lgt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lgt_string_string~~CalledByGraph proc~lgt_string_string lgt_string_string interface~lgt lgt interface~lgt->proc~lgt_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lgt_string_string ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), maybe ( rhs )) end function lgt_string_string","tags":"","url":"proc/lgt_string_string.html"},{"title":"lle_char_string – PIC","text":"private elemental function lle_char_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lle_char_string~~CallsGraph proc~lle_char_string lle_char_string proc~maybe maybe proc~lle_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lle_char_string~~CalledByGraph proc~lle_char_string lle_char_string interface~lle lle interface~lle->proc~lle_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lle_char_string ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( lhs , maybe ( rhs )) end function lle_char_string","tags":"","url":"proc/lle_char_string.html"},{"title":"lle_string_char – PIC","text":"private elemental function lle_string_char(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Calls proc~~lle_string_char~~CallsGraph proc~lle_string_char lle_string_char proc~maybe maybe proc~lle_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lle_string_char~~CalledByGraph proc~lle_string_char lle_string_char interface~lle lle interface~lle->proc~lle_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lle_string_char ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), rhs ) end function lle_string_char","tags":"","url":"proc/lle_string_char.html"},{"title":"lle_string_string – PIC","text":"private elemental function lle_string_string(lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~lle_string_string~~CallsGraph proc~lle_string_string lle_string_string proc~maybe maybe proc~lle_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~lle_string_string~~CalledByGraph proc~lle_string_string lle_string_string interface~lle lle interface~lle->proc~lle_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lle_string_string ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), maybe ( rhs )) end function lle_string_string","tags":"","url":"proc/lle_string_string.html"},{"title":"llt_char_string – PIC","text":"private elemental function llt_char_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~llt_char_string~~CallsGraph proc~llt_char_string llt_char_string proc~maybe maybe proc~llt_char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~llt_char_string~~CalledByGraph proc~llt_char_string llt_char_string interface~llt llt interface~llt->proc~llt_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function llt_char_string ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( lhs , maybe ( rhs )) end function llt_char_string","tags":"","url":"proc/llt_char_string.html"},{"title":"llt_string_char – PIC","text":"private elemental function llt_string_char(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Calls proc~~llt_string_char~~CallsGraph proc~llt_string_char llt_string_char proc~maybe maybe proc~llt_string_char->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~llt_string_char~~CalledByGraph proc~llt_string_char llt_string_char interface~llt llt interface~llt->proc~llt_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function llt_string_char ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), rhs ) end function llt_string_char","tags":"","url":"proc/llt_string_char.html"},{"title":"llt_string_string – PIC","text":"private elemental function llt_string_string(lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Calls proc~~llt_string_string~~CallsGraph proc~llt_string_string llt_string_string proc~maybe maybe proc~llt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~llt_string_string~~CalledByGraph proc~llt_string_string llt_string_string interface~llt llt interface~llt->proc~llt_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function llt_string_string ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), maybe ( rhs )) end function llt_string_string","tags":"","url":"proc/llt_string_string.html"},{"title":"lt_char_string – PIC","text":"private elemental function lt_char_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~lt_char_string~~CalledByGraph proc~lt_char_string lt_char_string interface~operator(lt) operator(<) interface~operator(lt)->proc~lt_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lt_char_string ( lhs , rhs ) result ( is_lt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_char_string","tags":"","url":"proc/lt_char_string.html"},{"title":"lt_string_char – PIC","text":"private elemental function lt_string_char(lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Called by proc~~lt_string_char~~CalledByGraph proc~lt_string_char lt_string_char interface~operator(lt) operator(<) interface~operator(lt)->proc~lt_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lt_string_char ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_char","tags":"","url":"proc/lt_string_char.html"},{"title":"lt_string_string – PIC","text":"private elemental function lt_string_string(lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~lt_string_string~~CalledByGraph proc~lt_string_string lt_string_string interface~operator(lt) operator(<) interface~operator(lt)->proc~lt_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function lt_string_string ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_string","tags":"","url":"proc/lt_string_string.html"},{"title":"maybe – PIC","text":"private pure function maybe(string) result(maybe_string) Safely return the character sequences represented by the string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) Called by proc~~maybe~~CalledByGraph proc~maybe maybe proc~adjustl_string adjustl_string proc~adjustl_string->proc~maybe proc~adjustr_string adjustr_string proc~adjustr_string->proc~maybe proc~char_string char_string proc~char_string->proc~maybe proc~concat_char_string concat_char_string proc~concat_char_string->proc~maybe proc~concat_string_char concat_string_char proc~concat_string_char->proc~maybe proc~concat_string_string concat_string_string proc~concat_string_string->proc~maybe proc~gt_char_string gt_char_string proc~gt_char_string->proc~maybe proc~gt_string_char gt_string_char proc~gt_string_char->proc~maybe proc~gt_string_string gt_string_string proc~gt_string_string->proc~maybe proc~index_char_string index_char_string proc~index_char_string->proc~maybe proc~index_string_char index_string_char proc~index_string_char->proc~maybe proc~index_string_string index_string_string proc~index_string_string->proc~maybe proc~lge_char_string lge_char_string proc~lge_char_string->proc~maybe proc~lge_string_char lge_string_char proc~lge_string_char->proc~maybe proc~lge_string_string lge_string_string proc~lge_string_string->proc~maybe proc~lgt_char_string lgt_char_string proc~lgt_char_string->proc~maybe proc~lgt_string_char lgt_string_char proc~lgt_string_char->proc~maybe proc~lgt_string_string lgt_string_string proc~lgt_string_string->proc~maybe proc~lle_char_string lle_char_string proc~lle_char_string->proc~maybe proc~lle_string_char lle_string_char proc~lle_string_char->proc~maybe proc~lle_string_string lle_string_string proc~lle_string_string->proc~maybe proc~llt_char_string llt_char_string proc~llt_char_string->proc~maybe proc~llt_string_char llt_string_char proc~llt_string_char->proc~maybe proc~llt_string_string llt_string_string proc~llt_string_string->proc~maybe proc~repeat_string repeat_string proc~repeat_string->proc~maybe proc~reverse_string reverse_string proc~reverse_string->proc~maybe proc~scan_char_string scan_char_string proc~scan_char_string->proc~maybe proc~scan_string_char scan_string_char proc~scan_string_char->proc~maybe proc~scan_string_string scan_string_string proc~scan_string_string->proc~maybe proc~to_lower_string to_lower_string proc~to_lower_string->proc~maybe proc~to_sentence_string to_sentence_string proc~to_sentence_string->proc~maybe proc~to_title_string to_title_string proc~to_title_string->proc~maybe proc~to_upper_string to_upper_string proc~to_upper_string->proc~maybe proc~trim_string trim_string proc~trim_string->proc~maybe proc~verify_char_string verify_char_string proc~verify_char_string->proc~maybe proc~verify_string_char verify_string_char proc~verify_string_char->proc~maybe proc~verify_string_string verify_string_string proc~verify_string_string->proc~maybe proc~write_formatted write_formatted proc~write_formatted->proc~maybe proc~write_unformatted write_unformatted proc~write_unformatted->proc~maybe interface~adjustl adjustl interface~adjustl->proc~adjustl_string interface~adjustr adjustr interface~adjustr->proc~adjustr_string interface~char char interface~char->proc~char_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~lge lge interface~lge->proc~lge_char_string interface~lge->proc~lge_string_char interface~lge->proc~lge_string_string interface~lgt lgt interface~lgt->proc~lgt_char_string interface~lgt->proc~lgt_string_char interface~lgt->proc~lgt_string_string interface~lle lle interface~lle->proc~lle_char_string interface~lle->proc~lle_string_char interface~lle->proc~lle_string_string interface~llt llt interface~llt->proc~llt_char_string interface~llt->proc~llt_string_char interface~llt->proc~llt_string_string interface~operator(SLASHSLASH) operator(//) interface~operator(SLASHSLASH)->proc~concat_char_string interface~operator(SLASHSLASH)->proc~concat_string_char interface~operator(SLASHSLASH)->proc~concat_string_string interface~operator(gt) operator(>) interface~operator(gt)->proc~gt_char_string interface~operator(gt)->proc~gt_string_char interface~operator(gt)->proc~gt_string_string interface~repeat repeat interface~repeat->proc~repeat_string interface~reverse reverse interface~reverse->proc~reverse_string interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~to_lower to_lower interface~to_lower->proc~to_lower_string interface~to_sentence to_sentence interface~to_sentence->proc~to_sentence_string interface~to_title to_title interface~to_title->proc~to_title_string interface~to_upper to_upper interface~to_upper->proc~to_upper_string interface~trim trim interface~trim->proc~trim_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string interface~write (formatted) write (formatted) interface~write (formatted)->proc~write_formatted interface~write (unformatted) write (unformatted) interface~write (unformatted)->proc~write_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function maybe ( string ) result ( maybe_string ) type ( string_type ), intent ( in ) :: string character ( len = slen ( string )) :: maybe_string if ( allocated ( string % raw )) then maybe_string = string % raw else maybe_string = '' end if end function maybe","tags":"","url":"proc/maybe.html"},{"title":"ne_char_string – PIC","text":"private elemental function ne_char_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~ne_char_string~~CalledByGraph proc~ne_char_string ne_char_string interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ne_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ne_char_string ( lhs , rhs ) result ( is_ne ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_char_string","tags":"","url":"proc/ne_char_string.html"},{"title":"ne_string_char – PIC","text":"private elemental function ne_string_char(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical Called by proc~~ne_string_char~~CalledByGraph proc~ne_string_char ne_string_char interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ne_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ne_string_char ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_char","tags":"","url":"proc/ne_string_char.html"},{"title":"ne_string_string – PIC","text":"private elemental function ne_string_string(lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical Called by proc~~ne_string_string~~CalledByGraph proc~ne_string_string ne_string_string interface~operator(SLASH=) operator(/=) interface~operator(SLASH=)->proc~ne_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ne_string_string ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_string","tags":"","url":"proc/ne_string_string.html"},{"title":"repeat_string – PIC","text":"private elemental function repeat_string(string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\nspecified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type ) Calls proc~~repeat_string~~CallsGraph proc~repeat_string repeat_string proc~maybe maybe proc~repeat_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~repeat_string~~CalledByGraph proc~repeat_string repeat_string interface~repeat repeat interface~repeat->proc~repeat_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function repeat_string ( string , ncopies ) result ( repeated_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( string_type ) :: repeated_string repeated_string = repeat ( maybe ( string ), ncopies ) end function repeat_string","tags":"","url":"proc/repeat_string.html"},{"title":"reverse_string – PIC","text":"private elemental function reverse_string(string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~reverse_string~~CallsGraph proc~reverse_string reverse_string proc~maybe maybe proc~reverse_string->proc~maybe reverse_ reverse_ proc~reverse_string->reverse_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~reverse_string~~CalledByGraph proc~reverse_string reverse_string interface~reverse reverse interface~reverse->proc~reverse_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function reverse_string ( string ) result ( reversed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: reversed_string reversed_string % raw = reverse_ ( maybe ( string )) end function reverse_string","tags":"","url":"proc/reverse_string.html"},{"title":"scan_char_string – PIC","text":"private elemental function scan_char_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~scan_char_string~~CallsGraph proc~scan_char_string scan_char_string interface~pic_optional pic_optional proc~scan_char_string->interface~pic_optional proc~maybe maybe proc~scan_char_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scan_char_string~~CalledByGraph proc~scan_char_string scan_char_string interface~scan scan interface~scan->proc~scan_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function scan_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( string , maybe ( set ), pic_optional ( back , . false .)) end function scan_char_string","tags":"","url":"proc/scan_char_string.html"},{"title":"scan_string_char – PIC","text":"private elemental function scan_string_char(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~scan_string_char~~CallsGraph proc~scan_string_char scan_string_char interface~pic_optional pic_optional proc~scan_string_char->interface~pic_optional proc~maybe maybe proc~scan_string_char->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scan_string_char~~CalledByGraph proc~scan_string_char scan_string_char interface~scan scan interface~scan->proc~scan_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function scan_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), set , pic_optional ( back , . false .)) end function scan_string_char","tags":"","url":"proc/scan_string_char.html"},{"title":"scan_string_string – PIC","text":"private elemental function scan_string_string(string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version both the character sequence and the character set are\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~scan_string_string~~CallsGraph proc~scan_string_string scan_string_string interface~pic_optional pic_optional proc~scan_string_string->interface~pic_optional proc~maybe maybe proc~scan_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~scan_string_string~~CalledByGraph proc~scan_string_string scan_string_string interface~scan scan interface~scan->proc~scan_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function scan_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), maybe ( set ), pic_optional ( back , . false .)) end function scan_string_string","tags":"","url":"proc/scan_string_string.html"},{"title":"to_lower_string – PIC","text":"private elemental function to_lower_string(string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~to_lower_string~~CallsGraph proc~to_lower_string to_lower_string proc~maybe maybe proc~to_lower_string->proc~maybe to_lower_ to_lower_ proc~to_lower_string->to_lower_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_lower_string~~CalledByGraph proc~to_lower_string to_lower_string interface~to_lower to_lower interface~to_lower->proc~to_lower_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function to_lower_string ( string ) result ( lowercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: lowercase_string lowercase_string % raw = to_lower_ ( maybe ( string )) end function to_lower_string","tags":"","url":"proc/to_lower_string.html"},{"title":"to_sentence_string – PIC","text":"private elemental function to_sentence_string(string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~to_sentence_string~~CallsGraph proc~to_sentence_string to_sentence_string proc~maybe maybe proc~to_sentence_string->proc~maybe to_sentence_ to_sentence_ proc~to_sentence_string->to_sentence_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_sentence_string~~CalledByGraph proc~to_sentence_string to_sentence_string interface~to_sentence to_sentence interface~to_sentence->proc~to_sentence_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function to_sentence_string ( string ) result ( sentence_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: sentence_string sentence_string % raw = to_sentence_ ( maybe ( string )) end function to_sentence_string","tags":"","url":"proc/to_sentence_string.html"},{"title":"to_title_string – PIC","text":"private elemental function to_title_string(string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~to_title_string~~CallsGraph proc~to_title_string to_title_string proc~maybe maybe proc~to_title_string->proc~maybe to_title_ to_title_ proc~to_title_string->to_title_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_title_string~~CalledByGraph proc~to_title_string to_title_string interface~to_title to_title interface~to_title->proc~to_title_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function to_title_string ( string ) result ( titlecase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: titlecase_string titlecase_string % raw = to_title_ ( maybe ( string )) end function to_title_string","tags":"","url":"proc/to_title_string.html"},{"title":"to_upper_string – PIC","text":"private elemental function to_upper_string(string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~to_upper_string~~CallsGraph proc~to_upper_string to_upper_string proc~maybe maybe proc~to_upper_string->proc~maybe to_upper_ to_upper_ proc~to_upper_string->to_upper_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_upper_string~~CalledByGraph proc~to_upper_string to_upper_string interface~to_upper to_upper interface~to_upper->proc~to_upper_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function to_upper_string ( string ) result ( uppercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: uppercase_string uppercase_string % raw = to_upper_ ( maybe ( string )) end function to_upper_string","tags":"","url":"proc/to_upper_string.html"},{"title":"trim_string – PIC","text":"private elemental function trim_string(string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~trim_string~~CallsGraph proc~trim_string trim_string proc~maybe maybe proc~trim_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~trim_string~~CalledByGraph proc~trim_string trim_string interface~trim trim interface~trim->proc~trim_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function trim_string ( string ) result ( trimmed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: trimmed_string trimmed_string = trim ( maybe ( string )) end function trim_string","tags":"","url":"proc/trim_string.html"},{"title":"verify_char_string – PIC","text":"private elemental function verify_char_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the set of characters is\nrepresented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~verify_char_string~~CallsGraph proc~verify_char_string verify_char_string interface~pic_optional pic_optional proc~verify_char_string->interface~pic_optional proc~maybe maybe proc~verify_char_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~verify_char_string~~CalledByGraph proc~verify_char_string verify_char_string interface~verify verify interface~verify->proc~verify_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function verify_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( string , maybe ( set ), pic_optional ( back , . false .)) end function verify_char_string","tags":"","url":"proc/verify_char_string.html"},{"title":"verify_string_char – PIC","text":"private elemental function verify_string_char(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the character sequences is\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~verify_string_char~~CallsGraph proc~verify_string_char verify_string_char interface~pic_optional pic_optional proc~verify_string_char->interface~pic_optional proc~maybe maybe proc~verify_string_char->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~verify_string_char~~CalledByGraph proc~verify_string_char verify_string_char interface~verify verify interface~verify->proc~verify_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function verify_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), set , pic_optional ( back , . false .)) end function verify_string_char","tags":"","url":"proc/verify_string_char.html"},{"title":"verify_string_string – PIC","text":"private elemental function verify_string_string(string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version both the character sequence and\nthe character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Calls proc~~verify_string_string~~CallsGraph proc~verify_string_string verify_string_string interface~pic_optional pic_optional proc~verify_string_string->interface~pic_optional proc~maybe maybe proc~verify_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~verify_string_string~~CalledByGraph proc~verify_string_string verify_string_string interface~verify verify interface~verify->proc~verify_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function verify_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), maybe ( set ), pic_optional ( back , . false .)) end function verify_string_string","tags":"","url":"proc/verify_string_string.html"},{"title":"assign_string_char – PIC","text":"private elemental subroutine assign_string_char(lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs Called by proc~~assign_string_char~~CalledByGraph proc~assign_string_char assign_string_char interface~assignment(=) assignment(=) interface~assignment(=)->proc~assign_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental subroutine assign_string_char ( lhs , rhs ) type ( string_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs lhs % raw = rhs end subroutine assign_string_char","tags":"","url":"proc/assign_string_char.html"},{"title":"move_char_char – PIC","text":"private pure subroutine move_char_char(from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from character(len=:), intent(out), allocatable :: to Called by proc~~move_char_char~~CalledByGraph proc~move_char_char move_char_char interface~move move interface~move->proc~move_char_char proc~join_string join_string proc~join_string->interface~move interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine move_char_char ( from , to ) character ( len = :), intent ( inout ), allocatable :: from character ( len = :), intent ( out ), allocatable :: to call move_alloc ( from , to ) end subroutine move_char_char","tags":"","url":"proc/move_char_char.html"},{"title":"move_char_string – PIC","text":"private pure subroutine move_char_string(from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from type( string_type ), intent(out) :: to Called by proc~~move_char_string~~CalledByGraph proc~move_char_string move_char_string interface~move move interface~move->proc~move_char_string proc~join_string join_string proc~join_string->interface~move interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine move_char_string ( from , to ) character ( len = :), intent ( inout ), allocatable :: from type ( string_type ), intent ( out ) :: to call move_alloc ( from , to % raw ) end subroutine move_char_string","tags":"","url":"proc/move_char_string.html"},{"title":"move_string_char – PIC","text":"private pure subroutine move_string_char(from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: from character(len=:), intent(out), allocatable :: to Called by proc~~move_string_char~~CalledByGraph proc~move_string_char move_string_char interface~move move interface~move->proc~move_string_char proc~join_string join_string proc~join_string->interface~move interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine move_string_char ( from , to ) type ( string_type ), intent ( inout ) :: from character ( len = :), intent ( out ), allocatable :: to call move_alloc ( from % raw , to ) end subroutine move_string_char","tags":"","url":"proc/move_string_char.html"},{"title":"move_string_string – PIC","text":"private elemental subroutine move_string_string(from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout), target :: from type( string_type ), intent(inout), target :: to Called by proc~~move_string_string~~CalledByGraph proc~move_string_string move_string_string interface~move move interface~move->proc~move_string_string proc~join_string join_string proc~join_string->interface~move interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( string_type ), private, pointer :: fromp Source Code elemental subroutine move_string_string ( from , to ) type ( string_type ), intent ( inout ), target :: from type ( string_type ), intent ( inout ), target :: to type ( string_type ), pointer :: fromp fromp => from if ( associated ( fromp , to )) return call move_alloc ( from % raw , to % raw ) end subroutine move_string_string","tags":"","url":"proc/move_string_string.html"},{"title":"read_formatted – PIC","text":"private  subroutine read_formatted(string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~read_formatted~~CallsGraph proc~read_formatted read_formatted none~read_line read_line proc~read_formatted->none~read_line proc~unused_dummy_argument unused_dummy_argument proc~read_formatted->proc~unused_dummy_argument Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~read_formatted~~CalledByGraph proc~read_formatted read_formatted interface~read (formatted) read (formatted) interface~read (formatted)->proc~read_formatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: line Subroutines subroutine read_line (unit, line, iostat, iomsg) Internal routine to read a whole record from a formatted unit Arguments Type Intent Optional Attributes Name integer, intent(in) :: unit character(len=:), intent(out), allocatable :: line integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Source Code subroutine read_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: line call unused_dummy_argument ( v_list ) select case ( iotype ) case ( \"LISTDIRECTED\" ) call read_line ( unit , line , iostat , iomsg ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist input\" case default ! DT* error stop \"[Fatal] This implementation does not support dt formatters\" end select string % raw = line contains !> Internal routine to read a whole record from a formatted unit subroutine read_line ( unit , line , iostat , iomsg ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: buffer_size = 512 character ( len = buffer_size ) :: buffer integer :: chunk line = '' do read ( unit , '(a)' , iostat = iostat , iomsg = iomsg , size = chunk , advance = 'no' ) & buffer if ( iostat > 0 ) exit line = line // buffer (: chunk ) if ( iostat < 0 ) exit end do if ( is_iostat_eor ( iostat )) then iostat = 0 end if end subroutine read_line end subroutine read_formatted","tags":"","url":"proc/read_formatted.html"},{"title":"read_unformatted – PIC","text":"private  subroutine read_unformatted(string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Called by proc~~read_unformatted~~CalledByGraph proc~read_unformatted read_unformatted interface~read (unformatted) read (unformatted) interface~read (unformatted)->proc~read_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: buffer integer(kind=long), private :: chunk Source Code subroutine read_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: buffer integer ( long ) :: chunk read ( unit , iostat = iostat , iomsg = iomsg ) chunk if ( iostat == 0 ) then allocate ( character ( len = chunk ) :: buffer ) read ( unit , iostat = iostat , iomsg = iomsg ) buffer string % raw = buffer end if end subroutine read_unformatted","tags":"","url":"proc/read_unformatted.html"},{"title":"unused_dummy_argument – PIC","text":"private elemental subroutine unused_dummy_argument(dummy) Do nothing but mark an unused dummy argument as such to acknowledge compile\ntime warning like: Warning: Unused dummy argument ‘dummy’ at (1) [-Wunused-dummy-argument] We deeply trust in the compiler to inline and optimize this piece of code away. Arguments Type Intent Optional Attributes Name class(*), intent(in) :: dummy Called by proc~~unused_dummy_argument~~CalledByGraph proc~unused_dummy_argument unused_dummy_argument proc~read_formatted read_formatted proc~read_formatted->proc~unused_dummy_argument interface~read (formatted) read (formatted) interface~read (formatted)->proc~read_formatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental subroutine unused_dummy_argument ( dummy ) class ( * ), intent ( in ) :: dummy associate ( dummy => dummy ); end associate end subroutine unused_dummy_argument","tags":"","url":"proc/unused_dummy_argument.html"},{"title":"write_formatted – PIC","text":"private  subroutine write_formatted(string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~write_formatted~~CallsGraph proc~write_formatted write_formatted proc~maybe maybe proc~write_formatted->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_formatted~~CalledByGraph proc~write_formatted write_formatted interface~write (formatted) write (formatted) interface~write (formatted)->proc~write_formatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg select case ( iotype ) case ( \"LISTDIRECTED\" ) write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist output\" case default ! DT* select case ( size ( v_list )) case ( 0 ) ! DT write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case default error stop \"[Fatal] This implementation does not support v_list formatters\" end select end select end subroutine write_formatted","tags":"","url":"proc/write_formatted.html"},{"title":"write_unformatted – PIC","text":"private  subroutine write_unformatted(string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Calls proc~~write_unformatted~~CallsGraph proc~write_unformatted write_unformatted interface~slen slen proc~write_unformatted->interface~slen proc~maybe maybe proc~write_unformatted->proc~maybe proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~write_unformatted~~CalledByGraph proc~write_unformatted write_unformatted interface~write (unformatted) write (unformatted) interface~write (unformatted)->proc~write_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg write ( unit , iostat = iostat , iomsg = iomsg ) int ( slen ( string ), long ) if ( iostat == 0 ) then write ( unit , iostat = iostat , iomsg = iomsg ) maybe ( string ) end if end subroutine write_unformatted","tags":"","url":"proc/write_unformatted.html"},{"title":"adjustl – PIC","text":"public interface adjustl Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Calls interface~~adjustl~~CallsGraph interface~adjustl adjustl proc~adjustl_string adjustl_string interface~adjustl->proc~adjustl_string proc~maybe maybe proc~adjustl_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function adjustl_string (string) result(adjusted_string) Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/adjustl.html"},{"title":"adjustr – PIC","text":"public interface adjustr Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. Calls interface~~adjustr~~CallsGraph interface~adjustr adjustr proc~adjustr_string adjustr_string interface~adjustr->proc~adjustr_string proc~maybe maybe proc~adjustr_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function adjustr_string (string) result(adjusted_string) Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/adjustr.html"},{"title":"assignment(=) – PIC","text":"public interface assignment(=) Assign a character sequence to a string. Calls interface~~assignment(=)~~CallsGraph interface~assignment(=) assignment(=) proc~assign_string_char assign_string_char interface~assignment(=)->proc~assign_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental subroutine assign_string_char (lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs","tags":"","url":"interface/assignment(=).html"},{"title":"char – PIC","text":"public interface char Return the character sequence represented by the string. This method is elemental and returns a scalar character value. Calls interface~~char~~CallsGraph interface~char char proc~char_string char_string interface~char->proc~char_string proc~char_string_pos char_string_pos interface~char->proc~char_string_pos proc~char_string_range char_string_range interface~char->proc~char_string_range proc~maybe maybe proc~char_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function char_string (string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) private elemental function char_string_pos (string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private pure function char_string_range (string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last)","tags":"","url":"interface/char.html"},{"title":"iachar – PIC","text":"public interface iachar Code in ASCII collating sequence. This method is elemental and returns a default integer scalar value. Calls interface~~iachar~~CallsGraph interface~iachar iachar proc~iachar_string iachar_string interface~iachar->proc~iachar_string interface~slen slen proc~iachar_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function iachar_string (string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/iachar.html"},{"title":"ichar – PIC","text":"public interface ichar Character-to-integer conversion function. This method is elemental and returns a default integer scalar value. Calls interface~~ichar~~CallsGraph interface~ichar ichar proc~ichar_string ichar_string interface~ichar->proc~ichar_string interface~slen slen proc~ichar_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function ichar_string (string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/ichar.html"},{"title":"index – PIC","text":"public interface index Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\nof string substring in string , counting from one. If substring is not\npresent in string , zero is returned. This method is elemental and returns a default integer scalar value. Calls interface~~index~~CallsGraph interface~index index proc~index_char_string index_char_string interface~index->proc~index_char_string proc~index_string_char index_string_char interface~index->proc~index_string_char proc~index_string_string index_string_string interface~index->proc~index_string_string interface~pic_optional pic_optional proc~index_char_string->interface~pic_optional proc~maybe maybe proc~index_char_string->proc~maybe proc~index_string_char->interface~pic_optional proc~index_string_char->proc~maybe proc~index_string_string->interface~pic_optional proc~index_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function index_string_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/index.html"},{"title":"len_trim – PIC","text":"public interface len_trim Returns the length of the character sequence without trailing spaces\nrepresented by the string. This method is elemental and returns a default integer scalar value. Calls interface~~len_trim~~CallsGraph interface~len_trim len_trim proc~len_trim_string len_trim_string interface~len_trim->proc~len_trim_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function len_trim_string (string) result(length) Returns the length of the character sequence without trailing spaces\nrepresented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/len_trim.html"},{"title":"lge – PIC","text":"public interface lge Lexically compare the order of two character sequences being greater equal,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. Calls interface~~lge~~CallsGraph interface~lge lge proc~lge_char_string lge_char_string interface~lge->proc~lge_char_string proc~lge_string_char lge_string_char interface~lge->proc~lge_string_char proc~lge_string_string lge_string_string interface~lge->proc~lge_string_string proc~maybe maybe proc~lge_char_string->proc~maybe proc~lge_string_char->proc~maybe proc~lge_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function lge_string_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lge.html"},{"title":"lgt – PIC","text":"public interface lgt Lexically compare the order of two character sequences being greater,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. Calls interface~~lgt~~CallsGraph interface~lgt lgt proc~lgt_char_string lgt_char_string interface~lgt->proc~lgt_char_string proc~lgt_string_char lgt_string_char interface~lgt->proc~lgt_string_char proc~lgt_string_string lgt_string_string interface~lgt->proc~lgt_string_string proc~maybe maybe proc~lgt_char_string->proc~maybe proc~lgt_string_char->proc~maybe proc~lgt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function lgt_string_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lgt.html"},{"title":"lle – PIC","text":"public interface lle Lexically compare the order of two character sequences being less equal,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. Calls interface~~lle~~CallsGraph interface~lle lle proc~lle_char_string lle_char_string interface~lle->proc~lle_char_string proc~lle_string_char lle_string_char interface~lle->proc~lle_string_char proc~lle_string_string lle_string_string interface~lle->proc~lle_string_string proc~maybe maybe proc~lle_char_string->proc~maybe proc~lle_string_char->proc~maybe proc~lle_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function lle_string_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/lle.html"},{"title":"llt – PIC","text":"public interface llt Lexically compare the order of two character sequences being less,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. Calls interface~~llt~~CallsGraph interface~llt llt proc~llt_char_string llt_char_string interface~llt->proc~llt_char_string proc~llt_string_char llt_string_char interface~llt->proc~llt_string_char proc~llt_string_string llt_string_string interface~llt->proc~llt_string_string proc~maybe maybe proc~llt_char_string->proc~maybe proc~llt_string_char->proc~maybe proc~llt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function llt_string_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/llt.html"},{"title":"move – PIC","text":"public interface move Moves the allocated character scalar from ‘from’ to ‘to’ Calls interface~~move~~CallsGraph interface~move move proc~move_char_char move_char_char interface~move->proc~move_char_char proc~move_char_string move_char_string interface~move->proc~move_char_string proc~move_string_char move_string_char interface~move->proc~move_string_char proc~move_string_string move_string_string interface~move->proc~move_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~move~~CalledByGraph interface~move move proc~join_string join_string proc~join_string->interface~move interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental subroutine move_string_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout), target :: from type( string_type ), intent(inout), target :: to private pure subroutine move_string_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: from character(len=:), intent(out), allocatable :: to private pure subroutine move_char_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from type( string_type ), intent(out) :: to private pure subroutine move_char_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from character(len=:), intent(out), allocatable :: to","tags":"","url":"interface/move.html"},{"title":"operator(//) – PIC","text":"public interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\nor both character sequences can be represented by a string. This operator is elemental and returns a scalar character value. Calls interface~~operator(SLASHSLASH)~~CallsGraph interface~operator(SLASHSLASH) operator(//) proc~concat_char_string concat_char_string interface~operator(SLASHSLASH)->proc~concat_char_string proc~concat_string_char concat_string_char interface~operator(SLASHSLASH)->proc~concat_string_char proc~concat_string_string concat_string_string interface~operator(SLASHSLASH)->proc~concat_string_string proc~maybe maybe proc~concat_char_string->proc~maybe proc~concat_string_char->proc~maybe proc~concat_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function concat_string_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_char (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_char_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type )","tags":"","url":"interface/operator(SLASHSLASH).html"},{"title":"operator(/=) – PIC","text":"public interface operator(/=) Compare two character sequences for inequality, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(SLASH=)~~CallsGraph interface~operator(SLASH=) operator(/=) proc~ne_char_string ne_char_string interface~operator(SLASH=)->proc~ne_char_string proc~ne_string_char ne_string_char interface~operator(SLASH=)->proc~ne_string_char proc~ne_string_string ne_string_string interface~operator(SLASH=)->proc~ne_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function ne_string_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(SLASH=).html"},{"title":"operator(<) – PIC","text":"public interface operator(<) Compare two character sequences for being less, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(lt)~~CallsGraph interface~operator(lt) operator(<) proc~lt_char_string lt_char_string interface~operator(lt)->proc~lt_char_string proc~lt_string_char lt_string_char interface~operator(lt)->proc~lt_string_char proc~lt_string_string lt_string_string interface~operator(lt)->proc~lt_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function lt_string_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt).html"},{"title":"operator(<=) – PIC","text":"public interface operator(<=) Compare two character sequences for being less than, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(lt=)~~CallsGraph interface~operator(lt=) operator(<=) proc~le_char_string le_char_string interface~operator(lt=)->proc~le_char_string proc~le_string_char le_string_char interface~operator(lt=)->proc~le_string_char proc~le_string_string le_string_string interface~operator(lt=)->proc~le_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function le_string_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(lt=).html"},{"title":"operator(==) – PIC","text":"public interface operator(==) Compare two character sequences for equality, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(==)~~CallsGraph interface~operator(==) operator(==) proc~eq_char_string eq_char_string interface~operator(==)->proc~eq_char_string proc~eq_string_char eq_string_char interface~operator(==)->proc~eq_string_char proc~eq_string_string eq_string_string interface~operator(==)->proc~eq_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function eq_string_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(==).html"},{"title":"operator(>) – PIC","text":"public interface operator(>) Compare two character sequences for being greater, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(gt)~~CallsGraph interface~operator(gt) operator(>) proc~gt_char_string gt_char_string interface~operator(gt)->proc~gt_char_string proc~gt_string_char gt_string_char interface~operator(gt)->proc~gt_string_char proc~gt_string_string gt_string_string interface~operator(gt)->proc~gt_string_string proc~maybe maybe proc~gt_char_string->proc~maybe proc~gt_string_char->proc~maybe proc~gt_string_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function gt_string_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt).html"},{"title":"operator(>=) – PIC","text":"public interface operator(>=) Compare two character sequences for being greater than, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. Calls interface~~operator(gt=)~~CallsGraph interface~operator(gt=) operator(>=) proc~ge_char_string ge_char_string interface~operator(gt=)->proc~ge_char_string proc~ge_string_char ge_string_char interface~operator(gt=)->proc~ge_string_char proc~ge_string_string ge_string_string interface~operator(gt=)->proc~ge_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function ge_string_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical","tags":"","url":"interface/operator(gt=).html"},{"title":"read (formatted) – PIC","text":"public interface read (formatted) Read a character sequence from a connected unformatted unit into the string. Calls interface~~read (formatted)~~CallsGraph interface~read (formatted) read (formatted) proc~read_formatted read_formatted interface~read (formatted)->proc~read_formatted none~read_line read_line proc~read_formatted->none~read_line proc~unused_dummy_argument unused_dummy_argument proc~read_formatted->proc~unused_dummy_argument Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine read_formatted (string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"interface/read (formatted).html"},{"title":"read (unformatted) – PIC","text":"public interface read (unformatted) Read a character sequence from a connected unformatted unit into the string. Calls interface~~read (unformatted)~~CallsGraph interface~read (unformatted) read (unformatted) proc~read_unformatted read_unformatted interface~read (unformatted)->proc~read_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine read_unformatted (string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"interface/read (unformatted).html"},{"title":"repeat – PIC","text":"public interface repeat Repeats the character sequence hold by the string by the number of\nspecified copies. This method is elemental and returns a scalar character value. Calls interface~~repeat~~CallsGraph interface~repeat repeat proc~repeat_string repeat_string interface~repeat->proc~repeat_string proc~maybe maybe proc~repeat_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function repeat_string (string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\nspecified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type )","tags":"","url":"interface/repeat.html"},{"title":"reverse – PIC","text":"public interface reverse Reverses the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\nreverse character sequence Calls interface~~reverse~~CallsGraph interface~reverse reverse proc~reverse_string reverse_string interface~reverse->proc~reverse_string proc~maybe maybe proc~reverse_string->proc~maybe reverse_ reverse_ proc~reverse_string->reverse_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function reverse_string (string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/reverse.html"},{"title":"scan – PIC","text":"public interface scan Scan a string for the presence of a set of characters. Scans a string for\nany of the characters in a set of characters. If back is either absent or false , this function returns the position\nof the leftmost character of string that is in set . If back is true ,\nthe rightmost position is returned. If no character of set is found in string , the result is zero. This method is elemental and returns a default integer scalar value. Calls interface~~scan~~CallsGraph interface~scan scan proc~scan_char_string scan_char_string interface~scan->proc~scan_char_string proc~scan_string_char scan_string_char interface~scan->proc~scan_string_char proc~scan_string_string scan_string_string interface~scan->proc~scan_string_string interface~pic_optional pic_optional proc~scan_char_string->interface~pic_optional proc~maybe maybe proc~scan_char_string->proc~maybe proc~scan_string_char->interface~pic_optional proc~scan_string_char->proc~maybe proc~scan_string_string->interface~pic_optional proc~scan_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function scan_string_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version both the character sequence and the character set are\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/scan.html"},{"title":"slen – PIC","text":"public interface slen Returns the length of the character sequence represented by the string. This method is elemental and returns a default integer scalar value. Calls interface~~slen~~CallsGraph interface~slen slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~slen~~CalledByGraph interface~slen slen proc~iachar_string iachar_string proc~iachar_string->interface~slen proc~ichar_string ichar_string proc~ichar_string->interface~slen proc~to_c_char_from_string to_c_char_from_string proc~to_c_char_from_string->interface~slen proc~write_unformatted write_unformatted proc~write_unformatted->interface~slen interface~iachar iachar interface~iachar->proc~iachar_string interface~ichar ichar interface~ichar->proc~ichar_string interface~to_c_char to_c_char interface~to_c_char->proc~to_c_char_from_string interface~write (unformatted) write (unformatted) interface~write (unformatted)->proc~write_unformatted Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function len_string (string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer","tags":"","url":"interface/slen.html"},{"title":"string_type – PIC","text":"public interface string_type Constructor for new string instances Functions private elemental module function new_string(string) result(new) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental module function new_string_from_integer_int32(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_integer_int64(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_logical_fbool(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: val Return Value type( string_type )","tags":"","url":"interface/string_type.html"},{"title":"to_lower – PIC","text":"public interface to_lower Returns the lowercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\nlowercase character sequence Calls interface~~to_lower~~CallsGraph interface~to_lower to_lower proc~to_lower_string to_lower_string interface~to_lower->proc~to_lower_string proc~maybe maybe proc~to_lower_string->proc~maybe to_lower_ to_lower_ proc~to_lower_string->to_lower_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function to_lower_string (string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/to_lower.html"},{"title":"to_sentence – PIC","text":"public interface to_sentence Returns the sentencecase version of the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\nsentencecase character sequence Calls interface~~to_sentence~~CallsGraph interface~to_sentence to_sentence proc~to_sentence_string to_sentence_string interface~to_sentence->proc~to_sentence_string proc~maybe maybe proc~to_sentence_string->proc~maybe to_sentence_ to_sentence_ proc~to_sentence_string->to_sentence_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function to_sentence_string (string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/to_sentence.html"},{"title":"to_title – PIC","text":"public interface to_title Returns the titlecase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\ntitlecase character sequence Calls interface~~to_title~~CallsGraph interface~to_title to_title proc~to_title_string to_title_string interface~to_title->proc~to_title_string proc~maybe maybe proc~to_title_string->proc~maybe to_title_ to_title_ proc~to_title_string->to_title_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function to_title_string (string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/to_title.html"},{"title":"to_upper – PIC","text":"public interface to_upper Returns the uppercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\nuppercase character sequence Calls interface~~to_upper~~CallsGraph interface~to_upper to_upper proc~to_upper_string to_upper_string interface~to_upper->proc~to_upper_string proc~maybe maybe proc~to_upper_string->proc~maybe to_upper_ to_upper_ proc~to_upper_string->to_upper_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function to_upper_string (string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/to_upper.html"},{"title":"trim – PIC","text":"public interface trim Returns the character sequence hold by the string without trailing spaces. This method is elemental and returns a scalar character value. Calls interface~~trim~~CallsGraph interface~trim trim proc~trim_string trim_string interface~trim->proc~trim_string proc~maybe maybe proc~trim_string->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function trim_string (string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type )","tags":"","url":"interface/trim.html"},{"title":"verify – PIC","text":"public interface verify Scan a string for the absence of a set of characters. Verifies that all\nthe characters in string belong to the set of characters in set. If back is either absent or false , this function returns the position\nof the leftmost character of string that is not in set . If back is true ,\nthe rightmost position is returned. If all characters of string are found\nin set , the result is zero. This method is elemental and returns a default integer scalar value. Calls interface~~verify~~CallsGraph interface~verify verify proc~verify_char_string verify_char_string interface~verify->proc~verify_char_string proc~verify_string_char verify_string_char interface~verify->proc~verify_string_char proc~verify_string_string verify_string_string interface~verify->proc~verify_string_string interface~pic_optional pic_optional proc~verify_char_string->interface~pic_optional proc~maybe maybe proc~verify_char_string->proc~maybe proc~verify_string_char->interface~pic_optional proc~verify_string_char->proc~maybe proc~verify_string_string->interface~pic_optional proc~verify_string_string->proc~maybe proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function verify_string_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version both the character sequence and\nthe character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the character sequences is\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the set of characters is\nrepresented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer","tags":"","url":"interface/verify.html"},{"title":"write (formatted) – PIC","text":"public interface write (formatted) Write the character sequence hold by the string to a connected formatted\nunit. Calls interface~~write (formatted)~~CallsGraph interface~write (formatted) write (formatted) proc~write_formatted write_formatted interface~write (formatted)->proc~write_formatted proc~maybe maybe proc~write_formatted->proc~maybe Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine write_formatted (string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"interface/write (formatted).html"},{"title":"write (unformatted) – PIC","text":"public interface write (unformatted) Write the character sequence hold by the string to a connected unformatted\nunit. Calls interface~~write (unformatted)~~CallsGraph interface~write (unformatted) write (unformatted) proc~write_unformatted write_unformatted interface~write (unformatted)->proc~write_unformatted interface~slen slen proc~write_unformatted->interface~slen proc~maybe maybe proc~write_unformatted->proc~maybe proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine write_unformatted (string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"interface/write (unformatted).html"},{"title":"is_alpha – PIC","text":"public elemental function is_alpha(c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_alpha ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alpha = ( c >= 'A' . and . c <= 'Z' ) . or . ( c >= 'a' . and . c <= 'z' ) end function is_alpha","tags":"","url":"proc/is_alpha.html"},{"title":"is_alphanum – PIC","text":"public elemental function is_alphanum(c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Called by proc~~is_alphanum~~CalledByGraph proc~is_alphanum is_alphanum proc~is_punctuation is_punctuation proc~is_punctuation->proc~is_alphanum proc~to_sentence to_sentence proc~to_sentence->proc~is_alphanum proc~to_title to_title proc~to_title->proc~is_alphanum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental logical function is_alphanum ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alphanum = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'z' ) & . or . ( c >= 'A' . and . c <= 'Z' ) end function is_alphanum","tags":"","url":"proc/is_alphanum.html"},{"title":"is_ascii – PIC","text":"public elemental function is_ascii(c) Checks whether or not c is in the ASCII character set -\ni.e. in the range 0 .. 0x7F. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_ascii ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_ascii = iachar ( c ) <= int ( z '7F' ) end function is_ascii","tags":"","url":"proc/is_ascii.html"},{"title":"is_blank – PIC","text":"public elemental function is_blank(c) Checks whether or not c is a blank character. That includes the\nonly the space and tab characters Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_blank ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB is_blank = ( c == ' ' ) . or . ( ic == int ( z '09' )) end function is_blank","tags":"","url":"proc/is_blank.html"},{"title":"is_control – PIC","text":"public elemental function is_control(c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_control ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_control = ic < int ( z '20' ) . or . ic == int ( z '7F' ) end function is_control","tags":"","url":"proc/is_control.html"},{"title":"is_digit – PIC","text":"public elemental function is_digit(c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_digit = ( '0' <= c ) . and . ( c <= '9' ) end function is_digit","tags":"","url":"proc/is_digit.html"},{"title":"is_graphical – PIC","text":"public elemental function is_graphical(c) Checks whether or not c is a printable character other than the\nspace character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_graphical ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is graphical if it's between '!' and '~' in the ASCII table, !that is: printable but not a space is_graphical = ( int ( z '21' ) <= ic ) . and . ( ic <= int ( z '7E' )) end function is_graphical","tags":"","url":"proc/is_graphical.html"},{"title":"is_hex_digit – PIC","text":"public elemental function is_hex_digit(c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_hex_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_hex_digit = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'f' ) & . or . ( c >= 'A' . and . c <= 'F' ) end function is_hex_digit","tags":"","url":"proc/is_hex_digit.html"},{"title":"is_lower – PIC","text":"public elemental function is_lower(c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_lower ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_lower = ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' ) end function is_lower","tags":"","url":"proc/is_lower.html"},{"title":"is_octal_digit – PIC","text":"public elemental function is_octal_digit(c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_octal_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_octal_digit = ( c >= '0' ) . and . ( c <= '7' ) end function is_octal_digit","tags":"","url":"proc/is_octal_digit.html"},{"title":"is_printable – PIC","text":"public elemental function is_printable(c) Checks whether or not c is a printable character - including the\nspace character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_printable ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is printable if it's between ' ' and '~' in the ASCII table is_printable = ic >= iachar ( ' ' ) . and . ic <= int ( z '7E' ) end function is_printable","tags":"","url":"proc/is_printable.html"},{"title":"is_punctuation – PIC","text":"public elemental function is_punctuation(c) Checks whether or not c is a punctuation character. That includes\nall ASCII characters which are not control characters, letters,\ndigits, or whitespace. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Calls proc~~is_punctuation~~CallsGraph proc~is_punctuation is_punctuation proc~is_alphanum is_alphanum proc~is_punctuation->proc~is_alphanum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_punctuation ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !       '~'                 '!' is_punctuation = ( ic <= int ( z '7E' )) . and . ( ic >= int ( z '21' )) . and . & (. not . is_alphanum ( c )) end function is_punctuation","tags":"","url":"proc/is_punctuation.html"},{"title":"is_upper – PIC","text":"public elemental function is_upper(c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Source Code elemental logical function is_upper ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_upper = ( c >= 'A' ) . and . ( c <= 'Z' ) end function is_upper","tags":"","url":"proc/is_upper.html"},{"title":"is_white – PIC","text":"public elemental function is_white(c) Checks whether or not c is a whitespace character. That includes the\nspace, tab, vertical tab, form feed, carriage return, and linefeed\ncharacters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical Variables Type Visibility Attributes Name Initial integer, private :: ic Source Code elemental logical function is_white ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB, LF, VT, FF, CR is_white = ( c == ' ' ) . or . ( ic >= int ( z '09' ) . and . ic <= int ( z '0D' )) end function is_white","tags":"","url":"proc/is_white.html"},{"title":"reverse – PIC","text":"public elemental function reverse(string) result(reverse_string) Reverse the character order in the input character variable Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: n Source Code elemental function reverse ( string ) result ( reverse_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: reverse_string integer :: i , n n = len ( string ) do i = 1 , n reverse_string ( n - i + 1 : n - i + 1 ) = string ( i : i ) end do end function reverse","tags":"","url":"proc/reverse.html"},{"title":"to_lower – PIC","text":"public elemental function to_lower(string) result(lower_string) Convert character variable to lower case Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Calls proc~~to_lower~~CallsGraph proc~to_lower to_lower proc~char_to_lower char_to_lower proc~to_lower->proc~char_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code elemental function to_lower ( string ) result ( lower_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lower_string integer :: i do i = 1 , len ( string ) lower_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_lower","tags":"","url":"proc/to_lower.html"},{"title":"to_sentence – PIC","text":"public elemental function to_sentence(string) result(sentence_string) Converts character sequence to sentence case Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Calls proc~~to_sentence~~CallsGraph proc~to_sentence to_sentence proc~char_to_lower char_to_lower proc~to_sentence->proc~char_to_lower proc~char_to_upper char_to_upper proc~to_sentence->proc~char_to_upper proc~is_alphanum is_alphanum proc~to_sentence->proc~is_alphanum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: n Source Code elemental function to_sentence ( string ) result ( sentence_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: sentence_string integer :: i , n n = len ( string ) do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then sentence_string ( i : i ) = char_to_upper ( string ( i : i )) n = i exit else sentence_string ( i : i ) = string ( i : i ) end if end do do i = n + 1 , len ( string ) sentence_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_sentence","tags":"","url":"proc/to_sentence.html"},{"title":"to_title – PIC","text":"public elemental function to_title(string) result(title_string) Converts character sequence to title case Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Calls proc~~to_title~~CallsGraph proc~to_title to_title proc~char_to_lower char_to_lower proc~to_title->proc~char_to_lower proc~char_to_upper char_to_upper proc~to_title->proc~char_to_upper proc~is_alphanum is_alphanum proc~to_title->proc~is_alphanum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial logical, private :: capitalize_switch integer, private :: i Source Code elemental function to_title ( string ) result ( title_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: title_string integer :: i logical :: capitalize_switch capitalize_switch = . true . do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then if ( capitalize_switch ) then title_string ( i : i ) = char_to_upper ( string ( i : i )) capitalize_switch = . false . else title_string ( i : i ) = char_to_lower ( string ( i : i )) end if else title_string ( i : i ) = string ( i : i ) capitalize_switch = . true . end if end do end function to_title","tags":"","url":"proc/to_title.html"},{"title":"to_upper – PIC","text":"public elemental function to_upper(string) result(upper_string) Convert character variable to upper case Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) Calls proc~~to_upper~~CallsGraph proc~to_upper to_upper proc~char_to_upper char_to_upper proc~to_upper->proc~char_to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i Source Code elemental function to_upper ( string ) result ( upper_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: upper_string integer :: i do i = 1 , len ( string ) upper_string ( i : i ) = char_to_upper ( string ( i : i )) end do end function to_upper","tags":"","url":"proc/to_upper.html"},{"title":"char_to_lower – PIC","text":"private elemental function char_to_lower(c) result(t) Returns the corresponding lowercase letter, if c is an uppercase\nASCII character, otherwise c itself. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Called by proc~~char_to_lower~~CalledByGraph proc~char_to_lower char_to_lower proc~to_lower to_lower proc~to_lower->proc~char_to_lower proc~to_sentence to_sentence proc~to_sentence->proc~char_to_lower proc~to_title to_title proc~to_title->proc~char_to_lower Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: BA = iachar('A') integer, private, parameter :: BZ = iachar('Z') integer, private :: k integer, private, parameter :: wp = iachar('a')-iachar('A') Source Code elemental function char_to_lower ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer , parameter :: wp = iachar ( 'a' ) - iachar ( 'A' ), BA = iachar ( 'A' ), BZ = iachar ( 'Z' ) integer :: k !Check whether the integer equivalent is between BA=65 and BZ=90 k = ichar ( c ) if ( k >= BA . and . k <= BZ ) k = k + wp t = char ( k ) end function char_to_lower","tags":"","url":"proc/char_to_lower.html"},{"title":"char_to_upper – PIC","text":"private elemental function char_to_upper(c) result(t) Returns the corresponding uppercase letter, if c is a lowercase\nASCII character, otherwise c itself. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) Called by proc~~char_to_upper~~CalledByGraph proc~char_to_upper char_to_upper proc~to_sentence to_sentence proc~to_sentence->proc~char_to_upper proc~to_title to_title proc~to_title->proc~char_to_upper proc~to_upper to_upper proc~to_upper->proc~char_to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: k integer, private, parameter :: la = iachar('a') integer, private, parameter :: lz = iachar('z') integer, private, parameter :: wp = iachar('a')-iachar('A') Source Code elemental function char_to_upper ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer , parameter :: wp = iachar ( 'a' ) - iachar ( 'A' ), la = iachar ( 'a' ), lz = iachar ( 'z' ) integer :: k !Check whether the integer equivalent is between la=97 and lz=122 k = ichar ( c ) if ( k >= la . and . k <= lz ) k = k - wp t = char ( k ) end function char_to_upper","tags":"","url":"proc/char_to_upper.html"},{"title":"reverse – PIC","text":"private interface reverse Returns a new character sequence which is reverse of\nthe input charater sequence\nThis method is elemental and returns a character sequence Module Procedures private  interface reverse () Returns a new character sequence which is reverse of\nthe input charater sequence\nThis method is elemental and returns a character sequence Arguments None","tags":"","url":"interface/reverse~2.html"},{"title":"to_lower – PIC","text":"private interface to_lower Returns a new character sequence which is the lower case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Module Procedures private  interface to_lower () Returns a new character sequence which is the lower case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None","tags":"","url":"interface/to_lower~2.html"},{"title":"to_sentence – PIC","text":"private interface to_sentence Returns a new character sequence which is the sentence case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Module Procedures private  interface to_sentence () Returns a new character sequence which is the sentence case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None","tags":"","url":"interface/to_sentence~2.html"},{"title":"to_title – PIC","text":"private interface to_title Returns a new character sequence which is the title case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Module Procedures private  interface to_title () Returns a new character sequence which is the title case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None","tags":"","url":"interface/to_title~2.html"},{"title":"to_upper – PIC","text":"private interface to_upper Returns a new character sequence which is the upper case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Module Procedures private  interface to_upper () Returns a new character sequence which is the upper case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None","tags":"","url":"interface/to_upper~2.html"},{"title":"chomp_char – PIC","text":"private pure function chomp_char(string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Called by proc~~chomp_char~~CalledByGraph proc~chomp_char chomp_char interface~chomp chomp interface~chomp->proc~chomp_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last Source Code pure function chomp_char ( string ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = string ( 1 : last ) end function chomp_char","tags":"","url":"proc/chomp_char.html"},{"title":"chomp_set_char_char – PIC","text":"private pure function chomp_set_char_char(string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:), allocatable Calls proc~~chomp_set_char_char~~CallsGraph proc~chomp_set_char_char chomp_set_char_char proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chomp_set_char_char~~CalledByGraph proc~chomp_set_char_char chomp_set_char_char interface~chomp chomp interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last Source Code pure function chomp_set_char_char ( string , set ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , set_to_string ( set ), back = . true .) chomped_string = string ( 1 : last ) end function chomp_set_char_char","tags":"","url":"proc/chomp_set_char_char.html"},{"title":"chomp_set_string_char – PIC","text":"private pure function chomp_set_string_char(string, set) result(chomped_string) Uses pic_string_type proc~~chomp_set_string_char~~UsesGraph proc~chomp_set_string_char chomp_set_string_char module~pic_string_type pic_string_type proc~chomp_set_string_char->module~pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) Calls proc~~chomp_set_string_char~~CallsGraph proc~chomp_set_string_char chomp_set_string_char interface~chomp chomp proc~chomp_set_string_char->interface~chomp interface~chomp->proc~chomp_set_string_char proc~chomp_char chomp_char interface~chomp->proc~chomp_char proc~chomp_set_char_char chomp_set_char_char interface~chomp->proc~chomp_set_char_char proc~chomp_string chomp_string interface~chomp->proc~chomp_string proc~chomp_substring_char_char chomp_substring_char_char interface~chomp->proc~chomp_substring_char_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chomp_set_string_char~~CalledByGraph proc~chomp_set_string_char chomp_set_string_char interface~chomp chomp proc~chomp_set_string_char->interface~chomp interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function chomp_set_string_char ( string , set ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), set ) end function chomp_set_string_char","tags":"","url":"proc/chomp_set_string_char.html"},{"title":"chomp_string – PIC","text":"private pure function chomp_string(string) result(chomped_string) Uses pic_string_type proc~~chomp_string~~UsesGraph proc~chomp_string chomp_string module~pic_string_type pic_string_type proc~chomp_string->module~pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Called by proc~~chomp_string~~CalledByGraph proc~chomp_string chomp_string interface~chomp chomp interface~chomp->proc~chomp_string proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last Source Code pure function chomp_string ( string ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = char ( string , 1 , last ) end function chomp_string","tags":"","url":"proc/chomp_string.html"},{"title":"chomp_substring_char_char – PIC","text":"private pure function chomp_substring_char_char(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:), allocatable Called by proc~~chomp_substring_char_char~~CalledByGraph proc~chomp_substring_char_char chomp_substring_char_char interface~chomp chomp interface~chomp->proc~chomp_substring_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last integer, private :: nsub Source Code pure function chomp_substring_char_char ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( nsub > 0 . and . nsub <= last ) then do while ( last >= nsub ) if ( string ( last - nsub + 1 : last ) == substring ) then last = last - nsub else exit end if end do end if if ( last <= 0 ) then chomped_string = '' else chomped_string = string ( 1 : last ) end if end function chomp_substring_char_char","tags":"","url":"proc/chomp_substring_char_char.html"},{"title":"chomp_substring_char_string – PIC","text":"private pure function chomp_substring_char_string(string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:), allocatable Calls proc~~chomp_substring_char_string~~CallsGraph proc~chomp_substring_char_string chomp_substring_char_string interface~chomp chomp proc~chomp_substring_char_string->interface~chomp interface~chomp->proc~chomp_substring_char_string proc~chomp_char chomp_char interface~chomp->proc~chomp_char proc~chomp_set_char_char chomp_set_char_char interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_string chomp_string interface~chomp->proc~chomp_string proc~chomp_substring_char_char chomp_substring_char_char interface~chomp->proc~chomp_substring_char_char proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chomp_substring_char_string~~CalledByGraph proc~chomp_substring_char_string chomp_substring_char_string interface~chomp chomp proc~chomp_substring_char_string->interface~chomp interface~chomp->proc~chomp_substring_char_string proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function chomp_substring_char_string ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string chomped_string = chomp ( string , char ( substring )) end function chomp_substring_char_string","tags":"","url":"proc/chomp_substring_char_string.html"},{"title":"chomp_substring_string_char – PIC","text":"private pure function chomp_substring_string_char(string, substring) result(chomped_string) Uses pic_string_type proc~~chomp_substring_string_char~~UsesGraph proc~chomp_substring_string_char chomp_substring_string_char module~pic_string_type pic_string_type proc~chomp_substring_string_char->module~pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) Calls proc~~chomp_substring_string_char~~CallsGraph proc~chomp_substring_string_char chomp_substring_string_char interface~chomp chomp proc~chomp_substring_string_char->interface~chomp interface~chomp->proc~chomp_substring_string_char proc~chomp_char chomp_char interface~chomp->proc~chomp_char proc~chomp_set_char_char chomp_set_char_char interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_string chomp_string interface~chomp->proc~chomp_string proc~chomp_substring_char_char chomp_substring_char_char interface~chomp->proc~chomp_substring_char_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chomp_substring_string_char~~CalledByGraph proc~chomp_substring_string_char chomp_substring_string_char interface~chomp chomp proc~chomp_substring_string_char->interface~chomp interface~chomp->proc~chomp_substring_string_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function chomp_substring_string_char ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), substring ) end function chomp_substring_string_char","tags":"","url":"proc/chomp_substring_string_char.html"},{"title":"chomp_substring_string_string – PIC","text":"private pure function chomp_substring_string_string(string, substring) result(chomped_string) Uses pic_string_type proc~~chomp_substring_string_string~~UsesGraph proc~chomp_substring_string_string chomp_substring_string_string module~pic_string_type pic_string_type proc~chomp_substring_string_string->module~pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) Calls proc~~chomp_substring_string_string~~CallsGraph proc~chomp_substring_string_string chomp_substring_string_string interface~chomp chomp proc~chomp_substring_string_string->interface~chomp interface~chomp->proc~chomp_substring_string_string proc~chomp_char chomp_char interface~chomp->proc~chomp_char proc~chomp_set_char_char chomp_set_char_char interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_string chomp_string interface~chomp->proc~chomp_string proc~chomp_substring_char_char chomp_substring_char_char interface~chomp->proc~chomp_substring_char_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~chomp_substring_string_string~~CalledByGraph proc~chomp_substring_string_string chomp_substring_string_string interface~chomp chomp proc~chomp_substring_string_string->interface~chomp interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function chomp_substring_string_string ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), char ( substring )) end function chomp_substring_string_string","tags":"","url":"proc/chomp_substring_string_string.html"},{"title":"compute_lps – PIC","text":"private pure function compute_lps(string) result(lps_array) Computes longest prefix suffix for each index of the input ‘string’ Returns an array of integers Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer, (len(string)) Called by proc~~compute_lps~~CalledByGraph proc~compute_lps compute_lps proc~count_char_char count_char_char proc~count_char_char->proc~compute_lps proc~find_char_char find_char_char proc~find_char_char->proc~compute_lps proc~replace_all_char_char_char replace_all_char_char_char proc~replace_all_char_char_char->proc~compute_lps interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~replace_all replace_all interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: length_string Source Code pure function compute_lps ( string ) result ( lps_array ) character ( len =* ), intent ( in ) :: string integer :: lps_array ( len ( string )) integer :: i , j , length_string length_string = len ( string ) if ( length_string > 0 ) then lps_array ( 1 ) = 0 i = 2 j = 1 do while ( i <= length_string ) if ( string ( j : j ) == string ( i : i )) then lps_array ( i ) = j i = i + 1 j = j + 1 else if ( j > 1 ) then j = lps_array ( j - 1 ) + 1 else lps_array ( i ) = 0 i = i + 1 end if end do end if end function compute_lps","tags":"","url":"proc/compute_lps.html"},{"title":"count_char_char – PIC","text":"private elemental function count_char_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer Calls proc~~count_char_char~~CallsGraph proc~count_char_char count_char_char interface~pic_optional pic_optional proc~count_char_char->interface~pic_optional proc~compute_lps compute_lps proc~count_char_char->proc~compute_lps proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~count_char_char~~CalledByGraph proc~count_char_char count_char_char interface~count count interface~count->proc~count_char_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: length_pattern integer, private :: length_string integer, private :: lps_array (len(pattern)) integer, private :: p_i integer, private :: s_i Source Code elemental function count_char_char ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res + 1 if ( pic_optional ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function count_char_char","tags":"","url":"proc/count_char_char.html"},{"title":"count_char_string – PIC","text":"private elemental function count_char_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer Called by proc~~count_char_string~~CalledByGraph proc~count_char_string count_char_string interface~count count interface~count->proc~count_char_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function count_char_string ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( string , char ( pattern ), consider_overlapping ) end function count_char_string","tags":"","url":"proc/count_char_string.html"},{"title":"count_string_char – PIC","text":"private elemental function count_string_char(string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer Called by proc~~count_string_char~~CalledByGraph proc~count_string_char count_string_char interface~count count interface~count->proc~count_string_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function count_string_char ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), pattern , consider_overlapping ) end function count_string_char","tags":"","url":"proc/count_string_char.html"},{"title":"count_string_string – PIC","text":"private elemental function count_string_string(string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer Called by proc~~count_string_string~~CalledByGraph proc~count_string_string count_string_string interface~count count interface~count->proc~count_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function count_string_string ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), char ( pattern ), consider_overlapping ) end function count_string_string","tags":"","url":"proc/count_string_string.html"},{"title":"ends_with_char_char – PIC","text":"private pure function ends_with_char_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Called by proc~~ends_with_char_char~~CalledByGraph proc~ends_with_char_char ends_with_char_char interface~ends_with ends_with interface~ends_with->proc~ends_with_char_char proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string->interface~ends_with proc~ends_with_string_char->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last integer, private :: nsub Source Code pure function ends_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( last < nsub ) then match = . false . return end if match = string ( last - nsub + 1 : last ) == substring end function ends_with_char_char","tags":"","url":"proc/ends_with_char_char.html"},{"title":"ends_with_char_string – PIC","text":"private elemental function ends_with_char_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical Calls proc~~ends_with_char_string~~CallsGraph proc~ends_with_char_string ends_with_char_string interface~ends_with ends_with proc~ends_with_char_string->interface~ends_with interface~ends_with->proc~ends_with_char_string proc~ends_with_char_char ends_with_char_char interface~ends_with->proc~ends_with_char_char proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_string_char->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ends_with_char_string~~CalledByGraph proc~ends_with_char_string ends_with_char_string interface~ends_with ends_with proc~ends_with_char_string->interface~ends_with interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_string_char->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ends_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( string , char ( substring )) end function ends_with_char_string","tags":"","url":"proc/ends_with_char_string.html"},{"title":"ends_with_string_char – PIC","text":"private elemental function ends_with_string_char(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Calls proc~~ends_with_string_char~~CallsGraph proc~ends_with_string_char ends_with_string_char interface~ends_with ends_with proc~ends_with_string_char->interface~ends_with interface~ends_with->proc~ends_with_string_char proc~ends_with_char_char ends_with_char_char interface~ends_with->proc~ends_with_char_char proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ends_with_string_char~~CalledByGraph proc~ends_with_string_char ends_with_string_char interface~ends_with ends_with proc~ends_with_string_char->interface~ends_with interface~ends_with->proc~ends_with_string_char proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ends_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), substring ) end function ends_with_string_char","tags":"","url":"proc/ends_with_string_char.html"},{"title":"ends_with_string_string – PIC","text":"private elemental function ends_with_string_string(string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical Calls proc~~ends_with_string_string~~CallsGraph proc~ends_with_string_string ends_with_string_string interface~ends_with ends_with proc~ends_with_string_string->interface~ends_with interface~ends_with->proc~ends_with_string_string proc~ends_with_char_char ends_with_char_char interface~ends_with->proc~ends_with_char_char proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_char_string->interface~ends_with proc~ends_with_string_char->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~ends_with_string_string~~CalledByGraph proc~ends_with_string_string ends_with_string_string interface~ends_with ends_with proc~ends_with_string_string->interface~ends_with interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_char_string->interface~ends_with proc~ends_with_string_char->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function ends_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), char ( substring )) end function ends_with_string_string","tags":"","url":"proc/ends_with_string_string.html"},{"title":"find_char_char – PIC","text":"private elemental function find_char_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer Calls proc~~find_char_char~~CallsGraph proc~find_char_char find_char_char interface~pic_optional pic_optional proc~find_char_char->interface~pic_optional proc~compute_lps compute_lps proc~find_char_char->proc~compute_lps proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_char_char~~CalledByGraph proc~find_char_char find_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: length_pattern integer, private :: length_string integer, private :: lps_array (len(pattern)) integer, private :: occurrence_ integer, private :: p_i integer, private :: s_i Source Code elemental function find_char_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern , occurrence_ occurrence_ = pic_optional ( occurrence , 1 ) res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string & & . and . occurrence_ > 0 ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then occurrence_ = occurrence_ - 1 if ( occurrence_ == 0 ) then res = s_i - length_pattern + 1 exit else if ( pic_optional ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function find_char_char","tags":"","url":"proc/find_char_char.html"},{"title":"find_char_string – PIC","text":"private elemental function find_char_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer Calls proc~~find_char_string~~CallsGraph proc~find_char_string find_char_string interface~find find proc~find_char_string->interface~find interface~find->proc~find_char_string proc~find_char_char find_char_char interface~find->proc~find_char_char proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~pic_optional pic_optional proc~find_char_char->interface~pic_optional proc~compute_lps compute_lps proc~find_char_char->proc~compute_lps proc~find_string_char->interface~find proc~find_string_string->interface~find proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_char_string~~CalledByGraph proc~find_char_string find_char_string interface~find find proc~find_char_string->interface~find interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function find_char_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( string , char ( pattern ), occurrence , consider_overlapping ) end function find_char_string","tags":"","url":"proc/find_char_string.html"},{"title":"find_string_char – PIC","text":"private elemental function find_string_char(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer Calls proc~~find_string_char~~CallsGraph proc~find_string_char find_string_char interface~find find proc~find_string_char->interface~find interface~find->proc~find_string_char proc~find_char_char find_char_char interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_string find_string_string interface~find->proc~find_string_string interface~pic_optional pic_optional proc~find_char_char->interface~pic_optional proc~compute_lps compute_lps proc~find_char_char->proc~compute_lps proc~find_char_string->interface~find proc~find_string_string->interface~find proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_string_char~~CalledByGraph proc~find_string_char find_string_char interface~find find proc~find_string_char->interface~find interface~find->proc~find_string_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_string find_string_string interface~find->proc~find_string_string proc~find_char_string->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function find_string_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), pattern , occurrence , consider_overlapping ) end function find_string_char","tags":"","url":"proc/find_string_char.html"},{"title":"find_string_string – PIC","text":"private elemental function find_string_string(string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer Calls proc~~find_string_string~~CallsGraph proc~find_string_string find_string_string interface~find find proc~find_string_string->interface~find interface~find->proc~find_string_string proc~find_char_char find_char_char interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char interface~pic_optional pic_optional proc~find_char_char->interface~pic_optional proc~compute_lps compute_lps proc~find_char_char->proc~compute_lps proc~find_char_string->interface~find proc~find_string_char->interface~find proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~find_string_string~~CalledByGraph proc~find_string_string find_string_string interface~find find proc~find_string_string->interface~find interface~find->proc~find_string_string proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_char_string->interface~find proc~find_string_char->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function find_string_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), char ( pattern ), occurrence , consider_overlapping ) end function find_string_string","tags":"","url":"proc/find_string_string.html"},{"title":"join_char – PIC","text":"private pure function join_char(strings, separator) result(joined) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable Called by proc~~join_char~~CalledByGraph proc~join_char join_char interface~join join interface~join->proc~join_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lt integer, private :: ltot integer, private :: pos character(len=:), private, allocatable :: sep Source Code pure function join_char ( strings , separator ) result ( joined ) character ( * ), intent ( in ) :: strings (:) character ( len =* ), intent ( in ), optional :: separator character ( len = :), allocatable :: joined integer :: ltot , i , lt , pos character ( len = :), allocatable :: sep ! Determine separator: use user-provided separator or default space if ( present ( separator )) then sep = separator else sep = ' ' end if ! Calculate the total length required, including separators ltot = sum ( len_trim ( strings )) + ( size ( strings ) - 1 ) * len ( sep ) allocate ( character ( len = ltot ) :: joined ) joined = repeat ( ' ' , ltot ) ! Concatenate strings with separator pos = 0 do i = 1 , size ( strings ) lt = len_trim ( strings ( i )) joined ( pos + 1 : pos + lt ) = strings ( i ) ( 1 : lt ) pos = pos + lt if ( i < size ( strings )) then joined ( pos + 1 : pos + len ( sep )) = sep pos = pos + len ( sep ) end if end do end function join_char","tags":"","url":"proc/join_char.html"},{"title":"join_string – PIC","text":"private pure function join_string(strings, separator) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value type( string_type ) Calls proc~~join_string~~CallsGraph proc~join_string join_string interface~move move proc~join_string->interface~move proc~move_char_char move_char_char interface~move->proc~move_char_char proc~move_char_string move_char_string interface~move->proc~move_char_string proc~move_string_char move_string_char interface~move->proc~move_string_char proc~move_string_string move_string_string interface~move->proc~move_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~join_string~~CalledByGraph proc~join_string join_string interface~join join interface~join->proc~join_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=:), private, allocatable :: joined integer, private :: lt integer, private :: ltot integer, private :: pos character(len=:), private, allocatable :: sep Source Code pure type ( string_type ) function join_string ( strings , separator ) type ( string_type ), intent ( in ) :: strings (:) character ( len =* ), intent ( in ), optional :: separator integer :: ltot , i , lt , pos character ( len = :), allocatable :: sep , joined ! Determine separator: use user-provided separator or default space if ( present ( separator )) then sep = separator else sep = ' ' end if ! Calculate the total length required, including separators ltot = sum ( len_trim ( strings )) + ( size ( strings ) - 1 ) * len ( sep ) allocate ( character ( len = ltot ) :: joined ) ! Concatenate strings with separator pos = 0 do i = 1 , size ( strings ) lt = len_trim ( strings ( i )) joined ( pos + 1 : pos + lt ) = char ( strings ( i ), 1 , lt ) pos = pos + lt if ( i < size ( strings )) then joined ( pos + 1 : pos + len ( sep )) = sep pos = pos + len ( sep ) end if end do call move ( from = joined , to = join_string ) end function join_string","tags":"","url":"proc/join_string.html"},{"title":"padl_char_default – PIC","text":"private pure function padl_char_default(string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) Calls proc~~padl_char_default~~CallsGraph proc~padl_char_default padl_char_default interface~padl padl proc~padl_char_default->interface~padl interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~padl_char_default~~CalledByGraph proc~padl_char_default padl_char_default interface~padl padl proc~padl_char_default->interface~padl interface~padl->proc~padl_char_default proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl proc~zfill_char zfill_char proc~zfill_char->interface~padl proc~zfill_string zfill_string proc~zfill_string->interface~padl interface~zfill zfill interface~zfill->proc~zfill_char interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function padl_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = padl ( string , output_length , \" \" ) end function padl_char_default","tags":"","url":"proc/padl_char_default.html"},{"title":"padl_char_pad_with – PIC","text":"private pure function padl_char_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) Called by proc~~padl_char_pad_with~~CalledByGraph proc~padl_char_pad_with padl_char_pad_with interface~padl padl interface~padl->proc~padl_char_pad_with proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl proc~zfill_char zfill_char proc~zfill_char->interface~padl proc~zfill_string zfill_string proc~zfill_string->interface~padl interface~zfill zfill interface~zfill->proc~zfill_char interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: string_length Source Code pure function padl_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) if ( string_length < output_length ) then res = repeat ( pad_with , output_length - string_length ) res ( output_length - string_length + 1 : output_length ) = string else res = string end if end function padl_char_pad_with","tags":"","url":"proc/padl_char_pad_with.html"},{"title":"padl_string_default – PIC","text":"private pure function padl_string_default(string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) Calls proc~~padl_string_default~~CallsGraph proc~padl_string_default padl_string_default interface~padl padl proc~padl_string_default->interface~padl interface~padl->proc~padl_string_default proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~padl_string_default~~CalledByGraph proc~padl_string_default padl_string_default interface~padl padl proc~padl_string_default->interface~padl interface~padl->proc~padl_string_default proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_pad_with->interface~padl proc~zfill_char zfill_char proc~zfill_char->interface~padl proc~zfill_string zfill_string proc~zfill_string->interface~padl interface~zfill zfill interface~zfill->proc~zfill_char interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function padl_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , \" \" )) end function padl_string_default","tags":"","url":"proc/padl_string_default.html"},{"title":"padl_string_pad_with – PIC","text":"private pure function padl_string_pad_with(string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) Calls proc~~padl_string_pad_with~~CallsGraph proc~padl_string_pad_with padl_string_pad_with interface~padl padl proc~padl_string_pad_with->interface~padl interface~padl->proc~padl_string_pad_with proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~padl_string_pad_with~~CalledByGraph proc~padl_string_pad_with padl_string_pad_with interface~padl padl proc~padl_string_pad_with->interface~padl interface~padl->proc~padl_string_pad_with proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~zfill_char zfill_char proc~zfill_char->interface~padl proc~zfill_string zfill_string proc~zfill_string->interface~padl interface~zfill zfill interface~zfill->proc~zfill_char interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function padl_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , pad_with )) end function padl_string_pad_with","tags":"","url":"proc/padl_string_pad_with.html"},{"title":"padr_char_default – PIC","text":"private pure function padr_char_default(string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) Called by proc~~padr_char_default~~CalledByGraph proc~padr_char_default padr_char_default interface~padr padr interface~padr->proc~padr_char_default proc~padr_string_pad_with padr_string_pad_with interface~padr->proc~padr_string_pad_with proc~padr_string_pad_with->interface~padr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function padr_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = string end function padr_char_default","tags":"","url":"proc/padr_char_default.html"},{"title":"padr_char_pad_with – PIC","text":"private pure function padr_char_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) Called by proc~~padr_char_pad_with~~CalledByGraph proc~padr_char_pad_with padr_char_pad_with interface~padr padr interface~padr->proc~padr_char_pad_with proc~padr_string_pad_with padr_string_pad_with interface~padr->proc~padr_string_pad_with proc~padr_string_pad_with->interface~padr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: string_length Source Code pure function padr_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) res = string if ( string_length < output_length ) then res ( string_length + 1 : output_length ) = & repeat ( pad_with , output_length - string_length ) end if end function padr_char_pad_with","tags":"","url":"proc/padr_char_pad_with.html"},{"title":"padr_string_default – PIC","text":"private pure function padr_string_default(string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) Called by proc~~padr_string_default~~CalledByGraph proc~padr_string_default padr_string_default interface~padr padr interface~padr->proc~padr_string_default proc~padr_string_pad_with padr_string_pad_with interface~padr->proc~padr_string_pad_with proc~padr_string_pad_with->interface~padr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(kind=output_length), len=max), private :: char_output Source Code pure function padr_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( slen ( string ), output_length )) :: char_output type ( string_type ) :: res ! We're taking advantage of `char_output` being longer than `string` and ! initialized with whitespaces. By casting `string` to a `character` ! type and back to `string_type`, we're effectively right-padding ! `string` with spaces, so we don't need to pad explicitly. char_output = char ( string ) res = string_type ( char_output ) end function padr_string_default","tags":"","url":"proc/padr_string_default.html"},{"title":"padr_string_pad_with – PIC","text":"private pure function padr_string_pad_with(string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) Calls proc~~padr_string_pad_with~~CallsGraph proc~padr_string_pad_with padr_string_pad_with interface~padr padr proc~padr_string_pad_with->interface~padr interface~padr->proc~padr_string_pad_with proc~padr_char_default padr_char_default interface~padr->proc~padr_char_default proc~padr_char_pad_with padr_char_pad_with interface~padr->proc~padr_char_pad_with proc~padr_string_default padr_string_default interface~padr->proc~padr_string_default Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~padr_string_pad_with~~CalledByGraph proc~padr_string_pad_with padr_string_pad_with interface~padr padr proc~padr_string_pad_with->interface~padr interface~padr->proc~padr_string_pad_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function padr_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padr ( char ( string ), output_length , pad_with )) end function padr_string_pad_with","tags":"","url":"proc/padr_string_pad_with.html"},{"title":"replace_all_char_char_char – PIC","text":"private pure function replace_all_char_char_char(string, pattern, replacement) result(res) Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable Calls proc~~replace_all_char_char_char~~CallsGraph proc~replace_all_char_char_char replace_all_char_char_char proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_char_char_char~~CalledByGraph proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all replace_all interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: last integer, private :: length_pattern integer, private :: length_string integer, private :: lps_array (len(pattern)) integer, private :: p_i integer, private :: s_i Source Code pure function replace_all_char_char_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res integer :: lps_array ( len ( pattern )) integer :: s_i , p_i , last , length_string , length_pattern res = \"\" length_string = len ( string ) length_pattern = len ( pattern ) last = 1 if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res // & & string ( last : s_i - length_pattern ) // & & replacement last = s_i + 1 p_i = 0 end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if res = res // string ( last : length_string ) end function replace_all_char_char_char","tags":"","url":"proc/replace_all_char_char_char.html"},{"title":"replace_all_char_char_string – PIC","text":"private pure function replace_all_char_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable Calls proc~~replace_all_char_char_string~~CallsGraph proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all replace_all proc~replace_all_char_char_string->interface~replace_all interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_char_char_string~~CalledByGraph proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all replace_all proc~replace_all_char_char_string->interface~replace_all interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_char_char_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , pattern , char ( replacement )) end function replace_all_char_char_string","tags":"","url":"proc/replace_all_char_char_string.html"},{"title":"replace_all_char_string_char – PIC","text":"private pure function replace_all_char_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable Calls proc~~replace_all_char_string_char~~CallsGraph proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all replace_all proc~replace_all_char_string_char->interface~replace_all interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_char_string_char~~CalledByGraph proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all replace_all proc~replace_all_char_string_char->interface~replace_all interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_char_string_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), replacement ) end function replace_all_char_string_char","tags":"","url":"proc/replace_all_char_string_char.html"},{"title":"replace_all_char_string_string – PIC","text":"private pure function replace_all_char_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable Calls proc~~replace_all_char_string_string~~CallsGraph proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all replace_all proc~replace_all_char_string_string->interface~replace_all interface~replace_all->proc~replace_all_char_string_string proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_char_string_string~~CalledByGraph proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all replace_all proc~replace_all_char_string_string->interface~replace_all interface~replace_all->proc~replace_all_char_string_string proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_char_string_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), char ( replacement )) end function replace_all_char_string_string","tags":"","url":"proc/replace_all_char_string_string.html"},{"title":"replace_all_string_char_char – PIC","text":"private pure function replace_all_string_char_char(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) Calls proc~~replace_all_string_char_char~~CallsGraph proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all replace_all proc~replace_all_string_char_char->interface~replace_all interface~replace_all->proc~replace_all_string_char_char proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_string_char_char~~CalledByGraph proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all replace_all proc~replace_all_string_char_char->interface~replace_all interface~replace_all->proc~replace_all_string_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_string_char_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , replacement )) end function replace_all_string_char_char","tags":"","url":"proc/replace_all_string_char_char.html"},{"title":"replace_all_string_char_string – PIC","text":"private pure function replace_all_string_char_string(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) Calls proc~~replace_all_string_char_string~~CallsGraph proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all replace_all proc~replace_all_string_char_string->interface~replace_all interface~replace_all->proc~replace_all_string_char_string proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_string_char_string~~CalledByGraph proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all replace_all proc~replace_all_string_char_string->interface~replace_all interface~replace_all->proc~replace_all_string_char_string proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_string_char_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , char ( replacement ))) end function replace_all_string_char_string","tags":"","url":"proc/replace_all_string_char_string.html"},{"title":"replace_all_string_string_char – PIC","text":"private pure function replace_all_string_string_char(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) Calls proc~~replace_all_string_string_char~~CallsGraph proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all replace_all proc~replace_all_string_string_char->interface~replace_all interface~replace_all->proc~replace_all_string_string_char proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_string_string_char~~CalledByGraph proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all replace_all proc~replace_all_string_string_char->interface~replace_all interface~replace_all->proc~replace_all_string_string_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_string_string_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), char ( pattern ), replacement )) end function replace_all_string_string_char","tags":"","url":"proc/replace_all_string_string_char.html"},{"title":"replace_all_string_string_string – PIC","text":"private pure function replace_all_string_string_string(string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) Calls proc~~replace_all_string_string_string~~CallsGraph proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all replace_all proc~replace_all_string_string_string->interface~replace_all interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~replace_all_string_string_string~~CalledByGraph proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all replace_all proc~replace_all_string_string_string->interface~replace_all interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function replace_all_string_string_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), & & char ( pattern ), char ( replacement ))) end function replace_all_string_string_string","tags":"","url":"proc/replace_all_string_string_string.html"},{"title":"set_to_string – PIC","text":"private pure function set_to_string(set) result(string) Implementation to transfer a set of characters to a string representing the set. This function is internal and not part of the public API. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: set (:) Return Value character(len=size) Called by proc~~set_to_string~~CalledByGraph proc~set_to_string set_to_string proc~chomp_set_char_char chomp_set_char_char proc~chomp_set_char_char->proc~set_to_string interface~chomp chomp interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function set_to_string ( set ) result ( string ) character ( len = 1 ), intent ( in ) :: set (:) character ( len = size ( set )) :: string string = transfer ( set , string ) end function set_to_string","tags":"","url":"proc/set_to_string.html"},{"title":"slice_char – PIC","text":"private pure function slice_char(string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:), allocatable Called by proc~~slice_char~~CalledByGraph proc~slice_char slice_char interface~slice slice interface~slice->proc~slice_char proc~slice_string slice_string interface~slice->proc~slice_string proc~slice_string->interface~slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: first_index integer, private :: i integer, private :: j integer, private :: last_index integer, private :: length_string integer, private :: stride_vector integer, private :: strides_taken Source Code pure function slice_char ( string , first , last , stride ) result ( sliced_string ) character ( len =* ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride integer :: first_index , last_index , stride_vector , strides_taken , length_string , i , j character ( len = :), allocatable :: sliced_string length_string = len ( string ) first_index = 0 ! first_index = -infinity last_index = length_string + 1 ! last_index = +infinity stride_vector = 1 if ( present ( stride )) then if ( stride /= 0 ) then if ( stride < 0 ) then first_index = length_string + 1 ! first_index = +infinity last_index = 0 ! last_index = -infinity end if stride_vector = stride end if else if ( present ( first ) . and . present ( last )) then if ( last < first ) then stride_vector = - 1 end if end if end if if ( present ( first )) then first_index = first end if if ( present ( last )) then last_index = last end if if ( stride_vector > 0 ) then first_index = max ( first_index , 1 ) last_index = min ( last_index , length_string ) else first_index = min ( first_index , length_string ) last_index = max ( last_index , 1 ) end if strides_taken = floor ( real ( last_index - first_index ) / real ( stride_vector )) allocate ( character ( len = max ( 0 , strides_taken + 1 )) :: sliced_string ) j = 1 do i = first_index , last_index , stride_vector sliced_string ( j : j ) = string ( i : i ) j = j + 1 end do end function slice_char","tags":"","url":"proc/slice_char.html"},{"title":"slice_string – PIC","text":"private elemental function slice_string(string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) Calls proc~~slice_string~~CallsGraph proc~slice_string slice_string interface~slice slice proc~slice_string->interface~slice interface~slice->proc~slice_string proc~slice_char slice_char interface~slice->proc~slice_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~slice_string~~CalledByGraph proc~slice_string slice_string interface~slice slice proc~slice_string->interface~slice interface~slice->proc~slice_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function slice_string ( string , first , last , stride ) result ( sliced_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride type ( string_type ) :: sliced_string sliced_string = string_type ( slice ( char ( string ), first , last , stride )) end function slice_string","tags":"","url":"proc/slice_string.html"},{"title":"starts_with_char_char – PIC","text":"private pure function starts_with_char_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Called by proc~~starts_with_char_char~~CalledByGraph proc~starts_with_char_char starts_with_char_char interface~starts_with starts_with interface~starts_with->proc~starts_with_char_char proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string->interface~starts_with proc~starts_with_string_char->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: nsub Source Code pure function starts_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: nsub nsub = len ( substring ) if ( len ( string ) < nsub ) then match = . false . return end if match = string ( 1 : nsub ) == substring end function starts_with_char_char","tags":"","url":"proc/starts_with_char_char.html"},{"title":"starts_with_char_string – PIC","text":"private elemental function starts_with_char_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical Calls proc~~starts_with_char_string~~CallsGraph proc~starts_with_char_string starts_with_char_string interface~starts_with starts_with proc~starts_with_char_string->interface~starts_with interface~starts_with->proc~starts_with_char_string proc~starts_with_char_char starts_with_char_char interface~starts_with->proc~starts_with_char_char proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_string_char->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~starts_with_char_string~~CalledByGraph proc~starts_with_char_string starts_with_char_string interface~starts_with starts_with proc~starts_with_char_string->interface~starts_with interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_string_char->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function starts_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( string , char ( substring )) end function starts_with_char_string","tags":"","url":"proc/starts_with_char_string.html"},{"title":"starts_with_string_char – PIC","text":"private elemental function starts_with_string_char(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical Calls proc~~starts_with_string_char~~CallsGraph proc~starts_with_string_char starts_with_string_char interface~starts_with starts_with proc~starts_with_string_char->interface~starts_with interface~starts_with->proc~starts_with_string_char proc~starts_with_char_char starts_with_char_char interface~starts_with->proc~starts_with_char_char proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~starts_with_string_char~~CalledByGraph proc~starts_with_string_char starts_with_string_char interface~starts_with starts_with proc~starts_with_string_char->interface~starts_with interface~starts_with->proc~starts_with_string_char proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function starts_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), substring ) end function starts_with_string_char","tags":"","url":"proc/starts_with_string_char.html"},{"title":"starts_with_string_string – PIC","text":"private elemental function starts_with_string_string(string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical Calls proc~~starts_with_string_string~~CallsGraph proc~starts_with_string_string starts_with_string_string interface~starts_with starts_with proc~starts_with_string_string->interface~starts_with interface~starts_with->proc~starts_with_string_string proc~starts_with_char_char starts_with_char_char interface~starts_with->proc~starts_with_char_char proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_char_string->interface~starts_with proc~starts_with_string_char->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~starts_with_string_string~~CalledByGraph proc~starts_with_string_string starts_with_string_string interface~starts_with starts_with proc~starts_with_string_string->interface~starts_with interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_char_string->interface~starts_with proc~starts_with_string_char->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function starts_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), char ( substring )) end function starts_with_string_string","tags":"","url":"proc/starts_with_string_string.html"},{"title":"strip_char – PIC","text":"private pure function strip_char(string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable Called by proc~~strip_char~~CalledByGraph proc~strip_char strip_char interface~strip strip interface~strip->proc~strip_char proc~strip_string strip_string interface~strip->proc~strip_string proc~strip_string->interface~strip Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: first integer, private :: last Source Code pure function strip_char ( string ) result ( stripped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: stripped_string integer :: first , last first = verify ( string , whitespace ) if ( first == 0 ) then stripped_string = \"\" else last = verify ( string , whitespace , back = . true .) stripped_string = string ( first : last ) end if end function strip_char","tags":"","url":"proc/strip_char.html"},{"title":"strip_string – PIC","text":"private pure function strip_string(string) result(stripped_string) Uses pic_string_type proc~~strip_string~~UsesGraph proc~strip_string strip_string module~pic_string_type pic_string_type proc~strip_string->module~pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) Calls proc~~strip_string~~CallsGraph proc~strip_string strip_string interface~strip strip proc~strip_string->interface~strip interface~strip->proc~strip_string proc~strip_char strip_char interface~strip->proc~strip_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~strip_string~~CalledByGraph proc~strip_string strip_string interface~strip strip proc~strip_string->interface~strip interface~strip->proc~strip_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function strip_string ( string ) result ( stripped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: stripped_string stripped_string = strip ( char ( string )) end function strip_string","tags":"","url":"proc/strip_string.html"},{"title":"to_c_char_from_char – PIC","text":"private pure function to_c_char_from_char(value) result(cstr) Convert a Fortran character string to a C character array Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(kind=c_char, len=1), (len(value)+1) Called by proc~~to_c_char_from_char~~CalledByGraph proc~to_c_char_from_char to_c_char_from_char interface~to_c_char to_c_char interface~to_c_char->proc~to_c_char_from_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lv Source Code pure function to_c_char_from_char ( value ) result ( cstr ) character ( len =* ), intent ( in ) :: value character ( kind = c_char ) :: cstr ( len ( value ) + 1 ) integer :: i , lv lv = len ( value ) do concurrent ( i = 1 : lv ) cstr ( i ) = value ( i : i ) end do cstr ( lv + 1 ) = c_null_char end function to_c_char_from_char","tags":"","url":"proc/to_c_char_from_char.html"},{"title":"to_c_char_from_string – PIC","text":"private pure function to_c_char_from_string(value) result(cstr) Convert a Fortran string type to a C character array Version: experimental Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: value Return Value character(kind=c_char, len=1), (slen(value)+1) Calls proc~~to_c_char_from_string~~CallsGraph proc~to_c_char_from_string to_c_char_from_string interface~slen slen proc~to_c_char_from_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~to_c_char_from_string~~CalledByGraph proc~to_c_char_from_string to_c_char_from_string interface~to_c_char to_c_char interface~to_c_char->proc~to_c_char_from_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: lv Source Code pure function to_c_char_from_string ( value ) result ( cstr ) type ( string_type ), intent ( in ) :: value character ( kind = c_char ) :: cstr ( slen ( value ) + 1 ) integer :: i , lv lv = slen ( value ) do concurrent ( i = 1 : lv ) cstr ( i ) = char ( value , pos = i ) end do cstr ( lv + 1 ) = c_null_char end function to_c_char_from_string","tags":"","url":"proc/to_c_char_from_string.html"},{"title":"zfill_char – PIC","text":"private pure function zfill_char(string, output_length) result(res) Left pad the input string with zeros Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) Calls proc~~zfill_char~~CallsGraph proc~zfill_char zfill_char interface~padl padl proc~zfill_char->interface~padl proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~zfill_char~~CalledByGraph proc~zfill_char zfill_char interface~zfill zfill interface~zfill->proc~zfill_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function zfill_char ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = padl ( string , output_length , \"0\" ) end function zfill_char","tags":"","url":"proc/zfill_char.html"},{"title":"zfill_string – PIC","text":"private pure function zfill_string(string, output_length) result(res) Left pad the input string with zeros Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) Calls proc~~zfill_string~~CallsGraph proc~zfill_string zfill_string interface~padl padl proc~zfill_string->interface~padl proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~zfill_string~~CalledByGraph proc~zfill_string zfill_string interface~zfill zfill interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function zfill_string ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , \"0\" )) end function zfill_string","tags":"","url":"proc/zfill_string.html"},{"title":"chomp – PIC","text":"public interface chomp Remove trailing characters in set from string.\nIf no character set is provided trailing whitespace is removed. Version: experimental Calls interface~~chomp~~CallsGraph interface~chomp chomp proc~chomp_char chomp_char interface~chomp->proc~chomp_char proc~chomp_set_char_char chomp_set_char_char interface~chomp->proc~chomp_set_char_char proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_string chomp_string interface~chomp->proc~chomp_string proc~chomp_substring_char_char chomp_substring_char_char interface~chomp->proc~chomp_substring_char_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~set_to_string set_to_string proc~chomp_set_char_char->proc~set_to_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~chomp~~CalledByGraph interface~chomp chomp proc~chomp_set_string_char chomp_set_string_char interface~chomp->proc~chomp_set_string_char proc~chomp_substring_char_string chomp_substring_char_string interface~chomp->proc~chomp_substring_char_string proc~chomp_substring_string_char chomp_substring_string_char interface~chomp->proc~chomp_substring_string_char proc~chomp_substring_string_string chomp_substring_string_string interface~chomp->proc~chomp_substring_string_string proc~chomp_set_string_char->interface~chomp proc~chomp_substring_char_string->interface~chomp proc~chomp_substring_string_char->interface~chomp proc~chomp_substring_string_string->interface~chomp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function chomp_string (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function chomp_char (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable private pure function chomp_set_string_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) private pure function chomp_set_char_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:), allocatable private pure function chomp_substring_string_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:), allocatable private pure function chomp_substring_string_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:), allocatable","tags":"","url":"interface/chomp.html"},{"title":"count – PIC","text":"public interface count Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’ Calls interface~~count~~CallsGraph interface~count count proc~count_char_char count_char_char interface~count->proc~count_char_char proc~count_char_string count_char_string interface~count->proc~count_char_string proc~count_string_char count_string_char interface~count->proc~count_string_char proc~count_string_string count_string_string interface~count->proc~count_string_string interface~pic_optional pic_optional proc~count_char_char->interface~pic_optional proc~compute_lps compute_lps proc~count_char_char->proc~compute_lps proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function count_string_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer","tags":"","url":"interface/count.html"},{"title":"ends_with – PIC","text":"public interface ends_with Check whether a string ends with substring or not Version: experimental Calls interface~~ends_with~~CallsGraph interface~ends_with ends_with proc~ends_with_char_char ends_with_char_char interface~ends_with->proc~ends_with_char_char proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string->interface~ends_with proc~ends_with_string_char->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~ends_with~~CalledByGraph interface~ends_with ends_with proc~ends_with_char_string ends_with_char_string interface~ends_with->proc~ends_with_char_string proc~ends_with_string_char ends_with_string_char interface~ends_with->proc~ends_with_string_char proc~ends_with_string_string ends_with_string_string interface~ends_with->proc~ends_with_string_string proc~ends_with_char_string->interface~ends_with proc~ends_with_string_char->interface~ends_with proc~ends_with_string_string->interface~ends_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function ends_with_string_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function ends_with_string_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_char_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function ends_with_char_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical","tags":"","url":"interface/ends_with.html"},{"title":"find – PIC","text":"public interface find Finds the starting index of substring ‘pattern’ in the input ‘string’ Specifications Version: experimental Calls interface~~find~~CallsGraph interface~find find proc~find_char_char find_char_char interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~pic_optional pic_optional proc~find_char_char->interface~pic_optional proc~compute_lps compute_lps proc~find_char_char->proc~compute_lps proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~find~~CalledByGraph interface~find find proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function find_string_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer","tags":"","url":"interface/find.html"},{"title":"join – PIC","text":"public interface join Joins an array of strings into a single string.\nThe chunks are separated with a space, or an optional user-defined separator. Calls interface~~join~~CallsGraph interface~join join proc~join_char join_char interface~join->proc~join_char proc~join_string join_string interface~join->proc~join_string interface~move move proc~join_string->interface~move proc~move_char_char move_char_char interface~move->proc~move_char_char proc~move_char_string move_char_string interface~move->proc~move_char_string proc~move_string_char move_string_char interface~move->proc~move_string_char proc~move_string_string move_string_string interface~move->proc~move_string_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function join_string (strings, separator) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value type( string_type ) private pure function join_char (strings, separator) result(joined) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable","tags":"","url":"interface/join.html"},{"title":"padl – PIC","text":"public interface padl Left pad the input string Calls interface~~padl~~CallsGraph interface~padl padl proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~padl~~CalledByGraph interface~padl padl proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl proc~zfill_char zfill_char proc~zfill_char->interface~padl proc~zfill_string zfill_string proc~zfill_string->interface~padl interface~zfill zfill interface~zfill->proc~zfill_char interface~zfill->proc~zfill_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function padl_string_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padl_string_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padl_char_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padl_char_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max)","tags":"","url":"interface/padl.html"},{"title":"padr – PIC","text":"public interface padr Right pad the input string Calls interface~~padr~~CallsGraph interface~padr padr proc~padr_char_default padr_char_default interface~padr->proc~padr_char_default proc~padr_char_pad_with padr_char_pad_with interface~padr->proc~padr_char_pad_with proc~padr_string_default padr_string_default interface~padr->proc~padr_string_default proc~padr_string_pad_with padr_string_pad_with interface~padr->proc~padr_string_pad_with proc~padr_string_pad_with->interface~padr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~padr~~CalledByGraph interface~padr padr proc~padr_string_pad_with padr_string_pad_with interface~padr->proc~padr_string_pad_with proc~padr_string_pad_with->interface~padr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function padr_string_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padr_string_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padr_char_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padr_char_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max)","tags":"","url":"interface/padr.html"},{"title":"replace_all – PIC","text":"public interface replace_all Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nVersion: experimental Calls interface~~replace_all~~CallsGraph interface~replace_all replace_all proc~replace_all_char_char_char replace_all_char_char_char interface~replace_all->proc~replace_all_char_char_char proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~compute_lps compute_lps proc~replace_all_char_char_char->proc~compute_lps proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~replace_all~~CalledByGraph interface~replace_all replace_all proc~replace_all_char_char_string replace_all_char_char_string interface~replace_all->proc~replace_all_char_char_string proc~replace_all_char_string_char replace_all_char_string_char interface~replace_all->proc~replace_all_char_string_char proc~replace_all_char_string_string replace_all_char_string_string interface~replace_all->proc~replace_all_char_string_string proc~replace_all_string_char_char replace_all_string_char_char interface~replace_all->proc~replace_all_string_char_char proc~replace_all_string_char_string replace_all_string_char_string interface~replace_all->proc~replace_all_string_char_string proc~replace_all_string_string_char replace_all_string_string_char interface~replace_all->proc~replace_all_string_string_char proc~replace_all_string_string_string replace_all_string_string_string interface~replace_all->proc~replace_all_string_string_string proc~replace_all_char_char_string->interface~replace_all proc~replace_all_char_string_char->interface~replace_all proc~replace_all_char_string_string->interface~replace_all proc~replace_all_string_char_char->interface~replace_all proc~replace_all_string_char_string->interface~replace_all proc~replace_all_string_string_char->interface~replace_all proc~replace_all_string_string_string->interface~replace_all Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function replace_all_string_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_string_char_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_char_char (string, pattern, replacement) result(res) Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable","tags":"","url":"interface/replace_all.html"},{"title":"slice – PIC","text":"public interface slice Extracts characters from the input string to return a new string Version: experimental Calls interface~~slice~~CallsGraph interface~slice slice proc~slice_char slice_char interface~slice->proc~slice_char proc~slice_string slice_string interface~slice->proc~slice_string proc~slice_string->interface~slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~slice~~CalledByGraph interface~slice slice proc~slice_string slice_string interface~slice->proc~slice_string proc~slice_string->interface~slice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function slice_string (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) private pure function slice_char (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:), allocatable","tags":"","url":"interface/slice.html"},{"title":"starts_with – PIC","text":"public interface starts_with Check whether a string starts with substring or not Version: experimental Calls interface~~starts_with~~CallsGraph interface~starts_with starts_with proc~starts_with_char_char starts_with_char_char interface~starts_with->proc~starts_with_char_char proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string->interface~starts_with proc~starts_with_string_char->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~starts_with~~CalledByGraph interface~starts_with starts_with proc~starts_with_char_string starts_with_char_string interface~starts_with->proc~starts_with_char_string proc~starts_with_string_char starts_with_string_char interface~starts_with->proc~starts_with_string_char proc~starts_with_string_string starts_with_string_string interface~starts_with->proc~starts_with_string_string proc~starts_with_char_string->interface~starts_with proc~starts_with_string_char->interface~starts_with proc~starts_with_string_string->interface~starts_with Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function starts_with_string_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function starts_with_string_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_char_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function starts_with_char_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical","tags":"","url":"interface/starts_with.html"},{"title":"strip – PIC","text":"public interface strip Remove leading and trailing whitespace characters. Version: experimental Calls interface~~strip~~CallsGraph interface~strip strip proc~strip_char strip_char interface~strip->proc~strip_char proc~strip_string strip_string interface~strip->proc~strip_string proc~strip_string->interface~strip Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~strip~~CalledByGraph interface~strip strip proc~strip_string strip_string interface~strip->proc~strip_string proc~strip_string->interface~strip Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function strip_string (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function strip_char (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable","tags":"","url":"interface/strip.html"},{"title":"to_c_char – PIC","text":"public interface to_c_char Format or transfer other types as a string. Calls interface~~to_c_char~~CallsGraph interface~to_c_char to_c_char proc~to_c_char_from_char to_c_char_from_char interface~to_c_char->proc~to_c_char_from_char proc~to_c_char_from_string to_c_char_from_string interface~to_c_char->proc~to_c_char_from_string interface~slen slen proc~to_c_char_from_string->interface~slen proc~len_string len_string interface~slen->proc~len_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function to_c_char_from_char (value) result(cstr) Convert a Fortran character string to a C character array Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(kind=c_char, len=1), (len(value)+1) private pure function to_c_char_from_string (value) result(cstr) Convert a Fortran string type to a C character array Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: value Return Value character(kind=c_char, len=1), (slen(value)+1)","tags":"","url":"interface/to_c_char.html"},{"title":"to_string – PIC","text":"public interface to_string Format or transfer other types as a string. Called by interface~~to_string~~CalledByGraph interface~to_string to_string proc~new_string_from_integer_int32 new_string_from_integer_int32 proc~new_string_from_integer_int32->interface~to_string proc~new_string_from_integer_int64 new_string_from_integer_int64 proc~new_string_from_integer_int64->interface~to_string proc~new_string_from_logical_fbool new_string_from_logical_fbool proc~new_string_from_logical_fbool->interface~to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure module function to_string_1_i_int32(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value Return Value character(len=:), allocatable private pure module function to_string_1_i_int64(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value Return Value character(len=:), allocatable private pure module function to_string_1_l_fbool(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value Return Value character(len=1) private pure module function to_string_2_i_int32(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_2_i_int64(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_2_l_fbool(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_r_dp(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable private pure module function to_string_r_sp(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable","tags":"","url":"interface/to_string.html"},{"title":"zfill – PIC","text":"public interface zfill Left pad the input string with zeros. Calls interface~~zfill~~CallsGraph interface~zfill zfill proc~zfill_char zfill_char interface~zfill->proc~zfill_char proc~zfill_string zfill_string interface~zfill->proc~zfill_string interface~padl padl proc~zfill_char->interface~padl proc~zfill_string->interface~padl proc~padl_char_default padl_char_default interface~padl->proc~padl_char_default proc~padl_char_pad_with padl_char_pad_with interface~padl->proc~padl_char_pad_with proc~padl_string_default padl_string_default interface~padl->proc~padl_string_default proc~padl_string_pad_with padl_string_pad_with interface~padl->proc~padl_string_pad_with proc~padl_char_default->interface~padl proc~padl_string_default->interface~padl proc~padl_string_pad_with->interface~padl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function zfill_string (string, output_length) result(res) Left pad the input string with zeros Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function zfill_char (string, output_length) result(res) Left pad the input string with zeros Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max)","tags":"","url":"interface/zfill.html"},{"title":"char_decrease_ord_sort – PIC","text":"private  subroutine char_decrease_ord_sort(array, work) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) Calls proc~~char_decrease_ord_sort~~CallsGraph proc~char_decrease_ord_sort char_decrease_ord_sort none~merge_sort~10 merge_sort proc~char_decrease_ord_sort->none~merge_sort~10 none~calc_min_run~10 calc_min_run none~merge_sort~10->none~calc_min_run~10 none~collapse~10 collapse none~merge_sort~10->none~collapse~10 none~insert_head~10 insert_head none~merge_sort~10->none~insert_head~10 none~insertion_sort~20 insertion_sort none~merge_sort~10->none~insertion_sort~20 none~reverse_segment~10 reverse_segment none~merge_sort~10->none~reverse_segment~10 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~char_decrease_ord_sort~~CalledByGraph proc~char_decrease_ord_sort char_decrease_ord_sort proc~char_ord_sort char_ord_sort proc~char_ord_sort->proc~char_decrease_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid character(len=len), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) Source Code subroutine char_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"char_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else block character ( len = :), allocatable :: buf (:) ! Allocate a buffer to use as scratch memory. allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"char_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end block end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_decrease_ord_sort","tags":"","url":"proc/char_decrease_ord_sort.html"},{"title":"char_increase_ord_sort – PIC","text":"private  subroutine char_increase_ord_sort(array, work) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) Calls proc~~char_increase_ord_sort~~CallsGraph proc~char_increase_ord_sort char_increase_ord_sort none~merge_sort~5 merge_sort proc~char_increase_ord_sort->none~merge_sort~5 none~calc_min_run~5 calc_min_run none~merge_sort~5->none~calc_min_run~5 none~collapse~5 collapse none~merge_sort~5->none~collapse~5 none~insert_head~5 insert_head none~merge_sort~5->none~insert_head~5 none~insertion_sort~15 insertion_sort none~merge_sort~5->none~insertion_sort~15 none~reverse_segment~5 reverse_segment none~merge_sort~5->none~reverse_segment~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~char_increase_ord_sort~~CalledByGraph proc~char_increase_ord_sort char_increase_ord_sort proc~char_ord_sort char_ord_sort proc~char_ord_sort->proc~char_increase_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid character(len=len), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) Source Code subroutine char_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"char_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else block character ( len = :), allocatable :: buf (:) ! Allocate a buffer to use as scratch memory. allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"char_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end block end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_increase_ord_sort","tags":"","url":"proc/char_increase_ord_sort.html"},{"title":"char_ord_sort – PIC","text":"private module subroutine char_ord_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Calls proc~~char_ord_sort~~CallsGraph proc~char_ord_sort char_ord_sort interface~pic_optional pic_optional proc~char_ord_sort->interface~pic_optional proc~char_decrease_ord_sort char_decrease_ord_sort proc~char_ord_sort->proc~char_decrease_ord_sort proc~char_increase_ord_sort char_increase_ord_sort proc~char_ord_sort->proc~char_increase_ord_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~10 merge_sort proc~char_decrease_ord_sort->none~merge_sort~10 none~merge_sort~5 merge_sort proc~char_increase_ord_sort->none~merge_sort~5 none~calc_min_run~10 calc_min_run none~merge_sort~10->none~calc_min_run~10 none~collapse~10 collapse none~merge_sort~10->none~collapse~10 none~insert_head~10 insert_head none~merge_sort~10->none~insert_head~10 none~insertion_sort~20 insertion_sort none~merge_sort~10->none~insertion_sort~20 none~reverse_segment~10 reverse_segment none~merge_sort~10->none~reverse_segment~10 none~calc_min_run~5 calc_min_run none~merge_sort~5->none~calc_min_run~5 none~collapse~5 collapse none~merge_sort~5->none~collapse~5 none~insert_head~5 insert_head none~merge_sort~5->none~insert_head~5 none~insertion_sort~15 insertion_sort none~merge_sort~5->none~insertion_sort~15 none~reverse_segment~5 reverse_segment none~merge_sort~5->none~reverse_segment~5 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module subroutine char_ord_sort ( array , work , reverse ) implicit none !! `char_ord_sort( array )` sorts the input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_ord_sort","tags":"","url":"proc/char_ord_sort.html"},{"title":"dp_decrease_ord_sort – PIC","text":"private  subroutine dp_decrease_ord_sort(array, work) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) Calls proc~~dp_decrease_ord_sort~~CallsGraph proc~dp_decrease_ord_sort dp_decrease_ord_sort none~merge_sort~9 merge_sort proc~dp_decrease_ord_sort->none~merge_sort~9 none~calc_min_run~9 calc_min_run none~merge_sort~9->none~calc_min_run~9 none~collapse~9 collapse none~merge_sort~9->none~collapse~9 none~insert_head~9 insert_head none~merge_sort~9->none~insert_head~9 none~insertion_sort~19 insertion_sort none~merge_sort~9->none~insertion_sort~19 none~reverse_segment~9 reverse_segment none~merge_sort~9->none~reverse_segment~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dp_decrease_ord_sort~~CalledByGraph proc~dp_decrease_ord_sort dp_decrease_ord_sort proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->proc~dp_decrease_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=dp), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=dp), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) Source Code subroutine dp_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) real ( dp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"dp_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"dp_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_decrease_ord_sort","tags":"","url":"proc/dp_decrease_ord_sort.html"},{"title":"dp_increase_ord_sort – PIC","text":"private  subroutine dp_increase_ord_sort(array, work) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) Calls proc~~dp_increase_ord_sort~~CallsGraph proc~dp_increase_ord_sort dp_increase_ord_sort none~merge_sort~4 merge_sort proc~dp_increase_ord_sort->none~merge_sort~4 none~calc_min_run~4 calc_min_run none~merge_sort~4->none~calc_min_run~4 none~collapse~4 collapse none~merge_sort~4->none~collapse~4 none~insert_head~4 insert_head none~merge_sort~4->none~insert_head~4 none~insertion_sort~14 insertion_sort none~merge_sort~4->none~insertion_sort~14 none~reverse_segment~4 reverse_segment none~merge_sort~4->none~reverse_segment~4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dp_increase_ord_sort~~CalledByGraph proc~dp_increase_ord_sort dp_increase_ord_sort proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->proc~dp_increase_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=dp), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=dp), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) Source Code subroutine dp_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) real ( dp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"dp_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"dp_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_increase_ord_sort","tags":"","url":"proc/dp_increase_ord_sort.html"},{"title":"dp_ord_sort – PIC","text":"private module subroutine dp_ord_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Calls proc~~dp_ord_sort~~CallsGraph proc~dp_ord_sort dp_ord_sort interface~pic_optional pic_optional proc~dp_ord_sort->interface~pic_optional proc~dp_decrease_ord_sort dp_decrease_ord_sort proc~dp_ord_sort->proc~dp_decrease_ord_sort proc~dp_increase_ord_sort dp_increase_ord_sort proc~dp_ord_sort->proc~dp_increase_ord_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~9 merge_sort proc~dp_decrease_ord_sort->none~merge_sort~9 none~merge_sort~4 merge_sort proc~dp_increase_ord_sort->none~merge_sort~4 none~calc_min_run~4 calc_min_run none~merge_sort~4->none~calc_min_run~4 none~collapse~4 collapse none~merge_sort~4->none~collapse~4 none~insert_head~4 insert_head none~merge_sort~4->none~insert_head~4 none~insertion_sort~14 insertion_sort none~merge_sort~4->none~insertion_sort~14 none~reverse_segment~4 reverse_segment none~merge_sort~4->none~reverse_segment~4 none~calc_min_run~9 calc_min_run none~merge_sort~9->none~calc_min_run~9 none~collapse~9 collapse none~merge_sort~9->none~collapse~9 none~insert_head~9 insert_head none~merge_sort~9->none~insert_head~9 none~insertion_sort~19 insertion_sort none~merge_sort~9->none~insertion_sort~19 none~reverse_segment~9 reverse_segment none~merge_sort~9->none~reverse_segment~9 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module subroutine dp_ord_sort ( array , work , reverse ) implicit none !! `dp_ord_sort( array )` sorts the input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_ord_sort","tags":"","url":"proc/dp_ord_sort.html"},{"title":"int32_decrease_ord_sort – PIC","text":"private  subroutine int32_decrease_ord_sort(array, work) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) Calls proc~~int32_decrease_ord_sort~~CallsGraph proc~int32_decrease_ord_sort int32_decrease_ord_sort none~merge_sort~6 merge_sort proc~int32_decrease_ord_sort->none~merge_sort~6 none~calc_min_run~6 calc_min_run none~merge_sort~6->none~calc_min_run~6 none~collapse~6 collapse none~merge_sort~6->none~collapse~6 none~insert_head~6 insert_head none~merge_sort~6->none~insert_head~6 none~insertion_sort~16 insertion_sort none~merge_sort~6->none~insertion_sort~16 none~reverse_segment~6 reverse_segment none~merge_sort~6->none~reverse_segment~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int32_decrease_ord_sort~~CalledByGraph proc~int32_decrease_ord_sort int32_decrease_ord_sort proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->proc~int32_decrease_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int32), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int32), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) Source Code subroutine int32_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int32 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int32_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int32_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_decrease_ord_sort","tags":"","url":"proc/int32_decrease_ord_sort.html"},{"title":"int32_increase_ord_sort – PIC","text":"private  subroutine int32_increase_ord_sort(array, work) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) Calls proc~~int32_increase_ord_sort~~CallsGraph proc~int32_increase_ord_sort int32_increase_ord_sort none~merge_sort merge_sort proc~int32_increase_ord_sort->none~merge_sort none~calc_min_run calc_min_run none~merge_sort->none~calc_min_run none~collapse collapse none~merge_sort->none~collapse none~insert_head insert_head none~merge_sort->none~insert_head none~insertion_sort~11 insertion_sort none~merge_sort->none~insertion_sort~11 none~reverse_segment reverse_segment none~merge_sort->none~reverse_segment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int32_increase_ord_sort~~CalledByGraph proc~int32_increase_ord_sort int32_increase_ord_sort proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->proc~int32_increase_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int32), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int32), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) Source Code subroutine int32_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int32 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int32_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int32_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_increase_ord_sort","tags":"","url":"proc/int32_increase_ord_sort.html"},{"title":"int32_ord_sort – PIC","text":"private module subroutine int32_ord_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Calls proc~~int32_ord_sort~~CallsGraph proc~int32_ord_sort int32_ord_sort interface~pic_optional pic_optional proc~int32_ord_sort->interface~pic_optional proc~int32_decrease_ord_sort int32_decrease_ord_sort proc~int32_ord_sort->proc~int32_decrease_ord_sort proc~int32_increase_ord_sort int32_increase_ord_sort proc~int32_ord_sort->proc~int32_increase_ord_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~6 merge_sort proc~int32_decrease_ord_sort->none~merge_sort~6 none~merge_sort merge_sort proc~int32_increase_ord_sort->none~merge_sort none~calc_min_run calc_min_run none~merge_sort->none~calc_min_run none~collapse collapse none~merge_sort->none~collapse none~insert_head insert_head none~merge_sort->none~insert_head none~insertion_sort~11 insertion_sort none~merge_sort->none~insertion_sort~11 none~reverse_segment reverse_segment none~merge_sort->none~reverse_segment none~calc_min_run~6 calc_min_run none~merge_sort~6->none~calc_min_run~6 none~collapse~6 collapse none~merge_sort~6->none~collapse~6 none~insert_head~6 insert_head none~merge_sort~6->none~insert_head~6 none~insertion_sort~16 insertion_sort none~merge_sort~6->none~insertion_sort~16 none~reverse_segment~6 reverse_segment none~merge_sort~6->none~reverse_segment~6 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module subroutine int32_ord_sort ( array , work , reverse ) implicit none !! `int32_ord_sort( array )` sorts the input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_ord_sort","tags":"","url":"proc/int32_ord_sort.html"},{"title":"int64_decrease_ord_sort – PIC","text":"private  subroutine int64_decrease_ord_sort(array, work) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) Calls proc~~int64_decrease_ord_sort~~CallsGraph proc~int64_decrease_ord_sort int64_decrease_ord_sort none~merge_sort~7 merge_sort proc~int64_decrease_ord_sort->none~merge_sort~7 none~calc_min_run~7 calc_min_run none~merge_sort~7->none~calc_min_run~7 none~collapse~7 collapse none~merge_sort~7->none~collapse~7 none~insert_head~7 insert_head none~merge_sort~7->none~insert_head~7 none~insertion_sort~17 insertion_sort none~merge_sort~7->none~insertion_sort~17 none~reverse_segment~7 reverse_segment none~merge_sort~7->none~reverse_segment~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int64_decrease_ord_sort~~CalledByGraph proc~int64_decrease_ord_sort int64_decrease_ord_sort proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->proc~int64_decrease_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int64), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int64), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) Source Code subroutine int64_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int64 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int64_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int64_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_decrease_ord_sort","tags":"","url":"proc/int64_decrease_ord_sort.html"},{"title":"int64_increase_ord_sort – PIC","text":"private  subroutine int64_increase_ord_sort(array, work) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) Calls proc~~int64_increase_ord_sort~~CallsGraph proc~int64_increase_ord_sort int64_increase_ord_sort none~merge_sort~2 merge_sort proc~int64_increase_ord_sort->none~merge_sort~2 none~calc_min_run~2 calc_min_run none~merge_sort~2->none~calc_min_run~2 none~collapse~2 collapse none~merge_sort~2->none~collapse~2 none~insert_head~2 insert_head none~merge_sort~2->none~insert_head~2 none~insertion_sort~12 insertion_sort none~merge_sort~2->none~insertion_sort~12 none~reverse_segment~2 reverse_segment none~merge_sort~2->none~reverse_segment~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~int64_increase_ord_sort~~CalledByGraph proc~int64_increase_ord_sort int64_increase_ord_sort proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->proc~int64_increase_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int64), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int64), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) Source Code subroutine int64_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int64 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int64_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int64_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_increase_ord_sort","tags":"","url":"proc/int64_increase_ord_sort.html"},{"title":"int64_ord_sort – PIC","text":"private module subroutine int64_ord_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Calls proc~~int64_ord_sort~~CallsGraph proc~int64_ord_sort int64_ord_sort interface~pic_optional pic_optional proc~int64_ord_sort->interface~pic_optional proc~int64_decrease_ord_sort int64_decrease_ord_sort proc~int64_ord_sort->proc~int64_decrease_ord_sort proc~int64_increase_ord_sort int64_increase_ord_sort proc~int64_ord_sort->proc~int64_increase_ord_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~7 merge_sort proc~int64_decrease_ord_sort->none~merge_sort~7 none~merge_sort~2 merge_sort proc~int64_increase_ord_sort->none~merge_sort~2 none~calc_min_run~2 calc_min_run none~merge_sort~2->none~calc_min_run~2 none~collapse~2 collapse none~merge_sort~2->none~collapse~2 none~insert_head~2 insert_head none~merge_sort~2->none~insert_head~2 none~insertion_sort~12 insertion_sort none~merge_sort~2->none~insertion_sort~12 none~reverse_segment~2 reverse_segment none~merge_sort~2->none~reverse_segment~2 none~calc_min_run~7 calc_min_run none~merge_sort~7->none~calc_min_run~7 none~collapse~7 collapse none~merge_sort~7->none~collapse~7 none~insert_head~7 insert_head none~merge_sort~7->none~insert_head~7 none~insertion_sort~17 insertion_sort none~merge_sort~7->none~insertion_sort~17 none~reverse_segment~7 reverse_segment none~merge_sort~7->none~reverse_segment~7 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module subroutine int64_ord_sort ( array , work , reverse ) implicit none !! `int64_ord_sort( array )` sorts the input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_ord_sort","tags":"","url":"proc/int64_ord_sort.html"},{"title":"sp_decrease_ord_sort – PIC","text":"private  subroutine sp_decrease_ord_sort(array, work) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) Calls proc~~sp_decrease_ord_sort~~CallsGraph proc~sp_decrease_ord_sort sp_decrease_ord_sort none~merge_sort~8 merge_sort proc~sp_decrease_ord_sort->none~merge_sort~8 none~calc_min_run~8 calc_min_run none~merge_sort~8->none~calc_min_run~8 none~collapse~8 collapse none~merge_sort~8->none~collapse~8 none~insert_head~8 insert_head none~merge_sort~8->none~insert_head~8 none~insertion_sort~18 insertion_sort none~merge_sort~8->none~insertion_sort~18 none~reverse_segment~8 reverse_segment none~merge_sort~8->none~reverse_segment~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sp_decrease_ord_sort~~CalledByGraph proc~sp_decrease_ord_sort sp_decrease_ord_sort proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->proc~sp_decrease_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=sp), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=sp), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) Source Code subroutine sp_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) real ( sp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"sp_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"sp_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_decrease_ord_sort","tags":"","url":"proc/sp_decrease_ord_sort.html"},{"title":"sp_increase_ord_sort – PIC","text":"private  subroutine sp_increase_ord_sort(array, work) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) Calls proc~~sp_increase_ord_sort~~CallsGraph proc~sp_increase_ord_sort sp_increase_ord_sort none~merge_sort~3 merge_sort proc~sp_increase_ord_sort->none~merge_sort~3 none~calc_min_run~3 calc_min_run none~merge_sort~3->none~calc_min_run~3 none~collapse~3 collapse none~merge_sort~3->none~collapse~3 none~insert_head~3 insert_head none~merge_sort~3->none~insert_head~3 none~insertion_sort~13 insertion_sort none~merge_sort~3->none~insertion_sort~13 none~reverse_segment~3 reverse_segment none~merge_sort~3->none~reverse_segment~3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sp_increase_ord_sort~~CalledByGraph proc~sp_increase_ord_sort sp_increase_ord_sort proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->proc~sp_increase_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=sp), private, allocatable :: buf (:) integer, private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine insertion_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) pure subroutine merge (array, mid, buf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=sp), intent(inout) :: buf (0:) subroutine merge_sort (array, buf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(inout) :: buf (0:) pure subroutine reverse_segment (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) Source Code subroutine sp_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) real ( sp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"sp_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"sp_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_increase_ord_sort","tags":"","url":"proc/sp_increase_ord_sort.html"},{"title":"sp_ord_sort – PIC","text":"private module subroutine sp_ord_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Calls proc~~sp_ord_sort~~CallsGraph proc~sp_ord_sort sp_ord_sort interface~pic_optional pic_optional proc~sp_ord_sort->interface~pic_optional proc~sp_decrease_ord_sort sp_decrease_ord_sort proc~sp_ord_sort->proc~sp_decrease_ord_sort proc~sp_increase_ord_sort sp_increase_ord_sort proc~sp_ord_sort->proc~sp_increase_ord_sort proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~8 merge_sort proc~sp_decrease_ord_sort->none~merge_sort~8 none~merge_sort~3 merge_sort proc~sp_increase_ord_sort->none~merge_sort~3 none~calc_min_run~3 calc_min_run none~merge_sort~3->none~calc_min_run~3 none~collapse~3 collapse none~merge_sort~3->none~collapse~3 none~insert_head~3 insert_head none~merge_sort~3->none~insert_head~3 none~insertion_sort~13 insertion_sort none~merge_sort~3->none~insertion_sort~13 none~reverse_segment~3 reverse_segment none~merge_sort~3->none~reverse_segment~3 none~calc_min_run~8 calc_min_run none~merge_sort~8->none~calc_min_run~8 none~collapse~8 collapse none~merge_sort~8->none~collapse~8 none~insert_head~8 insert_head none~merge_sort~8->none~insert_head~8 none~insertion_sort~18 insertion_sort none~merge_sort~8->none~insertion_sort~18 none~reverse_segment~8 reverse_segment none~merge_sort~8->none~reverse_segment~8 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module subroutine sp_ord_sort ( array , work , reverse ) implicit none !! `sp_ord_sort( array )` sorts the input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_ord_sort","tags":"","url":"proc/sp_ord_sort.html"},{"title":"ord_sort – PIC","text":"public interface ord_sort The generic subroutine interface implementing the ORD_SORT algorithm,\na translation to Fortran 2008, of the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\nand insertion sort . It is always at worst O(N Ln(N)) in sorting random\ndata, having a performance about 25% slower than SORT on such\ndata, but has much better performance than SORT on partially\nsorted data, having O(N) performance on uniformly non-increasing or\nnon-decreasing data. Subroutines private module subroutine char_ord_sort(array, work, reverse) Implementation → char_ord_sort( array ) sorts the input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine dp_ord_sort(array, work, reverse) Implementation → dp_ord_sort( array ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine int32_ord_sort(array, work, reverse) Implementation → int32_ord_sort( array ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine int64_ord_sort(array, work, reverse) Implementation → int64_ord_sort( array ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine sp_ord_sort(array, work, reverse) Implementation → sp_ord_sort( array ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse","tags":"","url":"interface/ord_sort.html"},{"title":"get_first_arg_from_command_line – PIC","text":"public  function get_first_arg_from_command_line() result(filename) get the first argument from the command line, this is expected to be a filename Usage: filename = get_first_arg_from_command_line() Arguments None Return Value character(len=255) Variables Type Visibility Attributes Name Initial character(len=255), private :: arg integer(kind=default_int), private :: num_args Source Code function get_first_arg_from_command_line () result ( filename ) !! get the first argument from the command line, this is expected to be a filename !! !! Usage: filename = get_first_arg_from_command_line() !! character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line","tags":"","url":"proc/get_first_arg_from_command_line.html"},{"title":"to_string_device – PIC","text":"private  function to_string_device(self) result(str) cute printing routine for the pic device type, transforms the contents into a\nstring of chars Arguments Type Intent Optional Attributes Name class( device_type ), intent(in) :: self Return Value character(len=:), allocatable Called by proc~~to_string_device~~CalledByGraph proc~to_string_device to_string_device interface~to_string~2 to_string interface~to_string~2->proc~to_string_device Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=100), private :: temp_str integer(kind=int32), private :: total_len Source Code function to_string_device ( self ) result ( str ) !! cute printing routine for the pic device type, transforms the contents into a !! string of chars class ( device_type ), intent ( in ) :: self character ( len = :), allocatable :: str character ( len = 100 ) :: temp_str integer ( int32 ) :: total_len total_len = len ( \"Device ID:   \" ) + 6 + & len ( \"Free memory: \" ) + 20 + & len ( \"Total memory:\" ) + 20 + & len ( \"Used memory: \" ) + 20 + 3 * len ( new_line ( 'a' )) allocate ( character ( len = total_len ) :: str ) write ( temp_str , '(I0)' ) self % device_id str = \"Device ID:   \" // trim ( temp_str ) // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % free_mb str = str // \"Free memory: \" // trim ( adjustl ( temp_str )) // \" MB\" // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % total_mb str = str // \"Total memory: \" // trim ( adjustl ( temp_str )) // \" MB\" // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % used_mb str = str // \"Used memory:  \" // trim ( adjustl ( temp_str )) // \" MB\" end function to_string_device","tags":"","url":"proc/to_string_device.html"},{"title":"get_device_id – PIC","text":"public  subroutine get_device_id(mem) routine to get the device id for the device_type Arguments Type Intent Optional Attributes Name type( device_type ), intent(inout) :: mem Calls proc~~get_device_id~~CallsGraph proc~get_device_id get_device_id proc~gpugetdevice gpugetdevice proc~get_device_id->proc~gpugetdevice Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_device_id~~CalledByGraph proc~get_device_id get_device_id proc~get_gpu_information device_type%get_gpu_information proc~get_gpu_information->proc~get_device_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_int), private :: device_id integer(kind=c_int), private :: ierr Source Code subroutine get_device_id ( mem ) !! routine to get the device id for the device_type type ( device_type ), intent ( inout ) :: mem integer ( c_int ) :: ierr , device_id call gpugetdevice ( device_id , ierr ) if ( ierr == 0_c_int ) then mem % device_id = device_id else mem % device_id = - 1_c_int end if end subroutine get_device_id","tags":"","url":"proc/get_device_id.html"},{"title":"get_gpu_information – PIC","text":"public  subroutine get_gpu_information(self) call my_device%get_gpu_informatio() style subroutine to populate the object Type Bound device_type Arguments Type Intent Optional Attributes Name class( device_type ), intent(inout) :: self Calls proc~~get_gpu_information~~CallsGraph proc~get_gpu_information device_type%get_gpu_information proc~get_device_id get_device_id proc~get_gpu_information->proc~get_device_id proc~get_gpu_memory_info get_gpu_memory_info proc~get_gpu_information->proc~get_gpu_memory_info proc~gpugetdevice gpugetdevice proc~get_device_id->proc~gpugetdevice proc~gpugetmeminfo gpugetmeminfo proc~get_gpu_memory_info->proc~gpugetmeminfo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine get_gpu_information ( self ) !! call my_device%get_gpu_informatio() style subroutine to populate the object class ( device_type ), intent ( inout ) :: self call get_gpu_memory_info ( self ) call get_device_id ( self ) end subroutine get_gpu_information","tags":"","url":"proc/get_gpu_information.html"},{"title":"get_gpu_memory_info – PIC","text":"public  subroutine get_gpu_memory_info(mem) routine to get the free and total memory for the device_type object\ncan be used independently with call get_gpu_memory_info(device_object) Arguments Type Intent Optional Attributes Name type( device_type ), intent(inout) :: mem Calls proc~~get_gpu_memory_info~~CallsGraph proc~get_gpu_memory_info get_gpu_memory_info proc~gpugetmeminfo gpugetmeminfo proc~get_gpu_memory_info->proc~gpugetmeminfo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~get_gpu_memory_info~~CalledByGraph proc~get_gpu_memory_info get_gpu_memory_info proc~get_gpu_information device_type%get_gpu_information proc~get_gpu_information->proc~get_gpu_memory_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=c_size_t), private :: freeMem integer(kind=c_int), private :: ierr integer(kind=c_size_t), private :: totalMem Source Code subroutine get_gpu_memory_info ( mem ) !! routine to get the free and total memory for the device_type object !! can be used independently with call get_gpu_memory_info(device_object) type ( device_type ), intent ( inout ) :: mem integer ( c_size_t ) :: freeMem , totalMem integer ( c_int ) :: ierr call gpugetmeminfo ( freeMem , totalMem , ierr ) if ( ierr == 0_c_int ) then mem % free_mb = real ( freeMem , kind = dp ) / 102 4.0_dp / 102 4.0_dp mem % total_mb = real ( totalMem , kind = dp ) / 102 4.0_dp / 102 4.0_dp mem % used_mb = mem % total_mb - mem % free_mb else mem = device_type () ! zero it end if end subroutine get_gpu_memory_info","tags":"","url":"proc/get_gpu_memory_info.html"},{"title":"to_string – PIC","text":"public interface to_string convenient way to print the device_type using to_string(my_device) Calls interface~~to_string~2~~CallsGraph interface~to_string~2 to_string proc~to_string_device to_string_device interface~to_string~2->proc~to_string_device Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function to_string_device (self) result(str) cute printing routine for the pic device type, transforms the contents into a\nstring of chars Arguments Type Intent Optional Attributes Name class( device_type ), intent(in) :: self Return Value character(len=:), allocatable","tags":"","url":"interface/to_string~2.html"},{"title":"fix_nvhpc_octal_format – PIC","text":"pure function fix_nvhpc_octal_format(fmt) result(fixed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer, private :: dot_pos integer, private :: pos character(len=10), private :: precision_str Source Code pure function fix_nvhpc_octal_format ( fmt ) result ( fixed ) character ( len =* ), intent ( in ) :: fmt character ( len = :), allocatable :: fixed integer :: pos , dot_pos character ( len = 10 ) :: precision_str ! Check if format contains \"O0.\" pos = index ( fmt , 'O0.' ) if ( pos > 0 ) then ! Extract precision after the dot dot_pos = pos + 2 ! Position of '.' precision_str = fmt ( dot_pos + 1 :) ! Replace O0.w with Ow.w (where w is the precision) fixed = fmt ( 1 : pos - 1 ) // 'O' // trim ( precision_str ) // '.' // trim ( precision_str ) else fixed = fmt end if end function fix_nvhpc_octal_format","tags":"","url":"proc/fix_nvhpc_octal_format.html"},{"title":"gpugetdevice – PIC","text":"public  subroutine gpugetdevice(device_id, ierr) get current device id from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: device_id integer(kind=c_int), intent(out) :: ierr Called by proc~~gpugetdevice~~CalledByGraph proc~gpugetdevice gpugetdevice proc~get_device_id get_device_id proc~get_device_id->proc~gpugetdevice proc~get_gpu_information device_type%get_gpu_information proc~get_gpu_information->proc~get_device_id Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gpugetdevice ( device_id , ierr ) !! get current device id from the GPU runtime integer ( c_int ), intent ( out ) :: device_id , ierr #ifdef HAVE_CUDA ierr = cudaGetDevice ( device_id ) #elif defined(HAVE_HIP) ierr = hipGetDevice ( device_id ) #else ierr = - 1_c_int device_id = - 1_c_int #endif end subroutine gpugetdevice","tags":"","url":"proc/gpugetdevice.html"},{"title":"gpugetdevicecount – PIC","text":"public  subroutine gpugetdevicecount(device_count, ierr) get device count available from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: device_count integer(kind=c_int), intent(out) :: ierr Source Code subroutine gpugetdevicecount ( device_count , ierr ) !! get device count available from the GPU runtime integer ( c_int ), intent ( out ) :: device_count , ierr #ifdef HAVE_CUDA ierr = cudaGetDeviceCount ( device_count ) #elif defined(HAVE_HIP) ierr = hipGetDeviceCount ( device_count ) #else ierr = - 1_c_int device_count = 0_c_int #endif end subroutine gpugetdevicecount","tags":"","url":"proc/gpugetdevicecount.html"},{"title":"gpugetmeminfo – PIC","text":"public  subroutine gpugetmeminfo(freeMem, totalMem, ierr) get free and total memory from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(out) :: freeMem integer(kind=c_size_t), intent(out) :: totalMem integer(kind=c_int), intent(out) :: ierr Called by proc~~gpugetmeminfo~~CalledByGraph proc~gpugetmeminfo gpugetmeminfo proc~get_gpu_memory_info get_gpu_memory_info proc~get_gpu_memory_info->proc~gpugetmeminfo proc~get_gpu_information device_type%get_gpu_information proc~get_gpu_information->proc~get_gpu_memory_info Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine gpugetmeminfo ( freeMem , totalMem , ierr ) !! get free and total memory from the GPU runtime integer ( c_size_t ), intent ( out ) :: freeMem , totalMem integer ( c_int ), intent ( out ) :: ierr #ifdef HAVE_CUDA ierr = cudaMemGetInfo ( freeMem , totalMem ) #elif defined(HAVE_HIP) ierr = hipMemGetInfo ( freeMem , totalMem ) #else freeMem = 0_c_size_t totalMem = 0_c_size_t ierr = - 1 #endif end subroutine gpugetmeminfo","tags":"","url":"proc/gpugetmeminfo.html"},{"title":"get_knowledge – PIC","text":"public  subroutine get_knowledge() I print random knowledge Arguments None Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: idx type( string_type ), private, allocatable :: knowledge (:) integer(kind=int32), private :: n real(kind=dp), private :: r Source Code subroutine get_knowledge () !! I print random knowledge type ( string_type ), allocatable :: knowledge (:) integer ( int32 ) :: n , idx real ( dp ) :: r allocate ( knowledge ( 8 )) knowledge ( 1 ) = \"The long line! (CS,2023)\" knowledge ( 2 ) = \"Maybe I have the Fortran brain-rot in Dijkstra's words (IP,2025)\" knowledge ( 3 ) = \"Mojo, yes, do I approve it, no. (IP, 2025)\" knowledge ( 4 ) = \"No, rice does not contain gluten (EG, dawn of time)\" knowledge ( 5 ) = \"Yes, potatoes are gluten free (EG, dawn of time)\" knowledge ( 6 ) = \"Stonks (MS, 2019)\" knowledge ( 7 ) = \"Praise the machine god\" knowledge ( 8 ) = \"Maybe I WILL use a more efficient language: Fortran (Jorge, to CS)\" n = size ( knowledge ) call random_number ( r ) idx = int ( r * n ) + 1 if ( idx > n ) idx = n call logger % knowledge ( trim ( char ( knowledge ( idx )))) end subroutine get_knowledge","tags":"","url":"proc/get_knowledge.html"},{"title":"close_log_file – PIC","text":"private  subroutine close_log_file(self) Close the log file, needs to be called at the end of the program Usage: call my_logger%close_log_file() TODO: revisit Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self Called by proc~~close_log_file~~CalledByGraph proc~close_log_file logger_type%close_log_file proc~configure_file_output logger_type%configure_file_output proc~configure_file_output->proc~close_log_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine close_log_file ( self ) !! Close the log file, needs to be called at the end of the program !! !! Usage: call my_logger%close_log_file() !! !! TODO: revisit class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file","tags":"","url":"proc/close_log_file.html"},{"title":"configuration – PIC","text":"private pure subroutine configuration(self, level) Get the current logger verbosity configuration Usage: call my_logger%configuration(level) TODO: this should be a function Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level Source Code pure subroutine configuration ( self , level ) !! Get the current logger verbosity configuration !! !! Usage: call my_logger%configuration(level) !! !! TODO: this should be a function class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration","tags":"","url":"proc/configuration.html"},{"title":"configure – PIC","text":"private pure subroutine configure(self, level) Configure the logger to be a certain verbosity level Usage: call my_logger%configure(level) Where level can be a number according to the level struct\nor can be loaded from the level struct to be debug_level = 10, & verbose_level = 9, & info_level = 8, & performance_level = 7, & warning_level = 6, & error_level = 5, & knowledge_level = 4 Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level Source Code pure subroutine configure ( self , level ) !! Configure the logger to be a certain verbosity level !! !! Usage: call my_logger%configure(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5, & !! !! knowledge_level = 4 !! class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure","tags":"","url":"proc/configure.html"},{"title":"configure_file_output – PIC","text":"private  subroutine configure_file_output(self, filename, level) Configure the logger to file to be a certain verbosity level Usage: call my_logger%configure_file_output(level) Where level can be a number according to the level struct\nor can be loaded from the level struct to be debug_level = 10, & verbose_level = 9, & info_level = 8, & performance_level = 7, & warning_level = 6, & error_level = 5, & knowledge_level = 4 Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level Calls proc~~configure_file_output~~CallsGraph proc~configure_file_output logger_type%configure_file_output proc~close_log_file logger_type%close_log_file proc~configure_file_output->proc~close_log_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: ios Source Code subroutine configure_file_output ( self , filename , level ) !! Configure the logger to file to be a certain verbosity level !! !! Usage: call my_logger%configure_file_output(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5, & !! !! knowledge_level = 4 !! class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = \"replace\" , action = \"write\" , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) \"ERROR: Failed to open log file: \" , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output","tags":"","url":"proc/configure_file_output.html"},{"title":"debug – PIC","text":"private  subroutine debug(self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Usage: call my_logger%debug(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine debug ( self , message , module , procedure ) !! Log a message that will only be printed at the debug level of verbosity !! !! Usage: call my_logger%debug(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug","tags":"","url":"proc/debug.html"},{"title":"error – PIC","text":"private  subroutine error(self, message, module, procedure) Log a message that will only be printed at the error of verbosity Usage: call my_logger%error(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine error ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%error(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error","tags":"","url":"proc/error.html"},{"title":"info – PIC","text":"private  subroutine info(self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Usage: call my_logger%info(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine info ( self , message , module , procedure ) !! Log a message that will only be printed at the info level of verbosity !! !! Usage: call my_logger%info(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info","tags":"","url":"proc/info.html"},{"title":"knowledge – PIC","text":"private  subroutine knowledge(self, message, module, procedure) Log a message that will only be printed at the error of verbosity Usage: call my_logger%knowledge(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine knowledge ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%knowledge(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"LORE\" , message , module , procedure ) end subroutine knowledge","tags":"","url":"proc/knowledge.html"},{"title":"log – PIC","text":"private  subroutine log(self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Calls proc~~log~~CallsGraph proc~log logger_type%log proc~write_log_line write_log_line proc~log->proc~write_log_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: log_level_value Source Code subroutine log ( self , level , message , module , procedure ) !! internal subroutines that processes the message and filters it according to !! the verbosity level set by the user or the default !! this is a private subroutine so it is not exposed to the user class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( \"DEBUG\" ) log_level_value = debug_level case ( \"VERBOSE\" ) log_level_value = verbose_level case ( \"INFO\" ) log_level_value = info_level case ( \"WARNING\" ) log_level_value = warning_level case ( \"PERFORMANCE\" ) log_level_value = performance_level case ( \"ERROR\" ) log_level_value = error_level case ( \"LORE\" ) log_level_value = knowledge_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log","tags":"","url":"proc/log.html"},{"title":"performance – PIC","text":"private  subroutine performance(self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Usage: call my_logger%performance(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine performance ( self , message , module , procedure ) !! Log a message that will only be printed at the performance of verbosity !! !! Usage: call my_logger%performance(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance","tags":"","url":"proc/performance.html"},{"title":"verbose – PIC","text":"private  subroutine verbose(self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Usage: call my_logger%verbose(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine verbose ( self , message , module , procedure ) !! Log a message that will only be printed at the verbose level of verbosity !! !! Usage: call my_logger%verbose(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose","tags":"","url":"proc/verbose.html"},{"title":"warning – PIC","text":"private  subroutine warning(self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Usage: call my_logger%warning(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine warning ( self , message , module , procedure ) !! Log a message that will only be printed at the warning level of verbosity !! !! Usage: call my_logger%warning(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning","tags":"","url":"proc/warning.html"},{"title":"write_log_line – PIC","text":"private  subroutine write_log_line(unit, level, message, module, procedure) Internal subroutine that will write the message to the log\nno interface to the public Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: unit character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Called by proc~~write_log_line~~CalledByGraph proc~write_log_line write_log_line proc~log logger_type%log proc~log->proc~write_log_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_log_line ( unit , level , message , module , procedure ) !! Internal subroutine that will write the message to the log !! no interface to the public integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line","tags":"","url":"proc/write_log_line.html"},{"title":"get_threading_mode_ – PIC","text":"private  function get_threading_mode_() result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical Called by proc~~get_threading_mode_~~CalledByGraph proc~get_threading_mode_ get_threading_mode_ interface~get_threading_mode get_threading_mode interface~get_threading_mode->proc~get_threading_mode_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_threading_mode_ () result ( mode ) !! get the current threading mode for the array routines !! Usage: mode = get_threading_mode() logical :: mode mode = use_threaded_default end function get_threading_mode_","tags":"","url":"proc/get_threading_mode_.html"},{"title":"is_sorted_char – PIC","text":"private pure function is_sorted_char(array, order) result(sorted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Calls proc~~is_sorted_char~~CallsGraph proc~is_sorted_char is_sorted_char interface~pic_optional pic_optional proc~is_sorted_char->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_sorted_char~~CalledByGraph proc~is_sorted_char is_sorted_char interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_char ( array , order ) result ( sorted ) character ( len =* ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_char","tags":"","url":"proc/is_sorted_char.html"},{"title":"is_sorted_dp – PIC","text":"private pure function is_sorted_dp(array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Calls proc~~is_sorted_dp~~CallsGraph proc~is_sorted_dp is_sorted_dp interface~pic_optional pic_optional proc~is_sorted_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_sorted_dp~~CalledByGraph proc~is_sorted_dp is_sorted_dp interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_dp ( array , order ) result ( sorted ) real ( dp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_dp","tags":"","url":"proc/is_sorted_dp.html"},{"title":"is_sorted_int32 – PIC","text":"private pure function is_sorted_int32(array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Calls proc~~is_sorted_int32~~CallsGraph proc~is_sorted_int32 is_sorted_int32 interface~pic_optional pic_optional proc~is_sorted_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_sorted_int32~~CalledByGraph proc~is_sorted_int32 is_sorted_int32 interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_int32 ( array , order ) result ( sorted ) integer ( int32 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int32","tags":"","url":"proc/is_sorted_int32.html"},{"title":"is_sorted_int64 – PIC","text":"private pure function is_sorted_int64(array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Calls proc~~is_sorted_int64~~CallsGraph proc~is_sorted_int64 is_sorted_int64 interface~pic_optional pic_optional proc~is_sorted_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_sorted_int64~~CalledByGraph proc~is_sorted_int64 is_sorted_int64 interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_int64 ( array , order ) result ( sorted ) integer ( int64 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int64","tags":"","url":"proc/is_sorted_int64.html"},{"title":"is_sorted_sp – PIC","text":"private pure function is_sorted_sp(array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Calls proc~~is_sorted_sp~~CallsGraph proc~is_sorted_sp is_sorted_sp interface~pic_optional pic_optional proc~is_sorted_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~is_sorted_sp~~CalledByGraph proc~is_sorted_sp is_sorted_sp interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_sp ( array , order ) result ( sorted ) real ( sp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_sp","tags":"","url":"proc/is_sorted_sp.html"},{"title":"sum_3d_tensor_dp – PIC","text":"private  function sum_3d_tensor_dp(tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) Calls proc~~sum_3d_tensor_dp~~CallsGraph proc~sum_3d_tensor_dp sum_3d_tensor_dp interface~pic_optional pic_optional proc~sum_3d_tensor_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_3d_tensor_dp~~CalledByGraph proc~sum_3d_tensor_dp sum_3d_tensor_dp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code function sum_3d_tensor_dp ( tensor , threaded ) result ( res ) real ( dp ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_dp if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_dp","tags":"","url":"proc/sum_3d_tensor_dp.html"},{"title":"sum_3d_tensor_int32 – PIC","text":"private  function sum_3d_tensor_int32(tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) Calls proc~~sum_3d_tensor_int32~~CallsGraph proc~sum_3d_tensor_int32 sum_3d_tensor_int32 interface~pic_optional pic_optional proc~sum_3d_tensor_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_3d_tensor_int32~~CalledByGraph proc~sum_3d_tensor_int32 sum_3d_tensor_int32 interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code function sum_3d_tensor_int32 ( tensor , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_int32","tags":"","url":"proc/sum_3d_tensor_int32.html"},{"title":"sum_3d_tensor_int64 – PIC","text":"private  function sum_3d_tensor_int64(tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) Calls proc~~sum_3d_tensor_int64~~CallsGraph proc~sum_3d_tensor_int64 sum_3d_tensor_int64 interface~pic_optional pic_optional proc~sum_3d_tensor_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_3d_tensor_int64~~CalledByGraph proc~sum_3d_tensor_int64 sum_3d_tensor_int64 interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code function sum_3d_tensor_int64 ( tensor , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_int64","tags":"","url":"proc/sum_3d_tensor_int64.html"},{"title":"sum_3d_tensor_sp – PIC","text":"private  function sum_3d_tensor_sp(tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Calls proc~~sum_3d_tensor_sp~~CallsGraph proc~sum_3d_tensor_sp sum_3d_tensor_sp interface~pic_optional pic_optional proc~sum_3d_tensor_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_3d_tensor_sp~~CalledByGraph proc~sum_3d_tensor_sp sum_3d_tensor_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code function sum_3d_tensor_sp ( tensor , threaded ) result ( res ) real ( sp ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_sp if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_sp","tags":"","url":"proc/sum_3d_tensor_sp.html"},{"title":"sum_matrix_dp – PIC","text":"private  function sum_matrix_dp(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) Calls proc~~sum_matrix_dp~~CallsGraph proc~sum_matrix_dp sum_matrix_dp interface~pic_optional pic_optional proc~sum_matrix_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_matrix_dp~~CalledByGraph proc~sum_matrix_dp sum_matrix_dp interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_dp ( matrix , threaded ) result ( res ) real ( dp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_dp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_dp","tags":"","url":"proc/sum_matrix_dp.html"},{"title":"sum_matrix_int32 – PIC","text":"private  function sum_matrix_int32(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) Calls proc~~sum_matrix_int32~~CallsGraph proc~sum_matrix_int32 sum_matrix_int32 interface~pic_optional pic_optional proc~sum_matrix_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_matrix_int32~~CalledByGraph proc~sum_matrix_int32 sum_matrix_int32 interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_int32 ( matrix , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int32","tags":"","url":"proc/sum_matrix_int32.html"},{"title":"sum_matrix_int64 – PIC","text":"private  function sum_matrix_int64(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) Calls proc~~sum_matrix_int64~~CallsGraph proc~sum_matrix_int64 sum_matrix_int64 interface~pic_optional pic_optional proc~sum_matrix_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_matrix_int64~~CalledByGraph proc~sum_matrix_int64 sum_matrix_int64 interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_int64 ( matrix , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int64","tags":"","url":"proc/sum_matrix_int64.html"},{"title":"sum_matrix_sp – PIC","text":"private  function sum_matrix_sp(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Calls proc~~sum_matrix_sp~~CallsGraph proc~sum_matrix_sp sum_matrix_sp interface~pic_optional pic_optional proc~sum_matrix_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_matrix_sp~~CalledByGraph proc~sum_matrix_sp sum_matrix_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_sp ( matrix , threaded ) result ( res ) real ( sp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_sp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_sp","tags":"","url":"proc/sum_matrix_sp.html"},{"title":"sum_vector_dp – PIC","text":"private  function sum_vector_dp(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) Calls proc~~sum_vector_dp~~CallsGraph proc~sum_vector_dp sum_vector_dp interface~pic_optional pic_optional proc~sum_vector_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_vector_dp~~CalledByGraph proc~sum_vector_dp sum_vector_dp interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_dp ( vector , threaded ) result ( res ) real ( dp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: i res = 0_dp use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_dp","tags":"","url":"proc/sum_vector_dp.html"},{"title":"sum_vector_int32 – PIC","text":"private  function sum_vector_int32(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) Calls proc~~sum_vector_int32~~CallsGraph proc~sum_vector_int32 sum_vector_int32 interface~pic_optional pic_optional proc~sum_vector_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_vector_int32~~CalledByGraph proc~sum_vector_int32 sum_vector_int32 interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_int32 ( vector , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: i res = 0_int32 use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int32","tags":"","url":"proc/sum_vector_int32.html"},{"title":"sum_vector_int64 – PIC","text":"private  function sum_vector_int64(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) Calls proc~~sum_vector_int64~~CallsGraph proc~sum_vector_int64 sum_vector_int64 interface~pic_optional pic_optional proc~sum_vector_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_vector_int64~~CalledByGraph proc~sum_vector_int64 sum_vector_int64 interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_int64 ( vector , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: i res = 0_int64 use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int64","tags":"","url":"proc/sum_vector_int64.html"},{"title":"sum_vector_sp – PIC","text":"private  function sum_vector_sp(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Calls proc~~sum_vector_sp~~CallsGraph proc~sum_vector_sp sum_vector_sp interface~pic_optional pic_optional proc~sum_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~sum_vector_sp~~CalledByGraph proc~sum_vector_sp sum_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_sp ( vector , threaded ) result ( res ) real ( sp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: i res = 0_sp use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_sp","tags":"","url":"proc/sum_vector_sp.html"},{"title":"copy_3d_tensor_dp – PIC","text":"private  subroutine copy_3d_tensor_dp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:,:) real(kind=dp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded Calls proc~~copy_3d_tensor_dp~~CallsGraph proc~copy_3d_tensor_dp copy_3d_tensor_dp interface~pic_optional pic_optional proc~copy_3d_tensor_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_3d_tensor_dp~~CalledByGraph proc~copy_3d_tensor_dp copy_3d_tensor_dp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine copy_3d_tensor_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :, :) real ( dp ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_dp","tags":"","url":"proc/copy_3d_tensor_dp.html"},{"title":"copy_3d_tensor_int32 – PIC","text":"private  subroutine copy_3d_tensor_int32(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:,:) integer(kind=int32), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded Calls proc~~copy_3d_tensor_int32~~CallsGraph proc~copy_3d_tensor_int32 copy_3d_tensor_int32 interface~pic_optional pic_optional proc~copy_3d_tensor_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_3d_tensor_int32~~CalledByGraph proc~copy_3d_tensor_int32 copy_3d_tensor_int32 interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine copy_3d_tensor_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :, :) integer ( int32 ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_int32","tags":"","url":"proc/copy_3d_tensor_int32.html"},{"title":"copy_3d_tensor_int64 – PIC","text":"private  subroutine copy_3d_tensor_int64(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:,:) integer(kind=int64), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded Calls proc~~copy_3d_tensor_int64~~CallsGraph proc~copy_3d_tensor_int64 copy_3d_tensor_int64 interface~pic_optional pic_optional proc~copy_3d_tensor_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_3d_tensor_int64~~CalledByGraph proc~copy_3d_tensor_int64 copy_3d_tensor_int64 interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine copy_3d_tensor_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :, :) integer ( int64 ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_int64","tags":"","url":"proc/copy_3d_tensor_int64.html"},{"title":"copy_3d_tensor_sp – PIC","text":"private  subroutine copy_3d_tensor_sp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:,:) real(kind=sp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded Calls proc~~copy_3d_tensor_sp~~CallsGraph proc~copy_3d_tensor_sp copy_3d_tensor_sp interface~pic_optional pic_optional proc~copy_3d_tensor_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_3d_tensor_sp~~CalledByGraph proc~copy_3d_tensor_sp copy_3d_tensor_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine copy_3d_tensor_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :, :) real ( sp ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_sp","tags":"","url":"proc/copy_3d_tensor_sp.html"},{"title":"copy_matrix_dp – PIC","text":"private  subroutine copy_matrix_dp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Calls proc~~copy_matrix_dp~~CallsGraph proc~copy_matrix_dp copy_matrix_dp interface~pic_optional pic_optional proc~copy_matrix_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_matrix_dp~~CalledByGraph proc~copy_matrix_dp copy_matrix_dp interface~pic_copy pic_copy interface~pic_copy->proc~copy_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :) real ( dp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_dp","tags":"","url":"proc/copy_matrix_dp.html"},{"title":"copy_matrix_int32 – PIC","text":"private  subroutine copy_matrix_int32(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Calls proc~~copy_matrix_int32~~CallsGraph proc~copy_matrix_int32 copy_matrix_int32 interface~pic_optional pic_optional proc~copy_matrix_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_matrix_int32~~CalledByGraph proc~copy_matrix_int32 copy_matrix_int32 interface~pic_copy pic_copy interface~pic_copy->proc~copy_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :) integer ( int32 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int32","tags":"","url":"proc/copy_matrix_int32.html"},{"title":"copy_matrix_int64 – PIC","text":"private  subroutine copy_matrix_int64(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Calls proc~~copy_matrix_int64~~CallsGraph proc~copy_matrix_int64 copy_matrix_int64 interface~pic_optional pic_optional proc~copy_matrix_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_matrix_int64~~CalledByGraph proc~copy_matrix_int64 copy_matrix_int64 interface~pic_copy pic_copy interface~pic_copy->proc~copy_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :) integer ( int64 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int64","tags":"","url":"proc/copy_matrix_int64.html"},{"title":"copy_matrix_sp – PIC","text":"private  subroutine copy_matrix_sp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Calls proc~~copy_matrix_sp~~CallsGraph proc~copy_matrix_sp copy_matrix_sp interface~pic_optional pic_optional proc~copy_matrix_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_matrix_sp~~CalledByGraph proc~copy_matrix_sp copy_matrix_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :) real ( sp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_sp","tags":"","url":"proc/copy_matrix_sp.html"},{"title":"copy_vector_dp – PIC","text":"private  subroutine copy_vector_dp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded Calls proc~~copy_vector_dp~~CallsGraph proc~copy_vector_dp copy_vector_dp interface~pic_optional pic_optional proc~copy_vector_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_vector_dp~~CalledByGraph proc~copy_vector_dp copy_vector_dp interface~pic_copy pic_copy interface~pic_copy->proc~copy_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:) real ( dp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_dp","tags":"","url":"proc/copy_vector_dp.html"},{"title":"copy_vector_int32 – PIC","text":"private  subroutine copy_vector_int32(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded Calls proc~~copy_vector_int32~~CallsGraph proc~copy_vector_int32 copy_vector_int32 interface~pic_optional pic_optional proc~copy_vector_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_vector_int32~~CalledByGraph proc~copy_vector_int32 copy_vector_int32 interface~pic_copy pic_copy interface~pic_copy->proc~copy_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:) integer ( int32 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int32","tags":"","url":"proc/copy_vector_int32.html"},{"title":"copy_vector_int64 – PIC","text":"private  subroutine copy_vector_int64(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded Calls proc~~copy_vector_int64~~CallsGraph proc~copy_vector_int64 copy_vector_int64 interface~pic_optional pic_optional proc~copy_vector_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_vector_int64~~CalledByGraph proc~copy_vector_int64 copy_vector_int64 interface~pic_copy pic_copy interface~pic_copy->proc~copy_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:) integer ( int64 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int64","tags":"","url":"proc/copy_vector_int64.html"},{"title":"copy_vector_sp – PIC","text":"private  subroutine copy_vector_sp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded Calls proc~~copy_vector_sp~~CallsGraph proc~copy_vector_sp copy_vector_sp interface~pic_optional pic_optional proc~copy_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~copy_vector_sp~~CalledByGraph proc~copy_vector_sp copy_vector_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:) real ( sp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_sp","tags":"","url":"proc/copy_vector_sp.html"},{"title":"fill_3d_tensor_dp – PIC","text":"private  subroutine fill_3d_tensor_dp(tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (:,:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_3d_tensor_dp~~CallsGraph proc~fill_3d_tensor_dp fill_3d_tensor_dp interface~pic_optional pic_optional proc~fill_3d_tensor_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_3d_tensor_dp~~CalledByGraph proc~fill_3d_tensor_dp fill_3d_tensor_dp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine fill_3d_tensor_dp ( tensor , alpha , threaded ) real ( dp ), intent ( inout ) :: tensor (:, :, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_dp","tags":"","url":"proc/fill_3d_tensor_dp.html"},{"title":"fill_3d_tensor_int32 – PIC","text":"private  subroutine fill_3d_tensor_int32(tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: tensor (:,:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_3d_tensor_int32~~CallsGraph proc~fill_3d_tensor_int32 fill_3d_tensor_int32 interface~pic_optional pic_optional proc~fill_3d_tensor_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_3d_tensor_int32~~CalledByGraph proc~fill_3d_tensor_int32 fill_3d_tensor_int32 interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine fill_3d_tensor_int32 ( tensor , alpha , threaded ) integer ( int32 ), intent ( inout ) :: tensor (:, :, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_int32","tags":"","url":"proc/fill_3d_tensor_int32.html"},{"title":"fill_3d_tensor_int64 – PIC","text":"private  subroutine fill_3d_tensor_int64(tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: tensor (:,:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_3d_tensor_int64~~CallsGraph proc~fill_3d_tensor_int64 fill_3d_tensor_int64 interface~pic_optional pic_optional proc~fill_3d_tensor_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_3d_tensor_int64~~CalledByGraph proc~fill_3d_tensor_int64 fill_3d_tensor_int64 interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine fill_3d_tensor_int64 ( tensor , alpha , threaded ) integer ( int64 ), intent ( inout ) :: tensor (:, :, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_int64","tags":"","url":"proc/fill_3d_tensor_int64.html"},{"title":"fill_3d_tensor_sp – PIC","text":"private  subroutine fill_3d_tensor_sp(tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: tensor (:,:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_3d_tensor_sp~~CallsGraph proc~fill_3d_tensor_sp fill_3d_tensor_sp interface~pic_optional pic_optional proc~fill_3d_tensor_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_3d_tensor_sp~~CalledByGraph proc~fill_3d_tensor_sp fill_3d_tensor_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: k integer(kind=default_int), private :: kk integer(kind=default_int), private :: nx integer(kind=default_int), private :: ny integer(kind=default_int), private :: nz logical, private :: use_threads Source Code subroutine fill_3d_tensor_sp ( tensor , alpha , threaded ) real ( sp ), intent ( inout ) :: tensor (:, :, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_sp","tags":"","url":"proc/fill_3d_tensor_sp.html"},{"title":"fill_matrix_dp – PIC","text":"private  subroutine fill_matrix_dp(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_matrix_dp~~CallsGraph proc~fill_matrix_dp fill_matrix_dp interface~pic_optional pic_optional proc~fill_matrix_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_matrix_dp~~CalledByGraph proc~fill_matrix_dp fill_matrix_dp interface~pic_fill pic_fill interface~pic_fill->proc~fill_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_dp ( matrix , alpha , threaded ) real ( dp ), intent ( inout ) :: matrix (:, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_dp","tags":"","url":"proc/fill_matrix_dp.html"},{"title":"fill_matrix_int32 – PIC","text":"private  subroutine fill_matrix_int32(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_matrix_int32~~CallsGraph proc~fill_matrix_int32 fill_matrix_int32 interface~pic_optional pic_optional proc~fill_matrix_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_matrix_int32~~CalledByGraph proc~fill_matrix_int32 fill_matrix_int32 interface~pic_fill pic_fill interface~pic_fill->proc~fill_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_int32 ( matrix , alpha , threaded ) integer ( int32 ), intent ( inout ) :: matrix (:, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int32","tags":"","url":"proc/fill_matrix_int32.html"},{"title":"fill_matrix_int64 – PIC","text":"private  subroutine fill_matrix_int64(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_matrix_int64~~CallsGraph proc~fill_matrix_int64 fill_matrix_int64 interface~pic_optional pic_optional proc~fill_matrix_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_matrix_int64~~CalledByGraph proc~fill_matrix_int64 fill_matrix_int64 interface~pic_fill pic_fill interface~pic_fill->proc~fill_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_int64 ( matrix , alpha , threaded ) integer ( int64 ), intent ( inout ) :: matrix (:, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int64","tags":"","url":"proc/fill_matrix_int64.html"},{"title":"fill_matrix_sp – PIC","text":"private  subroutine fill_matrix_sp(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_matrix_sp~~CallsGraph proc~fill_matrix_sp fill_matrix_sp interface~pic_optional pic_optional proc~fill_matrix_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_matrix_sp~~CalledByGraph proc~fill_matrix_sp fill_matrix_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_sp ( matrix , alpha , threaded ) real ( sp ), intent ( inout ) :: matrix (:, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_sp","tags":"","url":"proc/fill_matrix_sp.html"},{"title":"fill_vector_dp – PIC","text":"private  subroutine fill_vector_dp(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_vector_dp~~CallsGraph proc~fill_vector_dp fill_vector_dp interface~pic_optional pic_optional proc~fill_vector_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_vector_dp~~CalledByGraph proc~fill_vector_dp fill_vector_dp interface~pic_fill pic_fill interface~pic_fill->proc~fill_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_dp ( vector , alpha , threaded ) real ( dp ), intent ( inout ) :: vector (:) real ( dp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_dp","tags":"","url":"proc/fill_vector_dp.html"},{"title":"fill_vector_int32 – PIC","text":"private  subroutine fill_vector_int32(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_vector_int32~~CallsGraph proc~fill_vector_int32 fill_vector_int32 interface~pic_optional pic_optional proc~fill_vector_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_vector_int32~~CalledByGraph proc~fill_vector_int32 fill_vector_int32 interface~pic_fill pic_fill interface~pic_fill->proc~fill_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_int32 ( vector , alpha , threaded ) integer ( int32 ), intent ( inout ) :: vector (:) integer ( int32 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int32","tags":"","url":"proc/fill_vector_int32.html"},{"title":"fill_vector_int64 – PIC","text":"private  subroutine fill_vector_int64(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_vector_int64~~CallsGraph proc~fill_vector_int64 fill_vector_int64 interface~pic_optional pic_optional proc~fill_vector_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_vector_int64~~CalledByGraph proc~fill_vector_int64 fill_vector_int64 interface~pic_fill pic_fill interface~pic_fill->proc~fill_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int64","tags":"","url":"proc/fill_vector_int64.html"},{"title":"fill_vector_sp – PIC","text":"private  subroutine fill_vector_sp(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded Calls proc~~fill_vector_sp~~CallsGraph proc~fill_vector_sp fill_vector_sp interface~pic_optional pic_optional proc~fill_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~fill_vector_sp~~CalledByGraph proc~fill_vector_sp fill_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_sp ( vector , alpha , threaded ) real ( sp ), intent ( inout ) :: vector (:) real ( sp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_sp","tags":"","url":"proc/fill_vector_sp.html"},{"title":"print_3d_tensor_dp – PIC","text":"private  subroutine print_3d_tensor_dp(matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_dp~~CallsGraph proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_optional pic_optional proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~set_brackets set_brackets proc~print_3d_tensor_dp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~pic_print_array->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~pic_print_array->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~pic_print_array->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~pic_print_array->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~pic_print_array->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~pic_print_array->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int32->proc~set_brackets proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_int64->proc~set_brackets proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_3d_tensor_sp->proc~set_brackets proc~print_matrix_dp->interface~pic_optional proc~print_matrix_dp->proc~set_brackets interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_char proc~print_matrix_int64->interface~pic_optional proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_char proc~print_matrix_sp->interface~pic_optional proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp->interface~pic_optional proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp->interface~pic_optional proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_char proc~print_vector_int32->interface~pic_optional proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_char proc~print_vector_int64->interface~pic_optional proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_char proc~print_vector_sp->interface~pic_optional proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_char proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_dp~~CalledByGraph proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_dp ( matrix , format_type ) !! Print a 3D tensor of ${T} values real ( dp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_dp","tags":"","url":"proc/print_3d_tensor_dp.html"},{"title":"print_3d_tensor_int32 – PIC","text":"private  subroutine print_3d_tensor_int32(matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_int32~~CallsGraph proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_optional pic_optional proc~print_3d_tensor_int32->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~set_brackets set_brackets proc~print_3d_tensor_int32->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~pic_print_array->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~pic_print_array->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~pic_print_array->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~pic_print_array->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~pic_print_array->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~pic_print_array->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_dp->interface~pic_optional proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_dp->proc~set_brackets proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_int64->proc~set_brackets proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_3d_tensor_sp->proc~set_brackets proc~print_matrix_dp->interface~pic_optional proc~print_matrix_dp->proc~set_brackets interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_char proc~print_matrix_int64->interface~pic_optional proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_char proc~print_matrix_sp->interface~pic_optional proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp->interface~pic_optional proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp->interface~pic_optional proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_char proc~print_vector_int32->interface~pic_optional proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_char proc~print_vector_int64->interface~pic_optional proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_char proc~print_vector_sp->interface~pic_optional proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_char proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_int32~~CalledByGraph proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_int32 ( matrix , format_type ) !! Print a 3D tensor of ${T} values integer ( int32 ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_int32","tags":"","url":"proc/print_3d_tensor_int32.html"},{"title":"print_3d_tensor_int64 – PIC","text":"private  subroutine print_3d_tensor_int64(matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_int64~~CallsGraph proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_optional pic_optional proc~print_3d_tensor_int64->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~set_brackets set_brackets proc~print_3d_tensor_int64->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~pic_print_array->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~pic_print_array->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~pic_print_array->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~pic_print_array->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~pic_print_array->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~pic_print_array->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_dp->interface~pic_optional proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_dp->proc~set_brackets proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int32->proc~set_brackets proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_3d_tensor_sp->proc~set_brackets proc~print_matrix_dp->interface~pic_optional proc~print_matrix_dp->proc~set_brackets interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_char proc~print_matrix_int64->interface~pic_optional proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_char proc~print_matrix_sp->interface~pic_optional proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp->interface~pic_optional proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp->interface~pic_optional proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_char proc~print_vector_int32->interface~pic_optional proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_char proc~print_vector_int64->interface~pic_optional proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_char proc~print_vector_sp->interface~pic_optional proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_char proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_int64~~CalledByGraph proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_int64 ( matrix , format_type ) !! Print a 3D tensor of ${T} values integer ( int64 ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_int64","tags":"","url":"proc/print_3d_tensor_int64.html"},{"title":"print_3d_tensor_sp – PIC","text":"private  subroutine print_3d_tensor_sp(matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_sp~~CallsGraph proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_optional pic_optional proc~print_3d_tensor_sp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array proc~set_brackets set_brackets proc~print_3d_tensor_sp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_matrix_dp print_matrix_dp interface~pic_print_array->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~pic_print_array->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~pic_print_array->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~pic_print_array->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~pic_print_array->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~pic_print_array->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_dp->interface~pic_optional proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_dp->proc~set_brackets proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int32->proc~set_brackets proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_int64->proc~set_brackets proc~print_matrix_dp->interface~pic_optional proc~print_matrix_dp->proc~set_brackets interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_char proc~print_matrix_int64->interface~pic_optional proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_char proc~print_matrix_sp->interface~pic_optional proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp->interface~pic_optional proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp->interface~pic_optional proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_char proc~print_vector_int32->interface~pic_optional proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_char proc~print_vector_int64->interface~pic_optional proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_char proc~print_vector_sp->interface~pic_optional proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_char proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_sp~~CalledByGraph proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_sp ( matrix , format_type ) !! Print a 3D tensor of ${T} values real ( sp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_sp","tags":"","url":"proc/print_3d_tensor_sp.html"},{"title":"print_matrix_dp – PIC","text":"private  subroutine print_matrix_dp(matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_dp~~CallsGraph proc~print_matrix_dp print_matrix_dp interface~pic_optional pic_optional proc~print_matrix_dp->interface~pic_optional interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~set_brackets set_brackets proc~print_matrix_dp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_dp~~CalledByGraph proc~print_matrix_dp print_matrix_dp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_dp ( matrix , format_type ) !! print a matrix of ${T} values real ( dp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_dp","tags":"","url":"proc/print_matrix_dp.html"},{"title":"print_matrix_int32 – PIC","text":"private  subroutine print_matrix_int32(matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_int32~~CallsGraph proc~print_matrix_int32 print_matrix_int32 interface~pic_optional pic_optional proc~print_matrix_int32->interface~pic_optional interface~to_char to_char proc~print_matrix_int32->interface~to_char proc~set_brackets set_brackets proc~print_matrix_int32->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_int32~~CalledByGraph proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_int32 ( matrix , format_type ) !! print a matrix of ${T} values integer ( int32 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int32","tags":"","url":"proc/print_matrix_int32.html"},{"title":"print_matrix_int64 – PIC","text":"private  subroutine print_matrix_int64(matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_int64~~CallsGraph proc~print_matrix_int64 print_matrix_int64 interface~pic_optional pic_optional proc~print_matrix_int64->interface~pic_optional interface~to_char to_char proc~print_matrix_int64->interface~to_char proc~set_brackets set_brackets proc~print_matrix_int64->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_int64~~CalledByGraph proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_int64 ( matrix , format_type ) !! print a matrix of ${T} values integer ( int64 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int64","tags":"","url":"proc/print_matrix_int64.html"},{"title":"print_matrix_sp – PIC","text":"private  subroutine print_matrix_sp(matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_sp~~CallsGraph proc~print_matrix_sp print_matrix_sp interface~pic_optional pic_optional proc~print_matrix_sp->interface~pic_optional interface~to_char to_char proc~print_matrix_sp->interface~to_char proc~set_brackets set_brackets proc~print_matrix_sp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_sp~~CalledByGraph proc~print_matrix_sp print_matrix_sp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_sp ( matrix , format_type ) !! print a matrix of ${T} values real ( sp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_sp","tags":"","url":"proc/print_matrix_sp.html"},{"title":"print_packed_matrix_dp – PIC","text":"private  subroutine print_packed_matrix_dp(packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_dp~~CallsGraph proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_optional pic_optional proc~print_packed_matrix_dp->interface~pic_optional interface~to_char to_char proc~print_packed_matrix_dp->interface~to_char proc~set_brackets set_brackets proc~print_packed_matrix_dp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_dp~~CalledByGraph proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_packed_matrix_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=dp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_dp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values real ( dp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_dp","tags":"","url":"proc/print_packed_matrix_dp.html"},{"title":"print_packed_matrix_int32 – PIC","text":"private  subroutine print_packed_matrix_int32(packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_int32~~CallsGraph proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_optional pic_optional proc~print_packed_matrix_int32->interface~pic_optional interface~to_char to_char proc~print_packed_matrix_int32->interface~to_char proc~set_brackets set_brackets proc~print_packed_matrix_int32->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_int32~~CalledByGraph proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=dp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_int32 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values integer ( int32 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int32","tags":"","url":"proc/print_packed_matrix_int32.html"},{"title":"print_packed_matrix_int64 – PIC","text":"private  subroutine print_packed_matrix_int64(packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_int64~~CallsGraph proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_optional pic_optional proc~print_packed_matrix_int64->interface~pic_optional interface~to_char to_char proc~print_packed_matrix_int64->interface~to_char proc~set_brackets set_brackets proc~print_packed_matrix_int64->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_int64~~CalledByGraph proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=dp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_int64 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values integer ( int64 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int64","tags":"","url":"proc/print_packed_matrix_int64.html"},{"title":"print_packed_matrix_sp – PIC","text":"private  subroutine print_packed_matrix_sp(packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_sp~~CallsGraph proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_optional pic_optional proc~print_packed_matrix_sp->interface~pic_optional interface~to_char to_char proc~print_packed_matrix_sp->interface~to_char proc~set_brackets set_brackets proc~print_packed_matrix_sp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_sp~~CalledByGraph proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_packed_matrix_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=dp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_sp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values real ( sp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_sp","tags":"","url":"proc/print_packed_matrix_sp.html"},{"title":"print_vector_dp – PIC","text":"private  subroutine print_vector_dp(vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_dp~~CallsGraph proc~print_vector_dp print_vector_dp interface~pic_optional pic_optional proc~print_vector_dp->interface~pic_optional interface~to_char to_char proc~print_vector_dp->interface~to_char proc~set_brackets set_brackets proc~print_vector_dp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_dp~~CalledByGraph proc~print_vector_dp print_vector_dp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_vector_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_dp ( vector , format_type ) !! print a vector of ${T} values real ( dp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_dp","tags":"","url":"proc/print_vector_dp.html"},{"title":"print_vector_int32 – PIC","text":"private  subroutine print_vector_int32(vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_int32~~CallsGraph proc~print_vector_int32 print_vector_int32 interface~pic_optional pic_optional proc~print_vector_int32->interface~pic_optional interface~to_char to_char proc~print_vector_int32->interface~to_char proc~set_brackets set_brackets proc~print_vector_int32->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_int32~~CalledByGraph proc~print_vector_int32 print_vector_int32 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_vector_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_int32 ( vector , format_type ) !! print a vector of ${T} values integer ( int32 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int32","tags":"","url":"proc/print_vector_int32.html"},{"title":"print_vector_int64 – PIC","text":"private  subroutine print_vector_int64(vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_int64~~CallsGraph proc~print_vector_int64 print_vector_int64 interface~pic_optional pic_optional proc~print_vector_int64->interface~pic_optional interface~to_char to_char proc~print_vector_int64->interface~to_char proc~set_brackets set_brackets proc~print_vector_int64->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_int64~~CalledByGraph proc~print_vector_int64 print_vector_int64 interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_vector_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_int64 ( vector , format_type ) !! print a vector of ${T} values integer ( int64 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int64","tags":"","url":"proc/print_vector_int64.html"},{"title":"print_vector_sp – PIC","text":"private  subroutine print_vector_sp(vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_sp~~CallsGraph proc~print_vector_sp print_vector_sp interface~pic_optional pic_optional proc~print_vector_sp->interface~pic_optional interface~to_char to_char proc~print_vector_sp->interface~to_char proc~set_brackets set_brackets proc~print_vector_sp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_sp~~CalledByGraph proc~print_vector_sp print_vector_sp interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_sp ( vector , format_type ) !! print a vector of ${T} values real ( sp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_sp","tags":"","url":"proc/print_vector_sp.html"},{"title":"scramble_array_character – PIC","text":"private  subroutine scramble_array_character(array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (:) Called by proc~~scramble_array_character~~CalledByGraph proc~scramble_array_character scramble_array_character interface~pic_scramble_array pic_scramble_array interface~pic_scramble_array->proc~scramble_array_character Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: i integer(kind=int32), private :: j integer(kind=int32), private :: n real(kind=sp), private :: rand_val character(len=len), private :: temp Source Code subroutine scramble_array_character ( array ) character ( len =* ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n character ( len = len ( array )) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_character","tags":"","url":"proc/scramble_array_character.html"},{"title":"scramble_array_dp – PIC","text":"private  subroutine scramble_array_dp(array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (:) Called by proc~~scramble_array_dp~~CalledByGraph proc~scramble_array_dp scramble_array_dp interface~pic_scramble_array pic_scramble_array interface~pic_scramble_array->proc~scramble_array_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: i integer(kind=int32), private :: j integer(kind=int32), private :: n real(kind=sp), private :: rand_val real(kind=dp), private :: temp Source Code subroutine scramble_array_dp ( array ) real ( dp ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n real ( dp ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_dp","tags":"","url":"proc/scramble_array_dp.html"},{"title":"scramble_array_int32 – PIC","text":"private  subroutine scramble_array_int32(array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (:) Called by proc~~scramble_array_int32~~CalledByGraph proc~scramble_array_int32 scramble_array_int32 interface~pic_scramble_array pic_scramble_array interface~pic_scramble_array->proc~scramble_array_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: i integer(kind=int32), private :: j integer(kind=int32), private :: n real(kind=sp), private :: rand_val integer(kind=int32), private :: temp Source Code subroutine scramble_array_int32 ( array ) integer ( int32 ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n integer ( int32 ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_int32","tags":"","url":"proc/scramble_array_int32.html"},{"title":"scramble_array_int64 – PIC","text":"private  subroutine scramble_array_int64(array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (:) Called by proc~~scramble_array_int64~~CalledByGraph proc~scramble_array_int64 scramble_array_int64 interface~pic_scramble_array pic_scramble_array interface~pic_scramble_array->proc~scramble_array_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: i integer(kind=int32), private :: j integer(kind=int32), private :: n real(kind=sp), private :: rand_val integer(kind=int64), private :: temp Source Code subroutine scramble_array_int64 ( array ) integer ( int64 ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n integer ( int64 ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_int64","tags":"","url":"proc/scramble_array_int64.html"},{"title":"scramble_array_sp – PIC","text":"private  subroutine scramble_array_sp(array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (:) Called by proc~~scramble_array_sp~~CalledByGraph proc~scramble_array_sp scramble_array_sp interface~pic_scramble_array pic_scramble_array interface~pic_scramble_array->proc~scramble_array_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: i integer(kind=int32), private :: j integer(kind=int32), private :: n real(kind=sp), private :: rand_val real(kind=sp), private :: temp Source Code subroutine scramble_array_sp ( array ) real ( sp ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n real ( sp ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_sp","tags":"","url":"proc/scramble_array_sp.html"},{"title":"set_brackets – PIC","text":"private  subroutine set_brackets(format_type, open_bracket, close_bracket) Set brackets based on output format type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: format_type character(len=1), intent(out) :: open_bracket character(len=1), intent(out) :: close_bracket Calls proc~~set_brackets~~CallsGraph proc~set_brackets set_brackets to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_brackets~~CalledByGraph proc~set_brackets set_brackets proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->proc~set_brackets interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->proc~set_brackets proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->proc~set_brackets proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->proc~set_brackets proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->proc~set_brackets proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->proc~set_brackets proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->proc~set_brackets proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->proc~set_brackets proc~print_vector_dp print_vector_dp proc~print_vector_dp->proc~set_brackets proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->proc~set_brackets proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->proc~set_brackets proc~print_vector_sp print_vector_sp proc~print_vector_sp->proc~set_brackets interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_brackets ( format_type , open_bracket , close_bracket ) !! Set brackets based on output format type character ( len =* ), intent ( in ) :: format_type character ( len = 1 ), intent ( out ) :: open_bracket , close_bracket select case ( trim ( to_upper ( adjustl ( format_type )))) case ( \"NUMPY\" ) open_bracket = \"[\" close_bracket = \"]\" case ( \"MATHEMATICA\" ) open_bracket = \"{\" close_bracket = \"}\" case ( \"PLAIN\" ) open_bracket = \"[\" close_bracket = \"]\" case default print * , \"Warning: Unsupported format type '\" // trim ( format_type ) // \"'. Defaulting to NumPy style.\" open_bracket = \"[\" close_bracket = \"]\" end select end subroutine set_brackets","tags":"","url":"proc/set_brackets.html"},{"title":"set_threading_mode_ – PIC","text":"private  subroutine set_threading_mode_(threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Usage: call set_threading(.true.) or call set_threading(.false.) Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded Called by proc~~set_threading_mode_~~CalledByGraph proc~set_threading_mode_ set_threading_mode_ interface~set_threading_mode set_threading_mode interface~set_threading_mode->proc~set_threading_mode_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_threading_mode_ ( threaded ) !! set the threading mode for the array routines, this will set the use_threaded variable !! to true or false depending on the input !! !! Usage: call set_threading(.true.) or call set_threading(.false.) logical , intent ( in ) :: threaded use_threaded_default = threaded end subroutine set_threading_mode_","tags":"","url":"proc/set_threading_mode_.html"},{"title":"transpose_matrix_dp – PIC","text":"private  subroutine transpose_matrix_dp(A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Calls proc~~transpose_matrix_dp~~CallsGraph proc~transpose_matrix_dp transpose_matrix_dp interface~pic_optional pic_optional proc~transpose_matrix_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_matrix_dp~~CalledByGraph proc~transpose_matrix_dp transpose_matrix_dp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_dp ( A , B , threaded ) real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_dp","tags":"","url":"proc/transpose_matrix_dp.html"},{"title":"transpose_matrix_int32 – PIC","text":"private  subroutine transpose_matrix_int32(A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Calls proc~~transpose_matrix_int32~~CallsGraph proc~transpose_matrix_int32 transpose_matrix_int32 interface~pic_optional pic_optional proc~transpose_matrix_int32->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_matrix_int32~~CalledByGraph proc~transpose_matrix_int32 transpose_matrix_int32 interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_int32 ( A , B , threaded ) integer ( int32 ), intent ( in ) :: A (:, :) integer ( int32 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int32","tags":"","url":"proc/transpose_matrix_int32.html"},{"title":"transpose_matrix_int64 – PIC","text":"private  subroutine transpose_matrix_int64(A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Calls proc~~transpose_matrix_int64~~CallsGraph proc~transpose_matrix_int64 transpose_matrix_int64 interface~pic_optional pic_optional proc~transpose_matrix_int64->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_matrix_int64~~CalledByGraph proc~transpose_matrix_int64 transpose_matrix_int64 interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_int64 ( A , B , threaded ) integer ( int64 ), intent ( in ) :: A (:, :) integer ( int64 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int64","tags":"","url":"proc/transpose_matrix_int64.html"},{"title":"transpose_matrix_sp – PIC","text":"private  subroutine transpose_matrix_sp(A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Calls proc~~transpose_matrix_sp~~CallsGraph proc~transpose_matrix_sp transpose_matrix_sp interface~pic_optional pic_optional proc~transpose_matrix_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~transpose_matrix_sp~~CalledByGraph proc~transpose_matrix_sp transpose_matrix_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_sp ( A , B , threaded ) real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_sp","tags":"","url":"proc/transpose_matrix_sp.html"},{"title":"get_threading_mode – PIC","text":"public interface get_threading_mode get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() Calls interface~~get_threading_mode~~CallsGraph interface~get_threading_mode get_threading_mode proc~get_threading_mode_ get_threading_mode_ interface~get_threading_mode->proc~get_threading_mode_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function get_threading_mode_ () result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical","tags":"","url":"interface/get_threading_mode.html"},{"title":"is_sorted – PIC","text":"public interface is_sorted is_sorted provides a simple way to checking if a 1d array is sorted\nit is implemented for int32, int64, sp, and dp datatypes. The default\nis to check if an array is sorted in ascending fashion. Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) Calls interface~~is_sorted~~CallsGraph interface~is_sorted is_sorted proc~is_sorted_char is_sorted_char interface~is_sorted->proc~is_sorted_char proc~is_sorted_dp is_sorted_dp interface~is_sorted->proc~is_sorted_dp proc~is_sorted_int32 is_sorted_int32 interface~is_sorted->proc~is_sorted_int32 proc~is_sorted_int64 is_sorted_int64 interface~is_sorted->proc~is_sorted_int64 proc~is_sorted_sp is_sorted_sp interface~is_sorted->proc~is_sorted_sp interface~pic_optional pic_optional proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_char (array, order) result(sorted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical","tags":"","url":"interface/is_sorted.html"},{"title":"pic_copy – PIC","text":"public interface pic_copy copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy\nif you built pic with BLAS use the copy interface provided there, I will not beat BLAS\ncopy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types Usage: call pic_copy(destination, source, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Calls interface~~pic_copy~~CallsGraph interface~pic_copy pic_copy proc~copy_3d_tensor_dp copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_dp proc~copy_3d_tensor_int32 copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int32 proc~copy_3d_tensor_int64 copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_int64 proc~copy_3d_tensor_sp copy_3d_tensor_sp interface~pic_copy->proc~copy_3d_tensor_sp proc~copy_matrix_dp copy_matrix_dp interface~pic_copy->proc~copy_matrix_dp proc~copy_matrix_int32 copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int32 proc~copy_matrix_int64 copy_matrix_int64 interface~pic_copy->proc~copy_matrix_int64 proc~copy_matrix_sp copy_matrix_sp interface~pic_copy->proc~copy_matrix_sp proc~copy_vector_dp copy_vector_dp interface~pic_copy->proc~copy_vector_dp proc~copy_vector_int32 copy_vector_int32 interface~pic_copy->proc~copy_vector_int32 proc~copy_vector_int64 copy_vector_int64 interface~pic_copy->proc~copy_vector_int64 proc~copy_vector_sp copy_vector_sp interface~pic_copy->proc~copy_vector_sp interface~pic_optional pic_optional proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:,:) integer(kind=int32), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:,:) integer(kind=int64), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:,:) real(kind=sp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:,:) real(kind=dp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded","tags":"","url":"interface/pic_copy.html"},{"title":"pic_fill – PIC","text":"public interface pic_fill fill provides a generic interface to assing a value\nalpha of types (int32, int64, sp, dp) as defined in pic_types.F90\nThe inteface supports filling 1d and 2d arrays of the specified\nvariables Usage: call pic_fill(array, value, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Calls interface~~pic_fill~~CallsGraph interface~pic_fill pic_fill proc~fill_3d_tensor_dp fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_dp proc~fill_3d_tensor_int32 fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int32 proc~fill_3d_tensor_int64 fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_int64 proc~fill_3d_tensor_sp fill_3d_tensor_sp interface~pic_fill->proc~fill_3d_tensor_sp proc~fill_matrix_dp fill_matrix_dp interface~pic_fill->proc~fill_matrix_dp proc~fill_matrix_int32 fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int32 proc~fill_matrix_int64 fill_matrix_int64 interface~pic_fill->proc~fill_matrix_int64 proc~fill_matrix_sp fill_matrix_sp interface~pic_fill->proc~fill_matrix_sp proc~fill_vector_dp fill_vector_dp interface~pic_fill->proc~fill_vector_dp proc~fill_vector_int32 fill_vector_int32 interface~pic_fill->proc~fill_vector_int32 proc~fill_vector_int64 fill_vector_int64 interface~pic_fill->proc~fill_vector_int64 proc~fill_vector_sp fill_vector_sp interface~pic_fill->proc~fill_vector_sp interface~pic_optional pic_optional proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int32 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: tensor (:,:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int64 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: tensor (:,:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_sp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: tensor (:,:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_dp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (:,:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded","tags":"","url":"interface/pic_fill.html"},{"title":"pic_print_array – PIC","text":"public interface pic_print_array Generic interface for printing arrays of different types Usage: call pic_print_array(array, [optional] format)\nWhere format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) Implemented types are: array(:)   -> int32, int64, sp, dp array(:,:) -> int32, int64, sp, dp array(:) (packed matrix) -> sp, dp array(:,:,:) -> sp, dp Calls interface~~pic_print_array~~CallsGraph interface~pic_print_array pic_print_array proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~pic_print_array->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~pic_print_array->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~pic_print_array->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~pic_print_array->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~pic_print_array->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~pic_print_array->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~pic_print_array->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~pic_print_array->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp->interface~pic_print_array interface~pic_optional pic_optional proc~print_3d_tensor_dp->interface~pic_optional proc~set_brackets set_brackets proc~print_3d_tensor_dp->proc~set_brackets proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->proc~set_brackets proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->proc~set_brackets proc~print_3d_tensor_sp->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->proc~set_brackets proc~print_matrix_dp->interface~pic_optional interface~to_char to_char proc~print_matrix_dp->interface~to_char proc~print_matrix_dp->proc~set_brackets proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int32->interface~to_char proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int64->interface~pic_optional proc~print_matrix_int64->interface~to_char proc~print_matrix_int64->proc~set_brackets proc~print_matrix_sp->interface~pic_optional proc~print_matrix_sp->interface~to_char proc~print_matrix_sp->proc~set_brackets proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_sp->interface~pic_optional proc~print_packed_matrix_sp->interface~to_char proc~print_packed_matrix_sp->proc~set_brackets proc~print_vector_dp->interface~pic_optional proc~print_vector_dp->interface~to_char proc~print_vector_dp->proc~set_brackets proc~print_vector_int32->interface~pic_optional proc~print_vector_int32->interface~to_char proc~print_vector_int32->proc~set_brackets proc~print_vector_int64->interface~pic_optional proc~print_vector_int64->interface~to_char proc~print_vector_int64->proc~set_brackets proc~print_vector_sp->interface~pic_optional proc~print_vector_sp->interface~to_char proc~print_vector_sp->proc~set_brackets proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~pic_print_array~~CalledByGraph interface~pic_print_array pic_print_array proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine print_vector_int32 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int32 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int64 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/pic_print_array.html"},{"title":"pic_scramble_array – PIC","text":"public interface pic_scramble_array Calls interface~~pic_scramble_array~~CallsGraph interface~pic_scramble_array pic_scramble_array proc~scramble_array_character scramble_array_character interface~pic_scramble_array->proc~scramble_array_character proc~scramble_array_dp scramble_array_dp interface~pic_scramble_array->proc~scramble_array_dp proc~scramble_array_int32 scramble_array_int32 interface~pic_scramble_array->proc~scramble_array_int32 proc~scramble_array_int64 scramble_array_int64 interface~pic_scramble_array->proc~scramble_array_int64 proc~scramble_array_sp scramble_array_sp interface~pic_scramble_array->proc~scramble_array_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine scramble_array_int32 (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (:) private  subroutine scramble_array_int64 (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (:) private  subroutine scramble_array_sp (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (:) private  subroutine scramble_array_dp (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (:) private  subroutine scramble_array_character (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (:)","tags":"","url":"interface/pic_scramble_array.html"},{"title":"pic_sum – PIC","text":"public interface pic_sum pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will\nbe too slow for large sizes of vectors and matrices. Note that this provides the total\nsum. As opposed to the blas alternative XASUM which does the absolute sum pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays Usage: result = pic_sum(array, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Calls interface~~pic_sum~~CallsGraph interface~pic_sum pic_sum proc~sum_3d_tensor_dp sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_dp proc~sum_3d_tensor_int32 sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int32 proc~sum_3d_tensor_int64 sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_int64 proc~sum_3d_tensor_sp sum_3d_tensor_sp interface~pic_sum->proc~sum_3d_tensor_sp proc~sum_matrix_dp sum_matrix_dp interface~pic_sum->proc~sum_matrix_dp proc~sum_matrix_int32 sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int32 proc~sum_matrix_int64 sum_matrix_int64 interface~pic_sum->proc~sum_matrix_int64 proc~sum_matrix_sp sum_matrix_sp interface~pic_sum->proc~sum_matrix_sp proc~sum_vector_dp sum_vector_dp interface~pic_sum->proc~sum_vector_dp proc~sum_vector_int32 sum_vector_int32 interface~pic_sum->proc~sum_vector_int32 proc~sum_vector_int64 sum_vector_int64 interface~pic_sum->proc~sum_vector_int64 proc~sum_vector_sp sum_vector_sp interface~pic_sum->proc~sum_vector_sp interface~pic_optional pic_optional proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_3d_tensor_int32 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_3d_tensor_int64 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_3d_tensor_sp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_3d_tensor_dp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp)","tags":"","url":"interface/pic_sum.html"},{"title":"pic_transpose – PIC","text":"public interface pic_transpose pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic\nwhich will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Calls interface~~pic_transpose~~CallsGraph interface~pic_transpose pic_transpose proc~transpose_matrix_dp transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_dp proc~transpose_matrix_int32 transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int32 proc~transpose_matrix_int64 transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_int64 proc~transpose_matrix_sp transpose_matrix_sp interface~pic_transpose->proc~transpose_matrix_sp interface~pic_optional pic_optional proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded","tags":"","url":"interface/pic_transpose.html"},{"title":"set_threading_mode – PIC","text":"public interface set_threading_mode set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) Calls interface~~set_threading_mode~~CallsGraph interface~set_threading_mode set_threading_mode proc~set_threading_mode_ set_threading_mode_ interface~set_threading_mode->proc~set_threading_mode_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine set_threading_mode_ (threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded","tags":"","url":"interface/set_threading_mode.html"},{"title":"dp_radix_sort – PIC","text":"private module subroutine dp_radix_sort(array, work, reverse) Uses iso_c_binding proc~~dp_radix_sort~~UsesGraph proc~dp_radix_sort dp_radix_sort iso_c_binding iso_c_binding proc~dp_radix_sort->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:), target :: array real(kind=dp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse Calls proc~~dp_radix_sort~~CallsGraph proc~dp_radix_sort dp_radix_sort interface~pic_optional pic_optional proc~dp_radix_sort->interface~pic_optional proc~radix_sort_u64_helper radix_sort_u64_helper proc~dp_radix_sort->proc~radix_sort_u64_helper proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: N integer(kind=int64), private, dimension(:), pointer :: arri64 integer(kind=int64), private, dimension(:), pointer :: buffer integer(kind=int_index), private :: i real(kind=dp), private :: item integer(kind=int_index), private :: pos integer(kind=int_index), private :: rev_pos logical, private :: use_internal_buffer Source Code module subroutine dp_radix_sort ( array , work , reverse ) implicit none real ( kind = dp ), dimension (:), intent ( inout ), target :: array real ( kind = dp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine dp_radix_sort","tags":"","url":"proc/dp_radix_sort.html"},{"title":"int32_radix_sort – PIC","text":"private pure module subroutine int32_radix_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: array integer(kind=int32), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse Calls proc~~int32_radix_sort~~CallsGraph proc~int32_radix_sort int32_radix_sort interface~pic_optional pic_optional proc~int32_radix_sort->interface~pic_optional proc~radix_sort_u32_helper radix_sort_u32_helper proc~int32_radix_sort->proc~radix_sort_u32_helper proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: N integer(kind=int32), private, dimension(:), pointer :: buffer integer(kind=int_index), private :: end integer(kind=int_index), private :: i integer(kind=int32), private :: item integer(kind=int_index), private :: middle integer(kind=int_index), private :: start logical, private :: use_internal_buffer Source Code pure module subroutine int32_radix_sort ( array , work , reverse ) implicit none integer ( kind = int32 ), dimension (:), intent ( inout ) :: array integer ( kind = int32 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine int32_radix_sort","tags":"","url":"proc/int32_radix_sort.html"},{"title":"int64_radix_sort – PIC","text":"private pure module subroutine int64_radix_sort(array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: array integer(kind=int64), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse Calls proc~~int64_radix_sort~~CallsGraph proc~int64_radix_sort int64_radix_sort interface~pic_optional pic_optional proc~int64_radix_sort->interface~pic_optional proc~radix_sort_u64_helper radix_sort_u64_helper proc~int64_radix_sort->proc~radix_sort_u64_helper proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: N integer(kind=int64), private, dimension(:), pointer :: buffer integer(kind=int_index), private :: end integer(kind=int_index), private :: i integer(kind=int64), private :: item integer(kind=int_index), private :: middle integer(kind=int_index), private :: start logical, private :: use_internal_buffer Source Code pure module subroutine int64_radix_sort ( array , work , reverse ) implicit none integer ( kind = int64 ), dimension (:), intent ( inout ) :: array integer ( kind = int64 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine int64_radix_sort","tags":"","url":"proc/int64_radix_sort.html"},{"title":"radix_sort_u32_helper – PIC","text":"private pure subroutine radix_sort_u32_helper(N, arr, buf) Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: N integer(kind=int32), intent(inout), dimension(N) :: arr integer(kind=int32), intent(inout), dimension(N) :: buf Called by proc~~radix_sort_u32_helper~~CalledByGraph proc~radix_sort_u32_helper radix_sort_u32_helper proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->proc~radix_sort_u32_helper proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->proc~radix_sort_u32_helper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: b integer, private :: b0 integer, private :: b1 integer, private :: b2 integer, private :: b3 integer(kind=int_index), private, dimension(0:radix_mask) :: c0 integer(kind=int_index), private, dimension(0:radix_mask) :: c1 integer(kind=int_index), private, dimension(0:radix_mask) :: c2 integer(kind=int_index), private, dimension(0:radix_mask) :: c3 integer(kind=int_index), private :: i Source Code pure subroutine radix_sort_u32_helper ( N , arr , buf ) integer ( kind = int_index ), intent ( in ) :: N integer ( kind = int32 ), dimension ( N ), intent ( inout ) :: arr integer ( kind = int32 ), dimension ( N ), intent ( inout ) :: buf integer ( kind = int_index ) :: i integer :: b , b0 , b1 , b2 , b3 integer ( kind = int_index ), dimension ( 0 : radix_mask ) :: c0 , c1 , c2 , c3 c0 (:) = 0 c1 (:) = 0 c2 (:) = 0 c3 (:) = 0 do i = 1 , N b0 = iand ( arr ( i ), radix_mask_i32 ) b1 = iand ( ishft ( arr ( i ), - radix_bits_i32 ), radix_mask_i32 ) b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i32 ), radix_mask_i32 ) b3 = ishft ( arr ( i ), - 3 * radix_bits_i32 ) c0 ( b0 ) = c0 ( b0 ) + 1 c1 ( b1 ) = c1 ( b1 ) + 1 c2 ( b2 ) = c2 ( b2 ) + 1 c3 ( b3 ) = c3 ( b3 ) + 1 end do do b = 1 , radix_mask c0 ( b ) = c0 ( b ) + c0 ( b - 1 ) c1 ( b ) = c1 ( b ) + c1 ( b - 1 ) c2 ( b ) = c2 ( b ) + c2 ( b - 1 ) c3 ( b ) = c3 ( b ) + c3 ( b - 1 ) end do do i = N , 1 , - 1 b0 = iand ( arr ( i ), radix_mask_i32 ) buf ( c0 ( b0 )) = arr ( i ) c0 ( b0 ) = c0 ( b0 ) - 1 end do do i = N , 1 , - 1 b1 = iand ( ishft ( buf ( i ), - radix_bits_i32 ), radix_mask_i32 ) arr ( c1 ( b1 )) = buf ( i ) c1 ( b1 ) = c1 ( b1 ) - 1 end do do i = N , 1 , - 1 b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i32 ), radix_mask_i32 ) buf ( c2 ( b2 )) = arr ( i ) c2 ( b2 ) = c2 ( b2 ) - 1 end do do i = N , 1 , - 1 b3 = ishft ( buf ( i ), - 3 * radix_bits_i32 ) arr ( c3 ( b3 )) = buf ( i ) c3 ( b3 ) = c3 ( b3 ) - 1 end do end subroutine radix_sort_u32_helper","tags":"","url":"proc/radix_sort_u32_helper.html"},{"title":"radix_sort_u64_helper – PIC","text":"private pure subroutine radix_sort_u64_helper(N, arr, buffer) Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: N integer(kind=int64), intent(inout), dimension(N) :: arr integer(kind=int64), intent(inout), dimension(N) :: buffer Called by proc~~radix_sort_u64_helper~~CalledByGraph proc~radix_sort_u64_helper radix_sort_u64_helper proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->proc~radix_sort_u64_helper proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->proc~radix_sort_u64_helper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: b integer(kind=int64), private :: b0 integer(kind=int64), private :: b1 integer(kind=int64), private :: b2 integer(kind=int64), private :: b3 integer(kind=int64), private :: b4 integer(kind=int64), private :: b5 integer(kind=int64), private :: b6 integer(kind=int64), private :: b7 integer(kind=int_index), private, dimension(0:radix_mask) :: c0 integer(kind=int_index), private, dimension(0:radix_mask) :: c1 integer(kind=int_index), private, dimension(0:radix_mask) :: c2 integer(kind=int_index), private, dimension(0:radix_mask) :: c3 integer(kind=int_index), private, dimension(0:radix_mask) :: c4 integer(kind=int_index), private, dimension(0:radix_mask) :: c5 integer(kind=int_index), private, dimension(0:radix_mask) :: c6 integer(kind=int_index), private, dimension(0:radix_mask) :: c7 integer(kind=int_index), private :: i Source Code pure subroutine radix_sort_u64_helper ( N , arr , buffer ) integer ( kind = int_index ), intent ( in ) :: N integer ( kind = int64 ), dimension ( N ), intent ( inout ) :: arr integer ( kind = int64 ), dimension ( N ), intent ( inout ) :: buffer integer ( kind = int_index ) :: i integer ( kind = int64 ) :: b , b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 integer ( kind = int_index ), dimension ( 0 : radix_mask ) :: c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 c0 (:) = 0 c1 (:) = 0 c2 (:) = 0 c3 (:) = 0 c4 (:) = 0 c5 (:) = 0 c6 (:) = 0 c7 (:) = 0 do i = 1 , N b0 = iand ( arr ( i ), radix_mask_i64 ) b1 = iand ( ishft ( arr ( i ), - radix_bits_i64 ), radix_mask_i64 ) b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i64 ), radix_mask_i64 ) b3 = iand ( ishft ( arr ( i ), - 3 * radix_bits_i64 ), radix_mask_i64 ) b4 = iand ( ishft ( arr ( i ), - 4 * radix_bits_i64 ), radix_mask_i64 ) b5 = iand ( ishft ( arr ( i ), - 5 * radix_bits_i64 ), radix_mask_i64 ) b6 = iand ( ishft ( arr ( i ), - 6 * radix_bits_i64 ), radix_mask_i64 ) b7 = ishft ( arr ( i ), - 7 * radix_bits_i64 ) c0 ( b0 ) = c0 ( b0 ) + 1 c1 ( b1 ) = c1 ( b1 ) + 1 c2 ( b2 ) = c2 ( b2 ) + 1 c3 ( b3 ) = c3 ( b3 ) + 1 c4 ( b4 ) = c4 ( b4 ) + 1 c5 ( b5 ) = c5 ( b5 ) + 1 c6 ( b6 ) = c6 ( b6 ) + 1 c7 ( b7 ) = c7 ( b7 ) + 1 end do do b = 1 , radix_mask c0 ( b ) = c0 ( b ) + c0 ( b - 1 ) c1 ( b ) = c1 ( b ) + c1 ( b - 1 ) c2 ( b ) = c2 ( b ) + c2 ( b - 1 ) c3 ( b ) = c3 ( b ) + c3 ( b - 1 ) c4 ( b ) = c4 ( b ) + c4 ( b - 1 ) c5 ( b ) = c5 ( b ) + c5 ( b - 1 ) c6 ( b ) = c6 ( b ) + c6 ( b - 1 ) c7 ( b ) = c7 ( b ) + c7 ( b - 1 ) end do do i = N , 1 , - 1 b0 = iand ( arr ( i ), radix_mask_i64 ) buffer ( c0 ( b0 )) = arr ( i ) c0 ( b0 ) = c0 ( b0 ) - 1 end do do i = N , 1 , - 1 b1 = iand ( ishft ( buffer ( i ), - radix_bits_i64 ), radix_mask_i64 ) arr ( c1 ( b1 )) = buffer ( i ) c1 ( b1 ) = c1 ( b1 ) - 1 end do do i = N , 1 , - 1 b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c2 ( b2 )) = arr ( i ) c2 ( b2 ) = c2 ( b2 ) - 1 end do do i = N , 1 , - 1 b3 = iand ( ishft ( buffer ( i ), - 3 * radix_bits_i64 ), radix_mask_i64 ) arr ( c3 ( b3 )) = buffer ( i ) c3 ( b3 ) = c3 ( b3 ) - 1 end do do i = N , 1 , - 1 b4 = iand ( ishft ( arr ( i ), - 4 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c4 ( b4 )) = arr ( i ) c4 ( b4 ) = c4 ( b4 ) - 1 end do do i = N , 1 , - 1 b5 = iand ( ishft ( buffer ( i ), - 5 * radix_bits_i64 ), radix_mask_i64 ) arr ( c5 ( b5 )) = buffer ( i ) c5 ( b5 ) = c5 ( b5 ) - 1 end do do i = N , 1 , - 1 b6 = iand ( ishft ( arr ( i ), - 6 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c6 ( b6 )) = arr ( i ) c6 ( b6 ) = c6 ( b6 ) - 1 end do do i = N , 1 , - 1 b7 = ishft ( buffer ( i ), - 7 * radix_bits_i64 ) arr ( c7 ( b7 )) = buffer ( i ) c7 ( b7 ) = c7 ( b7 ) - 1 end do end subroutine radix_sort_u64_helper","tags":"","url":"proc/radix_sort_u64_helper.html"},{"title":"sp_radix_sort – PIC","text":"private module subroutine sp_radix_sort(array, work, reverse) Uses iso_c_binding proc~~sp_radix_sort~~UsesGraph proc~sp_radix_sort sp_radix_sort iso_c_binding iso_c_binding proc~sp_radix_sort->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), dimension(:), target :: array real(kind=sp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse Calls proc~~sp_radix_sort~~CallsGraph proc~sp_radix_sort sp_radix_sort interface~pic_optional pic_optional proc~sp_radix_sort->interface~pic_optional proc~radix_sort_u32_helper radix_sort_u32_helper proc~sp_radix_sort->proc~radix_sort_u32_helper proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: N integer(kind=int32), private, dimension(:), pointer :: arri32 integer(kind=int32), private, dimension(:), pointer :: buffer integer(kind=int_index), private :: i real(kind=sp), private :: item integer(kind=int_index), private :: pos integer(kind=int_index), private :: rev_pos logical, private :: use_internal_buffer Source Code module subroutine sp_radix_sort ( array , work , reverse ) implicit none real ( kind = sp ), dimension (:), intent ( inout ), target :: array real ( kind = sp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine sp_radix_sort","tags":"","url":"proc/sp_radix_sort.html"},{"title":"radix_sort – PIC","text":"public interface radix_sort The generic subroutine interface implementing the LSD radix sort algorithm,\nsee https://en.wikipedia.org/wiki/Radix_sort for more details.\nIt is always O(N) in sorting random data, but need a O(N) buffer.\n( Specification ) Subroutines private module subroutine dp_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:), target :: array real(kind=dp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int32_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: array integer(kind=int32), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int64_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: array integer(kind=int64), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private module subroutine sp_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), dimension(:), target :: array real(kind=sp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse","tags":"","url":"interface/radix_sort.html"},{"title":"optional_char – PIC","text":"private pure function optional_char(input_value, default_value) result(output) Handle optional character(len=*) value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable Called by proc~~optional_char~~CalledByGraph proc~optional_char optional_char interface~pic_optional pic_optional interface~pic_optional->proc~optional_char proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_char ( input_value , default_value ) result ( output ) !! Handle optional character(len=*) value character ( len =* ), intent ( in ), optional :: input_value character ( len =* ), intent ( in ) :: default_value character ( len = :), allocatable :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_char","tags":"","url":"proc/optional_char.html"},{"title":"optional_dp – PIC","text":"private pure function optional_dp(input_value, default_value) result(output) Handle optional real(dp) value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) Called by proc~~optional_dp~~CalledByGraph proc~optional_dp optional_dp interface~pic_optional pic_optional interface~pic_optional->proc~optional_dp proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_dp ( input_value , default_value ) result ( output ) !! Handle optional real(dp) value real ( dp ), intent ( in ), optional :: input_value real ( dp ), intent ( in ) :: default_value real ( dp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_dp","tags":"","url":"proc/optional_dp.html"},{"title":"optional_int32 – PIC","text":"private pure function optional_int32(input_value, default_value) result(output) Handle optional integer(int32) value Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) Called by proc~~optional_int32~~CalledByGraph proc~optional_int32 optional_int32 interface~pic_optional pic_optional interface~pic_optional->proc~optional_int32 proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_int32 ( input_value , default_value ) result ( output ) !! Handle optional integer(int32) value integer ( int32 ), intent ( in ), optional :: input_value integer ( int32 ), intent ( in ) :: default_value integer ( int32 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int32","tags":"","url":"proc/optional_int32.html"},{"title":"optional_int64 – PIC","text":"private pure function optional_int64(input_value, default_value) result(output) Handle optional integer(int64) value Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) Called by proc~~optional_int64~~CalledByGraph proc~optional_int64 optional_int64 interface~pic_optional pic_optional interface~pic_optional->proc~optional_int64 proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_int64 ( input_value , default_value ) result ( output ) !! Handle optional integer(int64) value integer ( int64 ), intent ( in ), optional :: input_value integer ( int64 ), intent ( in ) :: default_value integer ( int64 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int64","tags":"","url":"proc/optional_int64.html"},{"title":"optional_logical – PIC","text":"private pure function optional_logical(input_value, default_value) result(output) Handle optional logical value Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: input_value logical, intent(in) :: default_value Return Value logical Called by proc~~optional_logical~~CalledByGraph proc~optional_logical optional_logical interface~pic_optional pic_optional interface~pic_optional->proc~optional_logical proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_logical ( input_value , default_value ) result ( output ) !! Handle optional logical value logical , intent ( in ), optional :: input_value logical , intent ( in ) :: default_value logical :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_logical","tags":"","url":"proc/optional_logical.html"},{"title":"optional_sp – PIC","text":"private pure function optional_sp(input_value, default_value) result(output) Handle optional real(sp) value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) Called by proc~~optional_sp~~CalledByGraph proc~optional_sp optional_sp interface~pic_optional pic_optional interface~pic_optional->proc~optional_sp proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_sp ( input_value , default_value ) result ( output ) !! Handle optional real(sp) value real ( sp ), intent ( in ), optional :: input_value real ( sp ), intent ( in ) :: default_value real ( sp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_sp","tags":"","url":"proc/optional_sp.html"},{"title":"pic_optional – PIC","text":"public interface pic_optional Overloaded interface for optional value retrieval, supported types are:\n- integer(int32), integer(int64), real(sp), real(dp), character(len=*), logical Calls interface~~pic_optional~~CallsGraph interface~pic_optional pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~pic_optional~~CalledByGraph interface~pic_optional pic_optional proc~char_ord_sort char_ord_sort proc~char_ord_sort->interface~pic_optional proc~char_sort char_sort proc~char_sort->interface~pic_optional proc~char_sort_index_default char_sort_index_default proc~char_sort_index_default->interface~pic_optional proc~char_sort_index_low char_sort_index_low proc~char_sort_index_low->interface~pic_optional proc~copy_3d_tensor_dp copy_3d_tensor_dp proc~copy_3d_tensor_dp->interface~pic_optional proc~copy_3d_tensor_int32 copy_3d_tensor_int32 proc~copy_3d_tensor_int32->interface~pic_optional proc~copy_3d_tensor_int64 copy_3d_tensor_int64 proc~copy_3d_tensor_int64->interface~pic_optional proc~copy_3d_tensor_sp copy_3d_tensor_sp proc~copy_3d_tensor_sp->interface~pic_optional proc~copy_matrix_dp copy_matrix_dp proc~copy_matrix_dp->interface~pic_optional proc~copy_matrix_int32 copy_matrix_int32 proc~copy_matrix_int32->interface~pic_optional proc~copy_matrix_int64 copy_matrix_int64 proc~copy_matrix_int64->interface~pic_optional proc~copy_matrix_sp copy_matrix_sp proc~copy_matrix_sp->interface~pic_optional proc~copy_vector_dp copy_vector_dp proc~copy_vector_dp->interface~pic_optional proc~copy_vector_int32 copy_vector_int32 proc~copy_vector_int32->interface~pic_optional proc~copy_vector_int64 copy_vector_int64 proc~copy_vector_int64->interface~pic_optional proc~copy_vector_sp copy_vector_sp proc~copy_vector_sp->interface~pic_optional proc~count_char_char count_char_char proc~count_char_char->interface~pic_optional proc~dp_ord_sort dp_ord_sort proc~dp_ord_sort->interface~pic_optional proc~dp_radix_sort dp_radix_sort proc~dp_radix_sort->interface~pic_optional proc~dp_sort dp_sort proc~dp_sort->interface~pic_optional proc~dp_sort_index_default dp_sort_index_default proc~dp_sort_index_default->interface~pic_optional proc~dp_sort_index_low dp_sort_index_low proc~dp_sort_index_low->interface~pic_optional proc~fill_3d_tensor_dp fill_3d_tensor_dp proc~fill_3d_tensor_dp->interface~pic_optional proc~fill_3d_tensor_int32 fill_3d_tensor_int32 proc~fill_3d_tensor_int32->interface~pic_optional proc~fill_3d_tensor_int64 fill_3d_tensor_int64 proc~fill_3d_tensor_int64->interface~pic_optional proc~fill_3d_tensor_sp fill_3d_tensor_sp proc~fill_3d_tensor_sp->interface~pic_optional proc~fill_matrix_dp fill_matrix_dp proc~fill_matrix_dp->interface~pic_optional proc~fill_matrix_int32 fill_matrix_int32 proc~fill_matrix_int32->interface~pic_optional proc~fill_matrix_int64 fill_matrix_int64 proc~fill_matrix_int64->interface~pic_optional proc~fill_matrix_sp fill_matrix_sp proc~fill_matrix_sp->interface~pic_optional proc~fill_vector_dp fill_vector_dp proc~fill_vector_dp->interface~pic_optional proc~fill_vector_int32 fill_vector_int32 proc~fill_vector_int32->interface~pic_optional proc~fill_vector_int64 fill_vector_int64 proc~fill_vector_int64->interface~pic_optional proc~fill_vector_sp fill_vector_sp proc~fill_vector_sp->interface~pic_optional proc~find_char_char find_char_char proc~find_char_char->interface~pic_optional proc~index_char_string index_char_string proc~index_char_string->interface~pic_optional proc~index_string_char index_string_char proc~index_string_char->interface~pic_optional proc~index_string_string index_string_string proc~index_string_string->interface~pic_optional proc~int32_ord_sort int32_ord_sort proc~int32_ord_sort->interface~pic_optional proc~int32_radix_sort int32_radix_sort proc~int32_radix_sort->interface~pic_optional proc~int32_sort int32_sort proc~int32_sort->interface~pic_optional proc~int32_sort_index_default int32_sort_index_default proc~int32_sort_index_default->interface~pic_optional proc~int32_sort_index_low int32_sort_index_low proc~int32_sort_index_low->interface~pic_optional proc~int64_ord_sort int64_ord_sort proc~int64_ord_sort->interface~pic_optional proc~int64_radix_sort int64_radix_sort proc~int64_radix_sort->interface~pic_optional proc~int64_sort int64_sort proc~int64_sort->interface~pic_optional proc~int64_sort_index_default int64_sort_index_default proc~int64_sort_index_default->interface~pic_optional proc~int64_sort_index_low int64_sort_index_low proc~int64_sort_index_low->interface~pic_optional proc~is_sorted_char is_sorted_char proc~is_sorted_char->interface~pic_optional proc~is_sorted_dp is_sorted_dp proc~is_sorted_dp->interface~pic_optional proc~is_sorted_int32 is_sorted_int32 proc~is_sorted_int32->interface~pic_optional proc~is_sorted_int64 is_sorted_int64 proc~is_sorted_int64->interface~pic_optional proc~is_sorted_sp is_sorted_sp proc~is_sorted_sp->interface~pic_optional proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->interface~pic_optional interface~pic_print_array pic_print_array proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32 print_3d_tensor_int32 proc~print_3d_tensor_int32->interface~pic_optional proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64 print_3d_tensor_int64 proc~print_3d_tensor_int64->interface~pic_optional proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->interface~pic_optional proc~print_3d_tensor_sp->interface~pic_print_array proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~pic_optional proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~pic_optional proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~pic_optional proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~pic_optional proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~pic_optional proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~pic_optional proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~pic_optional proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~pic_optional proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~pic_optional proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~pic_optional proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~pic_optional proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~pic_optional proc~scan_char_string scan_char_string proc~scan_char_string->interface~pic_optional proc~scan_string_char scan_string_char proc~scan_string_char->interface~pic_optional proc~scan_string_string scan_string_string proc~scan_string_string->interface~pic_optional proc~sp_ord_sort sp_ord_sort proc~sp_ord_sort->interface~pic_optional proc~sp_radix_sort sp_radix_sort proc~sp_radix_sort->interface~pic_optional proc~sp_sort sp_sort proc~sp_sort->interface~pic_optional proc~sp_sort_index_default sp_sort_index_default proc~sp_sort_index_default->interface~pic_optional proc~sp_sort_index_low sp_sort_index_low proc~sp_sort_index_low->interface~pic_optional proc~sum_3d_tensor_dp sum_3d_tensor_dp proc~sum_3d_tensor_dp->interface~pic_optional proc~sum_3d_tensor_int32 sum_3d_tensor_int32 proc~sum_3d_tensor_int32->interface~pic_optional proc~sum_3d_tensor_int64 sum_3d_tensor_int64 proc~sum_3d_tensor_int64->interface~pic_optional proc~sum_3d_tensor_sp sum_3d_tensor_sp proc~sum_3d_tensor_sp->interface~pic_optional proc~sum_matrix_dp sum_matrix_dp proc~sum_matrix_dp->interface~pic_optional proc~sum_matrix_int32 sum_matrix_int32 proc~sum_matrix_int32->interface~pic_optional proc~sum_matrix_int64 sum_matrix_int64 proc~sum_matrix_int64->interface~pic_optional proc~sum_matrix_sp sum_matrix_sp proc~sum_matrix_sp->interface~pic_optional proc~sum_vector_dp sum_vector_dp proc~sum_vector_dp->interface~pic_optional proc~sum_vector_int32 sum_vector_int32 proc~sum_vector_int32->interface~pic_optional proc~sum_vector_int64 sum_vector_int64 proc~sum_vector_int64->interface~pic_optional proc~sum_vector_sp sum_vector_sp proc~sum_vector_sp->interface~pic_optional proc~to_string_r_dp to_string_r_dp proc~to_string_r_dp->interface~pic_optional proc~to_string_r_sp to_string_r_sp proc~to_string_r_sp->interface~pic_optional proc~transpose_matrix_dp transpose_matrix_dp proc~transpose_matrix_dp->interface~pic_optional proc~transpose_matrix_int32 transpose_matrix_int32 proc~transpose_matrix_int32->interface~pic_optional proc~transpose_matrix_int64 transpose_matrix_int64 proc~transpose_matrix_int64->interface~pic_optional proc~transpose_matrix_sp transpose_matrix_sp proc~transpose_matrix_sp->interface~pic_optional proc~verify_char_string verify_char_string proc~verify_char_string->interface~pic_optional proc~verify_string_char verify_string_char proc~verify_string_char->interface~pic_optional proc~verify_string_string verify_string_string proc~verify_string_string->interface~pic_optional interface~count count interface~count->proc~count_char_char interface~find find interface~find->proc~find_char_char proc~find_char_string find_char_string interface~find->proc~find_char_string proc~find_string_char find_string_char interface~find->proc~find_string_char proc~find_string_string find_string_string interface~find->proc~find_string_string interface~index index interface~index->proc~index_char_string interface~index->proc~index_string_char interface~index->proc~index_string_string interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_char interface~is_sorted->proc~is_sorted_dp interface~is_sorted->proc~is_sorted_int32 interface~is_sorted->proc~is_sorted_int64 interface~is_sorted->proc~is_sorted_sp interface~pic_copy pic_copy interface~pic_copy->proc~copy_3d_tensor_dp interface~pic_copy->proc~copy_3d_tensor_int32 interface~pic_copy->proc~copy_3d_tensor_int64 interface~pic_copy->proc~copy_3d_tensor_sp interface~pic_copy->proc~copy_matrix_dp interface~pic_copy->proc~copy_matrix_int32 interface~pic_copy->proc~copy_matrix_int64 interface~pic_copy->proc~copy_matrix_sp interface~pic_copy->proc~copy_vector_dp interface~pic_copy->proc~copy_vector_int32 interface~pic_copy->proc~copy_vector_int64 interface~pic_copy->proc~copy_vector_sp interface~pic_fill pic_fill interface~pic_fill->proc~fill_3d_tensor_dp interface~pic_fill->proc~fill_3d_tensor_int32 interface~pic_fill->proc~fill_3d_tensor_int64 interface~pic_fill->proc~fill_3d_tensor_sp interface~pic_fill->proc~fill_matrix_dp interface~pic_fill->proc~fill_matrix_int32 interface~pic_fill->proc~fill_matrix_int64 interface~pic_fill->proc~fill_matrix_sp interface~pic_fill->proc~fill_vector_dp interface~pic_fill->proc~fill_vector_int32 interface~pic_fill->proc~fill_vector_int64 interface~pic_fill->proc~fill_vector_sp interface~pic_print_array->proc~print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_sp interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_3d_tensor_dp interface~pic_sum->proc~sum_3d_tensor_int32 interface~pic_sum->proc~sum_3d_tensor_int64 interface~pic_sum->proc~sum_3d_tensor_sp interface~pic_sum->proc~sum_matrix_dp interface~pic_sum->proc~sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int64 interface~pic_sum->proc~sum_matrix_sp interface~pic_sum->proc~sum_vector_dp interface~pic_sum->proc~sum_vector_int32 interface~pic_sum->proc~sum_vector_int64 interface~pic_sum->proc~sum_vector_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_sp interface~scan scan interface~scan->proc~scan_char_string interface~scan->proc~scan_string_char interface~scan->proc~scan_string_string interface~verify verify interface~verify->proc~verify_char_string interface~verify->proc~verify_string_char interface~verify->proc~verify_string_string proc~find_char_string->interface~find proc~find_string_char->interface~find proc~find_string_string->interface~find Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function optional_int32 (input_value, default_value) result(output) Handle optional integer(int32) value Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Handle optional integer(int64) value Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_sp (input_value, default_value) result(output) Handle optional real(sp) value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) private pure function optional_dp (input_value, default_value) result(output) Handle optional real(dp) value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_char (input_value, default_value) result(output) Handle optional character(len=*) value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable private pure function optional_logical (input_value, default_value) result(output) Handle optional logical value Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: input_value logical, intent(in) :: default_value Return Value logical","tags":"","url":"interface/pic_optional.html"},{"title":"flop_rate_get_flop_rate – PIC","text":"private  function flop_rate_get_flop_rate(self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Usage: flop_rate = my_flop_rate%get_flop_rate() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) Calls proc~~flop_rate_get_flop_rate~~CallsGraph proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate->proc~get_flops proc~timer_get_elapsed_time timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~flop_rate_get_flop_rate~~CalledByGraph proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: flops real(kind=dp), private :: time Source Code function flop_rate_get_flop_rate ( self ) result ( flop_rate ) !! get the flop rate in GFLOP/s, this will calculate the flop rate based on the !! number of flops and the elapsed time !! !! Usage: flop_rate = my_flop_rate%get_flop_rate() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self real ( dp ) :: flop_rate real ( dp ) :: time integer ( int64 ) :: flops flops = self % m_flops % get () time = self % m_timer % get_elapsed_time () if ( time <= 0.0_dp ) then print * , \"Warning: Time is zero or negative, setting flop rate to zero.\" self % m_flop_rate = 0.0_dp flop_rate = 0.0_dp return else self % m_flop_rate = flops / time / 1.0e9_dp flop_rate = self % m_flop_rate end if end function flop_rate_get_flop_rate","tags":"","url":"proc/flop_rate_get_flop_rate.html"},{"title":"flop_rate_get_flops – PIC","text":"private  function flop_rate_get_flops(self) result(flops) get the number of flops recorded in the flop rate type Usage: flops = my_flop_rate%get_flops() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) Calls proc~~flop_rate_get_flops~~CallsGraph proc~flop_rate_get_flops flop_rate_type%flop_rate_get_flops proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flops->proc~get_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function flop_rate_get_flops ( self ) result ( flops ) !! get the number of flops recorded in the flop rate type !! !! Usage: flops = my_flop_rate%get_flops() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % m_flops % get () end function flop_rate_get_flops","tags":"","url":"proc/flop_rate_get_flops.html"},{"title":"flop_rate_get_time – PIC","text":"private  function flop_rate_get_time(self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Usage: time = my_flop_rate%get_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) Calls proc~~flop_rate_get_time~~CallsGraph proc~flop_rate_get_time flop_rate_type%flop_rate_get_time proc~timer_get_elapsed_time timer_type%timer_get_elapsed_time proc~flop_rate_get_time->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function flop_rate_get_time ( self ) result ( time ) !! get the elapsed time in seconds from the timer contained in the flop rate type !! !! Usage: time = my_flop_rate%get_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self real ( dp ) :: time time = self % m_timer % get_elapsed_time () end function flop_rate_get_time","tags":"","url":"proc/flop_rate_get_time.html"},{"title":"flop_rate_add_flops – PIC","text":"private  subroutine flop_rate_add_flops(self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops Calls proc~~flop_rate_add_flops~~CallsGraph proc~flop_rate_add_flops flop_rate_type%flop_rate_add_flops proc~add_flops flop_recorder_type%add_flops proc~flop_rate_add_flops->proc~add_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_add_flops ( self , flops ) !! add flops to the flop rate type, this will add the flops to the flop recorder !! Usage: call my_flop_rate%add_flops(1000) !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops call self % m_flops % add ( flops ) end subroutine flop_rate_add_flops","tags":"","url":"proc/flop_rate_add_flops.html"},{"title":"flop_rate_report – PIC","text":"private  subroutine flop_rate_report(self) report the flop rate, this will print the flop rate in GFLOP/s Usage: call my_flop_rate%report() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_report~~CallsGraph proc~flop_rate_report flop_rate_type%flop_rate_report interface~to_char to_char proc~flop_rate_report->interface~to_char proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_report->proc~flop_rate_get_flop_rate proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate->proc~get_flops proc~timer_get_elapsed_time timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_report ( self ) !! report the flop rate, this will print the flop rate in GFLOP/s !! !! Usage: call my_flop_rate%report() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self self % m_flop_rate = self % get_flop_rate () print * , \"Flop rate is \" // to_char ( self % m_flop_rate ) // \" GFLOP/s\" end subroutine flop_rate_report","tags":"","url":"proc/flop_rate_report.html"},{"title":"flop_rate_reset – PIC","text":"private  subroutine flop_rate_reset(self) reset the flop rate type, this will reset the timer and the flop recorder Usage: call my_flop_rate%reset() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_reset~~CallsGraph proc~flop_rate_reset flop_rate_type%flop_rate_reset proc~reset_flop_counter flop_recorder_type%reset_flop_counter proc~flop_rate_reset->proc~reset_flop_counter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_reset ( self ) !! reset the flop rate type, this will reset the timer and the flop recorder !! !! Usage: call my_flop_rate%reset() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_flops % reset () end subroutine flop_rate_reset","tags":"","url":"proc/flop_rate_reset.html"},{"title":"flop_rate_start_time – PIC","text":"private  subroutine flop_rate_start_time(self) Calls the start method for the timer contained in the flop rate type Usage: call my_flop_rate%start_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_start_time~~CallsGraph proc~flop_rate_start_time flop_rate_type%flop_rate_start_time proc~timer_start timer_type%timer_start proc~flop_rate_start_time->proc~timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_start_time ( self ) !! Calls the start method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%start_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % start () end subroutine flop_rate_start_time","tags":"","url":"proc/flop_rate_start_time.html"},{"title":"flop_rate_stop_time – PIC","text":"private  subroutine flop_rate_stop_time(self) Calls the stop method for the timer contained in the flop rate type Usage: call my_flop_rate%stop_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Source Code subroutine flop_rate_stop_time ( self ) !! Calls the stop method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%stop_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % stop () end subroutine flop_rate_stop_time","tags":"","url":"proc/flop_rate_stop_time.html"},{"title":"character_fnv_1 – PIC","text":"private elemental module function character_fnv_1(key) result(hash_code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) Source Code elemental module function character_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for default character string keys implicit none character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_code end function character_fnv_1","tags":"","url":"proc/character_fnv_1.html"},{"title":"character_fnv_1a – PIC","text":"private elemental module function character_fnv_1a(key) result(hash_code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) Source Code elemental module function character_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for default character string keys implicit none character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_value end function character_fnv_1a","tags":"","url":"proc/character_fnv_1a.html"},{"title":"int16_fnv_1 – PIC","text":"private pure module function int16_fnv_1(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int16_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int16 implicit none integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int16_fnv_1","tags":"","url":"proc/int16_fnv_1.html"},{"title":"int16_fnv_1a – PIC","text":"private pure module function int16_fnv_1a(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int16_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int16 implicit none integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int16_fnv_1a","tags":"","url":"proc/int16_fnv_1a.html"},{"title":"int32_fnv_1 – PIC","text":"private pure module function int32_fnv_1(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int32_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int32 implicit none integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int32_fnv_1","tags":"","url":"proc/int32_fnv_1.html"},{"title":"int32_fnv_1a – PIC","text":"private pure module function int32_fnv_1a(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int32_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int32 implicit none integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int32_fnv_1a","tags":"","url":"proc/int32_fnv_1a.html"},{"title":"int64_fnv_1 – PIC","text":"private pure module function int64_fnv_1(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int64_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int64 implicit none integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int64_fnv_1","tags":"","url":"proc/int64_fnv_1.html"},{"title":"int64_fnv_1a – PIC","text":"private pure module function int64_fnv_1a(key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) Source Code pure module function int64_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int64 implicit none integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int64_fnv_1a","tags":"","url":"proc/int64_fnv_1a.html"},{"title":"int8_fnv_1 – PIC","text":"private pure module function int8_fnv_1(key) result(hash_code) The original FNV-1 8-bit key algorithm. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash) Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i Source Code pure module function int8_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int8 implicit none integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int8_fnv_1","tags":"","url":"proc/int8_fnv_1.html"},{"title":"int8_fnv_1a – PIC","text":"private pure module function int8_fnv_1a(key) result(hash_code) The original FNV-1a 8-bit key algorithm. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash) Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: i Source Code pure module function int8_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int8 implicit none integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int8_fnv_1a","tags":"","url":"proc/int8_fnv_1a.html"},{"title":"fnv_1_hash – PIC","text":"public interface fnv_1_hash FNV_1 interfaces Functions private elemental module function character_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for default character string keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private pure module function int16_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int16 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int8 Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash)","tags":"","url":"interface/fnv_1_hash.html"},{"title":"fnv_1a_hash – PIC","text":"public interface fnv_1a_hash FNV_1A interfaces Functions private elemental module function character_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for default character string keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private pure module function int16_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int16 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int8 Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash)","tags":"","url":"interface/fnv_1a_hash.html"},{"title":"get_precision – PIC","text":"public  function get_precision() result(precision) Get the current precision for real numbers Arguments None Return Value integer(kind=default_int) Source Code function get_precision () result ( precision ) !! Get the current precision for real numbers integer ( default_int ) :: precision precision = dp_precision end function get_precision","tags":"","url":"proc/get_precision.html"},{"title":"pad – PIC","text":"public  function pad(s, width) result(padded) function to pad a string with a certain number of characters for nice printing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer(kind=default_int), intent(in) :: width Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: len_s Source Code function pad ( s , width ) result ( padded ) !! function to pad a string with a certain number of characters for nice printing character ( len =* ), intent ( in ) :: s integer ( default_int ), intent ( in ) :: width character ( len = :), allocatable :: padded integer ( default_int ) :: len_s len_s = len_trim ( s ) if ( len_s >= width ) then padded = s ( 1 : width ) else padded = repeat ( \" \" , width - len_s ) // s end if end function pad","tags":"","url":"proc/pad.html"},{"title":"to_upper – PIC","text":"public  function to_upper(str) result(upper_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Variables Type Visibility Attributes Name Initial character(len=1), private :: ch integer(kind=default_int), private :: i Source Code function to_upper ( str ) result ( upper_str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: upper_str integer ( default_int ) :: i character :: ch do i = 1 , len ( str ) ch = str ( i : i ) if ( ch >= 'a' . and . ch <= 'z' ) then upper_str ( i : i ) = char ( iachar ( ch ) - 32 ) else upper_str ( i : i ) = ch end if end do end function to_upper","tags":"","url":"proc/to_upper~2.html"},{"title":"to_char_char – PIC","text":"private  function to_char_char(c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable Called by proc~~to_char_char~~CalledByGraph proc~to_char_char to_char_char interface~to_char to_char interface~to_char->proc~to_char_char proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=500), private :: str Source Code function to_char_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_char_char","tags":"","url":"proc/to_char_char.html"},{"title":"to_char_dp – PIC","text":"private  function to_char_dp(r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable Called by proc~~to_char_dp~~CalledByGraph proc~to_char_dp to_char_dp interface~to_char to_char interface~to_char->proc~to_char_dp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str character(len=32), private :: style Source Code function to_char_dp ( r ) result ( trimmed_str ) !! transform a real(dp) to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_char_dp","tags":"","url":"proc/to_char_dp.html"},{"title":"to_char_int32 – PIC","text":"private  function to_char_int32(i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable Called by proc~~to_char_int32~~CalledByGraph proc~to_char_int32 to_char_int32 interface~to_char to_char interface~to_char->proc~to_char_int32 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str Source Code function to_char_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_char_int32","tags":"","url":"proc/to_char_int32.html"},{"title":"to_char_int64 – PIC","text":"private  function to_char_int64(i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable Called by proc~~to_char_int64~~CalledByGraph proc~to_char_int64 to_char_int64 interface~to_char to_char interface~to_char->proc~to_char_int64 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str Source Code function to_char_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_char_int64","tags":"","url":"proc/to_char_int64.html"},{"title":"to_char_logical – PIC","text":"private  function to_char_logical(l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable Called by proc~~to_char_logical~~CalledByGraph proc~to_char_logical to_char_logical interface~to_char to_char interface~to_char->proc~to_char_logical proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=5), private :: str Source Code function to_char_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = \"TRUE\" else str = \"FALSE\" end if trimmed_str = trim ( str ) end function to_char_logical","tags":"","url":"proc/to_char_logical.html"},{"title":"to_char_matrix_dp – PIC","text":"private  function to_char_matrix_dp(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:,:) Return Value character(len=:), allocatable Called by proc~~to_char_matrix_dp~~CalledByGraph proc~to_char_matrix_dp to_char_matrix_dp interface~to_char to_char interface~to_char->proc~to_char_matrix_dp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: ncols integer, private :: nrows character(len=32), private :: style character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_matrix_dp ( array ) result ( trimmed_str ) real ( kind = dp ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' ! Estimate total length needed (rough estimate) total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , style ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , style ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_dp","tags":"","url":"proc/to_char_matrix_dp.html"},{"title":"to_char_matrix_int32 – PIC","text":"private  function to_char_matrix_int32(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:,:) Return Value character(len=:), allocatable Called by proc~~to_char_matrix_int32~~CalledByGraph proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char to_char interface~to_char->proc~to_char_matrix_int32 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: ncols integer, private :: nrows character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_matrix_int32 ( array ) result ( trimmed_str ) integer ( int32 ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Estimate total length needed total_len = 10 ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , nrows if ( i > 1 ) trimmed_str = trimmed_str // \", \" trimmed_str = trimmed_str // \"[\" do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_int32","tags":"","url":"proc/to_char_matrix_int32.html"},{"title":"to_char_matrix_int64 – PIC","text":"private  function to_char_matrix_int64(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:,:) Return Value character(len=:), allocatable Called by proc~~to_char_matrix_int64~~CalledByGraph proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char to_char interface~to_char->proc~to_char_matrix_int64 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: ncols integer, private :: nrows character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_matrix_int64 ( array ) result ( trimmed_str ) integer ( int64 ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Estimate total length needed total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_int64","tags":"","url":"proc/to_char_matrix_int64.html"},{"title":"to_char_matrix_sp – PIC","text":"private  function to_char_matrix_sp(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:,:) Return Value character(len=:), allocatable Called by proc~~to_char_matrix_sp~~CalledByGraph proc~to_char_matrix_sp to_char_matrix_sp interface~to_char to_char interface~to_char->proc~to_char_matrix_sp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i integer, private :: j integer, private :: ncols integer, private :: nrows character(len=32), private :: style character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_matrix_sp ( array ) result ( trimmed_str ) real ( kind = sp ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , sp_precision , ')' ! Estimate total length needed total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , style ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , style ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_sp","tags":"","url":"proc/to_char_matrix_sp.html"},{"title":"to_char_sp – PIC","text":"private  function to_char_sp(r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable Called by proc~~to_char_sp~~CalledByGraph proc~to_char_sp to_char_sp interface~to_char to_char interface~to_char->proc~to_char_sp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str character(len=32), private :: style Source Code function to_char_sp ( r ) result ( trimmed_str ) !! transform a real(sp) to a string real ( kind = sp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_char_sp","tags":"","url":"proc/to_char_sp.html"},{"title":"to_char_vector_dp – PIC","text":"private  function to_char_vector_dp(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) Return Value character(len=:), allocatable Called by proc~~to_char_vector_dp~~CalledByGraph proc~to_char_vector_dp to_char_vector_dp interface~to_char to_char interface~to_char->proc~to_char_vector_dp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=32), private :: style character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_vector_dp ( array ) result ( trimmed_str ) real ( kind = dp ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , total_len ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_dp","tags":"","url":"proc/to_char_vector_dp.html"},{"title":"to_char_vector_int32 – PIC","text":"private  function to_char_vector_int32(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Return Value character(len=:), allocatable Called by proc~~to_char_vector_int32~~CalledByGraph proc~to_char_vector_int32 to_char_vector_int32 interface~to_char to_char interface~to_char->proc~to_char_vector_int32 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_vector_int32 ( array ) result ( trimmed_str ) integer ( int32 ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , total_len ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_int32","tags":"","url":"proc/to_char_vector_int32.html"},{"title":"to_char_vector_int64 – PIC","text":"private  function to_char_vector_int64(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) Return Value character(len=:), allocatable Called by proc~~to_char_vector_int64~~CalledByGraph proc~to_char_vector_int64 to_char_vector_int64 interface~to_char to_char interface~to_char->proc~to_char_vector_int64 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_vector_int64 ( array ) result ( trimmed_str ) integer ( int64 ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , total_len ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_int64","tags":"","url":"proc/to_char_vector_int64.html"},{"title":"to_char_vector_sp – PIC","text":"private  function to_char_vector_sp(array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) Return Value character(len=:), allocatable Called by proc~~to_char_vector_sp~~CalledByGraph proc~to_char_vector_sp to_char_vector_sp interface~to_char to_char interface~to_char->proc~to_char_vector_sp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private :: i character(len=32), private :: style character(len=50), private :: temp_str integer, private :: total_len Source Code function to_char_vector_sp ( array ) result ( trimmed_str ) real ( kind = sp ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , total_len ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , sp_precision , ')' ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_sp","tags":"","url":"proc/to_char_vector_sp.html"},{"title":"print_asterisk_row – PIC","text":"public  subroutine print_asterisk_row(n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Source Code subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row","tags":"","url":"proc/print_asterisk_row.html"},{"title":"set_precision_internal – PIC","text":"private  subroutine set_precision_internal(precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision Called by proc~~set_precision_internal~~CalledByGraph proc~set_precision_internal set_precision_internal interface~set_precision set_precision interface~set_precision->proc~set_precision_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_precision_internal ( precision ) !! Set the precision for real numbers integer ( default_int ), intent ( in ) :: precision if ( precision > 0 ) then dp_precision = precision else print * , \"Warning: Precision must be positive. Using default.\" dp_precision = default_dp_precision end if end subroutine set_precision_internal","tags":"","url":"proc/set_precision_internal.html"},{"title":"set_precision – PIC","text":"public interface set_precision This routine overrides the default dp precision used for\nprinting strings in the to_char function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Usage: call set_precision(variable) where variable is default_int Calls interface~~set_precision~~CallsGraph interface~set_precision set_precision proc~set_precision_internal set_precision_internal interface~set_precision->proc~set_precision_internal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine set_precision_internal (precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision","tags":"","url":"interface/set_precision.html"},{"title":"to_char – PIC","text":"public interface to_char converts a variable of type (int32, int64, sp, dp, char, logical)\nto a series of chars which is just a collecting of chars. Usage result = to_char(variable) arrays. Please use pic_print_array_v2 module for this Calls interface~~to_char~~CallsGraph interface~to_char to_char proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~to_char~~CalledByGraph interface~to_char to_char proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_char proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_char proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_char proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_char proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_char proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_char proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_char proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_char proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_char proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_char proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_char proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_char proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_char proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->interface~to_char interface~pic_print_array pic_print_array interface~pic_print_array->proc~print_matrix_dp interface~pic_print_array->proc~print_matrix_int32 interface~pic_print_array->proc~print_matrix_int64 interface~pic_print_array->proc~print_matrix_sp interface~pic_print_array->proc~print_packed_matrix_dp interface~pic_print_array->proc~print_packed_matrix_int32 interface~pic_print_array->proc~print_packed_matrix_int64 interface~pic_print_array->proc~print_packed_matrix_sp interface~pic_print_array->proc~print_vector_dp interface~pic_print_array->proc~print_vector_int32 interface~pic_print_array->proc~print_vector_int64 interface~pic_print_array->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~pic_print_array->proc~print_3d_tensor_dp proc~print_3d_tensor_int32 print_3d_tensor_int32 interface~pic_print_array->proc~print_3d_tensor_int32 proc~print_3d_tensor_int64 print_3d_tensor_int64 interface~pic_print_array->proc~print_3d_tensor_int64 proc~print_3d_tensor_sp print_3d_tensor_sp interface~pic_print_array->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~pic_print_array proc~print_3d_tensor_int32->interface~pic_print_array proc~print_3d_tensor_int64->interface~pic_print_array proc~print_3d_tensor_sp->interface~pic_print_array Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function to_char_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_char_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable private  function to_char_vector_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_matrix_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:,:) Return Value character(len=:), allocatable","tags":"","url":"interface/to_char.html"},{"title":"get_precision – PIC","text":"private interface get_precision Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result Module Procedures private  interface get_precision () Obtain the current precision being used to print variables to strings Read more… Arguments None","tags":"","url":"interface/get_precision.html"},{"title":"pad – PIC","text":"private interface pad adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) Module Procedures private  interface pad () adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Read more… Arguments None","tags":"","url":"interface/pad.html"},{"title":"to_upper – PIC","text":"private interface to_upper takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) Module Procedures private  interface to_upper () takes a character variable and transforms it to uppercase Read more… Arguments None","tags":"","url":"interface/to_upper~3.html"},{"title":"char_sort_index_default – PIC","text":"private module subroutine char_sort_index_default(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~char_sort_index_default~~CallsGraph proc~char_sort_index_default char_sort_index_default interface~pic_optional pic_optional proc~char_sort_index_default->interface~pic_optional none~merge_sort~15 merge_sort proc~char_sort_index_default->none~merge_sort~15 none~reverse_segment~15 reverse_segment proc~char_sort_index_default->none~reverse_segment~15 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~15->none~reverse_segment~15 none~calc_min_run~15 calc_min_run none~merge_sort~15->none~calc_min_run~15 none~collapse~15 collapse none~merge_sort~15->none~collapse~15 none~insert_head~15 insert_head none~merge_sort~15->none~insert_head~15 none~insertion_sort~25 insertion_sort none~merge_sort~15->none~insertion_sort~25 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int_index), private :: i integer(kind=int_index), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid character(len=len), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) character(len=len), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) Source Code module subroutine char_sort_index_default ( array , index , work , iwork , & reverse ) !! `char_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort_index_default","tags":"","url":"proc/char_sort_index_default.html"},{"title":"char_sort_index_low – PIC","text":"private module subroutine char_sort_index_low(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~char_sort_index_low~~CallsGraph proc~char_sort_index_low char_sort_index_low interface~pic_optional pic_optional proc~char_sort_index_low->interface~pic_optional none~merge_sort~20 merge_sort proc~char_sort_index_low->none~merge_sort~20 none~reverse_segment~20 reverse_segment proc~char_sort_index_low->none~reverse_segment~20 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~20->none~reverse_segment~20 none~calc_min_run~20 calc_min_run none~merge_sort~20->none~calc_min_run~20 none~collapse~20 collapse none~merge_sort~20->none~collapse~20 none~insert_head~20 insert_head none~merge_sort~20->none~insert_head~20 none~insertion_sort~30 insertion_sort none~merge_sort~20->none~insertion_sort~30 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int_index), private :: i integer(kind=int_index_low), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid character(len=len), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) character(len=len), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) Source Code module subroutine char_sort_index_low ( array , index , work , iwork , & reverse ) !! `char_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort_index_low","tags":"","url":"proc/char_sort_index_low.html"},{"title":"dp_sort_index_default – PIC","text":"private module subroutine dp_sort_index_default(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~dp_sort_index_default~~CallsGraph proc~dp_sort_index_default dp_sort_index_default interface~pic_optional pic_optional proc~dp_sort_index_default->interface~pic_optional none~merge_sort~14 merge_sort proc~dp_sort_index_default->none~merge_sort~14 none~reverse_segment~14 reverse_segment proc~dp_sort_index_default->none~reverse_segment~14 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~14->none~reverse_segment~14 none~calc_min_run~14 calc_min_run none~merge_sort~14->none~calc_min_run~14 none~collapse~14 collapse none~merge_sort~14->none~collapse~14 none~insert_head~14 insert_head none~merge_sort~14->none~insert_head~14 none~insertion_sort~24 insertion_sort none~merge_sort~14->none~insertion_sort~24 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=dp), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=dp), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) real(kind=dp), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) Source Code module subroutine dp_sort_index_default ( array , index , work , iwork , & reverse ) !! `dp_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort_index_default","tags":"","url":"proc/dp_sort_index_default.html"},{"title":"dp_sort_index_low – PIC","text":"private module subroutine dp_sort_index_low(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~dp_sort_index_low~~CallsGraph proc~dp_sort_index_low dp_sort_index_low interface~pic_optional pic_optional proc~dp_sort_index_low->interface~pic_optional none~merge_sort~19 merge_sort proc~dp_sort_index_low->none~merge_sort~19 none~reverse_segment~19 reverse_segment proc~dp_sort_index_low->none~reverse_segment~19 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~19->none~reverse_segment~19 none~calc_min_run~19 calc_min_run none~merge_sort~19->none~calc_min_run~19 none~collapse~19 collapse none~merge_sort~19->none~collapse~19 none~insert_head~19 insert_head none~merge_sort~19->none~insert_head~19 none~insertion_sort~29 insertion_sort none~merge_sort~19->none~insertion_sort~29 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=dp), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index_low), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=dp), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) real(kind=dp), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) Source Code module subroutine dp_sort_index_low ( array , index , work , iwork , & reverse ) !! `dp_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort_index_low","tags":"","url":"proc/dp_sort_index_low.html"},{"title":"int32_sort_index_default – PIC","text":"private module subroutine int32_sort_index_default(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~int32_sort_index_default~~CallsGraph proc~int32_sort_index_default int32_sort_index_default interface~pic_optional pic_optional proc~int32_sort_index_default->interface~pic_optional none~merge_sort~11 merge_sort proc~int32_sort_index_default->none~merge_sort~11 none~reverse_segment~11 reverse_segment proc~int32_sort_index_default->none~reverse_segment~11 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~11->none~reverse_segment~11 none~calc_min_run~11 calc_min_run none~merge_sort~11->none~calc_min_run~11 none~collapse~11 collapse none~merge_sort~11->none~collapse~11 none~insert_head~11 insert_head none~merge_sort~11->none~insert_head~11 none~insertion_sort~21 insertion_sort none~merge_sort~11->none~insertion_sort~21 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int32), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int32), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int32), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) Source Code module subroutine int32_sort_index_default ( array , index , work , iwork , & reverse ) !! `int32_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort_index_default","tags":"","url":"proc/int32_sort_index_default.html"},{"title":"int32_sort_index_low – PIC","text":"private module subroutine int32_sort_index_low(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~int32_sort_index_low~~CallsGraph proc~int32_sort_index_low int32_sort_index_low interface~pic_optional pic_optional proc~int32_sort_index_low->interface~pic_optional none~merge_sort~16 merge_sort proc~int32_sort_index_low->none~merge_sort~16 none~reverse_segment~16 reverse_segment proc~int32_sort_index_low->none~reverse_segment~16 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~16->none~reverse_segment~16 none~calc_min_run~16 calc_min_run none~merge_sort~16->none~calc_min_run~16 none~collapse~16 collapse none~merge_sort~16->none~collapse~16 none~insert_head~16 insert_head none~merge_sort~16->none~insert_head~16 none~insertion_sort~26 insertion_sort none~merge_sort~16->none~insertion_sort~26 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int32), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index_low), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int32), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int32), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) Source Code module subroutine int32_sort_index_low ( array , index , work , iwork , & reverse ) !! `int32_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort_index_low","tags":"","url":"proc/int32_sort_index_low.html"},{"title":"int64_sort_index_default – PIC","text":"private module subroutine int64_sort_index_default(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~int64_sort_index_default~~CallsGraph proc~int64_sort_index_default int64_sort_index_default interface~pic_optional pic_optional proc~int64_sort_index_default->interface~pic_optional none~merge_sort~12 merge_sort proc~int64_sort_index_default->none~merge_sort~12 none~reverse_segment~12 reverse_segment proc~int64_sort_index_default->none~reverse_segment~12 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~12->none~reverse_segment~12 none~calc_min_run~12 calc_min_run none~merge_sort~12->none~calc_min_run~12 none~collapse~12 collapse none~merge_sort~12->none~collapse~12 none~insert_head~12 insert_head none~merge_sort~12->none~insert_head~12 none~insertion_sort~22 insertion_sort none~merge_sort~12->none~insertion_sort~22 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int64), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int64), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int64), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) Source Code module subroutine int64_sort_index_default ( array , index , work , iwork , & reverse ) !! `int64_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort_index_default","tags":"","url":"proc/int64_sort_index_default.html"},{"title":"int64_sort_index_low – PIC","text":"private module subroutine int64_sort_index_low(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~int64_sort_index_low~~CallsGraph proc~int64_sort_index_low int64_sort_index_low interface~pic_optional pic_optional proc~int64_sort_index_low->interface~pic_optional none~merge_sort~17 merge_sort proc~int64_sort_index_low->none~merge_sort~17 none~reverse_segment~17 reverse_segment proc~int64_sort_index_low->none~reverse_segment~17 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~17->none~reverse_segment~17 none~calc_min_run~17 calc_min_run none~merge_sort~17->none~calc_min_run~17 none~collapse~17 collapse none~merge_sort~17->none~collapse~17 none~insert_head~17 insert_head none~merge_sort~17->none~insert_head~17 none~insertion_sort~27 insertion_sort none~merge_sort~17->none~insertion_sort~27 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size integer(kind=int64), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index_low), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid integer(kind=int64), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int64), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) Source Code module subroutine int64_sort_index_low ( array , index , work , iwork , & reverse ) !! `int64_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort_index_low","tags":"","url":"proc/int64_sort_index_low.html"},{"title":"sp_sort_index_default – PIC","text":"private module subroutine sp_sort_index_default(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~sp_sort_index_default~~CallsGraph proc~sp_sort_index_default sp_sort_index_default interface~pic_optional pic_optional proc~sp_sort_index_default->interface~pic_optional none~merge_sort~13 merge_sort proc~sp_sort_index_default->none~merge_sort~13 none~reverse_segment~13 reverse_segment proc~sp_sort_index_default->none~reverse_segment~13 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~13->none~reverse_segment~13 none~calc_min_run~13 calc_min_run none~merge_sort~13->none~calc_min_run~13 none~collapse~13 collapse none~merge_sort~13->none~collapse~13 none~insert_head~13 insert_head none~merge_sort~13->none~insert_head~13 none~insertion_sort~23 insertion_sort none~merge_sort~13->none~insertion_sort~23 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=sp), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=sp), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: index (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) real(kind=sp), intent(inout) :: buf (0:) integer(kind=int_index), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(inout) :: index (0:) Source Code module subroutine sp_sort_index_default ( array , index , work , iwork , & reverse ) !! `sp_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort_index_default","tags":"","url":"proc/sp_sort_index_default.html"},{"title":"sp_sort_index_low – PIC","text":"private module subroutine sp_sort_index_low(array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Calls proc~~sp_sort_index_low~~CallsGraph proc~sp_sort_index_low sp_sort_index_low interface~pic_optional pic_optional proc~sp_sort_index_low->interface~pic_optional none~merge_sort~18 merge_sort proc~sp_sort_index_low->none~merge_sort~18 none~reverse_segment~18 reverse_segment proc~sp_sort_index_low->none~reverse_segment~18 proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp none~merge_sort~18->none~reverse_segment~18 none~calc_min_run~18 calc_min_run none~merge_sort~18->none~calc_min_run~18 none~collapse~18 collapse none~merge_sort~18->none~collapse~18 none~insert_head~18 insert_head none~merge_sort~18->none~insert_head~18 none~insertion_sort~28 insertion_sort none~merge_sort~18->none~insertion_sort~28 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int_index), private :: array_size real(kind=sp), private, allocatable :: buf (:) integer(kind=int_index), private :: i integer(kind=int_index_low), private, allocatable :: ibuf (:) integer(kind=int_index), private :: stat Functions pure function calc_min_run (n) result(min_run) Returns the minimum length of a run from 32-63 so that N/MIN_RUN is\nless than or equal to a power of two. See\nhttps://svn.python.org/projects/python/trunk/Objects/listsort.txt Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: n Return Value integer(kind=int_index) pure function collapse (runs) result(r) Arguments Type Intent Optional Attributes Name type( run_type ), intent(in), target :: runs (0:) Return Value integer(kind=int_index) Subroutines pure subroutine insert_head (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine insertion_sort (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) pure subroutine merge (array, mid, buf, index, ibuf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(in) :: mid real(kind=sp), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: index (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) subroutine merge_sort (array, index, buf, ibuf) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) real(kind=sp), intent(inout) :: buf (0:) integer(kind=int_index_low), intent(inout) :: ibuf (0:) pure subroutine reverse_segment (array, index) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(inout) :: index (0:) Source Code module subroutine sp_sort_index_low ( array , index , work , iwork , & reverse ) !! `sp_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort_index_low","tags":"","url":"proc/sp_sort_index_low.html"},{"title":"sort_index – PIC","text":"public interface sort_index The generic subroutine interface implementing the SORT_INDEX algorithm,\nbased on the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\nbut modified to return an array of indices that would provide a stable\nsort of the rank one ARRAY input. The indices by default correspond to a\nnon-decreasing sort, but if the optional argument REVERSE is present\nwith a value of .TRUE. the indices correspond to a non-increasing sort. Subroutines private module subroutine char_sort_index_default(array, index, work, iwork, reverse) Implementation → char_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine char_sort_index_low(array, index, work, iwork, reverse) Implementation → char_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_default(array, index, work, iwork, reverse) Implementation → dp_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_low(array, index, work, iwork, reverse) Implementation → dp_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_default(array, index, work, iwork, reverse) Implementation → int32_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_low(array, index, work, iwork, reverse) Implementation → int32_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_default(array, index, work, iwork, reverse) Implementation → int64_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_low(array, index, work, iwork, reverse) Implementation → int64_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_default(array, index, work, iwork, reverse) Implementation → sp_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_low(array, index, work, iwork, reverse) Implementation → sp_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse","tags":"","url":"interface/sort_index.html"},{"title":"pic_print_banner – PIC","text":"public  subroutine pic_print_banner() my cool banner, work in progress Arguments None Source Code subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" !print '(4a)', & !   '   PIC compiled with ', & !   compiler_version() !print '(4a)', ' using the options ',        & !  compiler_options() end subroutine pic_print_banner","tags":"","url":"proc/pic_print_banner.html"},{"title":"timer_get_elapsed_time – PIC","text":"private  function timer_get_elapsed_time(self) result(elapsed) Returns the elapsed time as a real(dp) variable Usage: var = my_timer%get_elapsed_time() Needs my_timer to be declared previously as type(timer_type) :: my_timer Type Bound timer_type Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self Return Value real(kind=dp) Called by proc~~timer_get_elapsed_time~~CalledByGraph proc~timer_get_elapsed_time timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time proc~flop_rate_get_time flop_rate_type%flop_rate_get_time proc~flop_rate_get_time->proc~timer_get_elapsed_time proc~timer_print_time timer_type%timer_print_time proc~timer_print_time->proc~timer_get_elapsed_time proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: current_count Source Code function timer_get_elapsed_time ( self ) result ( elapsed ) !! Returns the elapsed time as a real(dp) variable !! !! Usage: var = my_timer%get_elapsed_time() !! !! Needs my_timer to be declared previously as type(timer_type) :: my_timer !! class ( timer_type ), intent ( in ) :: self real ( dp ) :: elapsed integer ( default_int ) :: current_count elapsed = 0.0_dp #ifdef _OPENMP if ( self % is_running ) then elapsed = omp_get_wtime () - self % start_time else elapsed = self % stop_time - self % start_time end if #else if ( self % is_running ) then call system_clock ( count = current_count ) elapsed = real ( current_count - self % start_count , dp ) / real ( self % count_rate , dp ) else elapsed = real ( self % stop_count - self % start_count , dp ) / real ( self % count_rate , dp ) end if #endif end function timer_get_elapsed_time","tags":"","url":"proc/timer_get_elapsed_time.html"},{"title":"timer_print_time – PIC","text":"private  subroutine timer_print_time(self) Prints the elapsed time at the time of calling Usage: call my_timer%print_time() Needs my_timer to be declared previously as type(timer_type) :: my_timer This function does not stop the timer, it will get the current time elapsed stopped or not Type Bound timer_type Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self Calls proc~~timer_print_time~~CallsGraph proc~timer_print_time timer_type%timer_print_time interface~to_char to_char proc~timer_print_time->interface~to_char proc~timer_get_elapsed_time timer_type%timer_get_elapsed_time proc~timer_print_time->proc~timer_get_elapsed_time proc~to_char_char to_char_char interface~to_char->proc~to_char_char proc~to_char_dp to_char_dp interface~to_char->proc~to_char_dp proc~to_char_int32 to_char_int32 interface~to_char->proc~to_char_int32 proc~to_char_int64 to_char_int64 interface~to_char->proc~to_char_int64 proc~to_char_logical to_char_logical interface~to_char->proc~to_char_logical proc~to_char_matrix_dp to_char_matrix_dp interface~to_char->proc~to_char_matrix_dp proc~to_char_matrix_int32 to_char_matrix_int32 interface~to_char->proc~to_char_matrix_int32 proc~to_char_matrix_int64 to_char_matrix_int64 interface~to_char->proc~to_char_matrix_int64 proc~to_char_matrix_sp to_char_matrix_sp interface~to_char->proc~to_char_matrix_sp proc~to_char_sp to_char_sp interface~to_char->proc~to_char_sp proc~to_char_vector_dp to_char_vector_dp interface~to_char->proc~to_char_vector_dp proc~to_char_vector_int32 to_char_vector_int32 interface~to_char->proc~to_char_vector_int32 proc~to_char_vector_int64 to_char_vector_int64 interface~to_char->proc~to_char_vector_int64 proc~to_char_vector_sp to_char_vector_sp interface~to_char->proc~to_char_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: elapsed Source Code subroutine timer_print_time ( self ) !! Prints the elapsed time at the time of calling !! !! Usage: call my_timer%print_time() !! !! Needs my_timer to be declared previously as type(timer_type) :: my_timer !! !! This function does not stop the timer, it will get the current time elapsed stopped or not class ( timer_type ), intent ( in ) :: self real ( dp ) :: elapsed elapsed = self % get_elapsed_time () if ( self % is_running ) then print * , \"Currently elapsed time: \" // to_char ( elapsed ) // \" seconds\" else print * , \"Elapsed time: \" // to_char ( elapsed ) // \" seconds\" end if end subroutine timer_print_time","tags":"","url":"proc/timer_print_time.html"},{"title":"timer_start – PIC","text":"private  subroutine timer_start(self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Usage: call my_timer%start() Usage assumes a declaration of type(timer_type) :: my_timer Type Bound timer_type Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self Called by proc~~timer_start~~CalledByGraph proc~timer_start timer_type%timer_start proc~flop_rate_start_time flop_rate_type%flop_rate_start_time proc~flop_rate_start_time->proc~timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timer_start ( self ) !! starts the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%start() !! !! Usage assumes a declaration of type(timer_type) :: my_timer class ( timer_type ), intent ( inout ) :: self self % is_running = . true . #ifdef _OPENMP self % start_time = omp_get_wtime () #else call system_clock ( self % start_count , self % count_rate ) #endif end subroutine timer_start","tags":"","url":"proc/timer_start.html"},{"title":"timer_stop – PIC","text":"private  subroutine timer_stop(self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Usage: call my_timer%stop() Usage assumes a declaration of type(timer_type) :: my_timer\nwill fail if a timer has not been started! Type Bound timer_type Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self Source Code subroutine timer_stop ( self ) !! stop the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%stop() !! !! Usage assumes a declaration of type(timer_type) :: my_timer !! will fail if a timer has not been started! class ( timer_type ), intent ( inout ) :: self if (. not . self % is_running ) then error stop \"Cannot stop a timer that has not been started!\" end if #ifdef _OPENMP self % stop_time = omp_get_wtime () #else call system_clock ( self % stop_count ) #endif ! if someone stops the timer, we stop ! self % is_running = . false . end subroutine timer_stop","tags":"","url":"proc/timer_stop.html"},{"title":"to_string_1_i_int32 – PIC","text":"pure module function to_string_1_i_int32(value) result(string) Represent an integer of kind int32 as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: value Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=buffer_len), private :: buffer integer, private, parameter :: buffer_len = range(value)+2 integer, private, parameter :: ik = int32 integer(kind=ik), private :: n character(len=1), private, parameter :: numbers (-9:0) = [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] integer, private :: pos Source Code pure module function to_string_1_i_int32 ( value ) result ( string ) integer , parameter :: ik = int32 integer ( ik ), intent ( in ) :: value character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( value ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer ( ik ) :: n character ( len = 1 ), parameter :: numbers ( - 9 : 0 ) = & [ \"9\" , \"8\" , \"7\" , \"6\" , \"5\" , \"4\" , \"3\" , \"2\" , \"1\" , \"0\" ] if ( value == 0_ik ) then string = numbers ( 0 ) return end if n = sign ( value , - 1_ik ) buffer = \"\" pos = buffer_len + 1 do while ( n < 0_ik ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10_ik )) n = n / 10_ik end do if ( value < 0_ik ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function to_string_1_i_int32","tags":"","url":"proc/to_string_1_i_int32.html"},{"title":"to_string_1_i_int64 – PIC","text":"pure module function to_string_1_i_int64(value) result(string) Represent an integer of kind int64 as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: value Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=buffer_len), private :: buffer integer, private, parameter :: buffer_len = range(value)+2 integer, private, parameter :: ik = int64 integer(kind=ik), private :: n character(len=1), private, parameter :: numbers (-9:0) = [\"9\", \"8\", \"7\", \"6\", \"5\", \"4\", \"3\", \"2\", \"1\", \"0\"] integer, private :: pos Source Code pure module function to_string_1_i_int64 ( value ) result ( string ) integer , parameter :: ik = int64 integer ( ik ), intent ( in ) :: value character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( value ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer ( ik ) :: n character ( len = 1 ), parameter :: numbers ( - 9 : 0 ) = & [ \"9\" , \"8\" , \"7\" , \"6\" , \"5\" , \"4\" , \"3\" , \"2\" , \"1\" , \"0\" ] if ( value == 0_ik ) then string = numbers ( 0 ) return end if n = sign ( value , - 1_ik ) buffer = \"\" pos = buffer_len + 1 do while ( n < 0_ik ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10_ik )) n = n / 10_ik end do if ( value < 0_ik ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function to_string_1_i_int64","tags":"","url":"proc/to_string_1_i_int64.html"},{"title":"to_string_1_l_fbool – PIC","text":"pure module function to_string_1_l_fbool(value) result(string) Represent an logical of kind fbool as character sequence. Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value Return Value character(len=1) Source Code pure module function to_string_1_l_fbool ( value ) result ( string ) logical ( fbool ), intent ( in ) :: value character ( len = 1 ) :: string string = merge ( \"T\" , \"F\" , value ) end function to_string_1_l_fbool","tags":"","url":"proc/to_string_1_l_fbool.html"},{"title":"to_string_2_i_int32 – PIC","text":"pure module function to_string_2_i_int32(value, format) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: adjusted_format character(len=buffer_len), private :: buffer integer, private :: stat Source Code pure module function to_string_2_i_int32 ( value , format ) result ( string ) integer ( int32 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = :), allocatable :: adjusted_format character ( len = buffer_len ) :: buffer integer :: stat #ifdef __NVCOMPILER_LLVM__ adjusted_format = fix_nvhpc_octal_format ( format ) #else adjusted_format = format #endif write ( buffer , \"(\" // adjusted_format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_i_int32","tags":"","url":"proc/to_string_2_i_int32.html"},{"title":"to_string_2_i_int64 – PIC","text":"pure module function to_string_2_i_int64(value, format) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=:), private, allocatable :: adjusted_format character(len=buffer_len), private :: buffer integer, private :: stat Source Code pure module function to_string_2_i_int64 ( value , format ) result ( string ) integer ( int64 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = :), allocatable :: adjusted_format character ( len = buffer_len ) :: buffer integer :: stat #ifdef __NVCOMPILER_LLVM__ adjusted_format = fix_nvhpc_octal_format ( format ) #else adjusted_format = format #endif write ( buffer , \"(\" // adjusted_format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_i_int64","tags":"","url":"proc/to_string_2_i_int64.html"},{"title":"to_string_2_l_fbool – PIC","text":"pure module function to_string_2_l_fbool(value, format) result(string) Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial character(len=buffer_len), private :: buffer integer, private :: stat Source Code pure module function to_string_2_l_fbool ( value , format ) result ( string ) logical ( fbool ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , \"(\" // format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_l_fbool","tags":"","url":"proc/to_string_2_l_fbool.html"},{"title":"to_string_r_dp – PIC","text":"pure module function to_string_r_dp(value, format) result(string) Format or transfer a real(dp) scalar as a string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Calls proc~~to_string_r_dp~~CallsGraph proc~to_string_r_dp to_string_r_dp interface~pic_optional pic_optional proc~to_string_r_dp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=buffer_len), private :: buffer integer, private :: stat Source Code pure module function to_string_r_dp ( value , format ) result ( string ) real ( dp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , '(' // pic_optional ( format , \"g0\" ) // ')' , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_r_dp","tags":"","url":"proc/to_string_r_dp.html"},{"title":"to_string_r_sp – PIC","text":"pure module function to_string_r_sp(value, format) result(string) Format or transfer a real(sp) scalar as a string. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable Calls proc~~to_string_r_sp~~CallsGraph proc~to_string_r_sp to_string_r_sp interface~pic_optional pic_optional proc~to_string_r_sp->interface~pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_logical optional_logical interface~pic_optional->proc~optional_logical proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=buffer_len), private :: buffer integer, private :: stat Source Code pure module function to_string_r_sp ( value , format ) result ( string ) real ( sp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , '(' // pic_optional ( format , \"g0\" ) // ')' , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_r_sp","tags":"","url":"proc/to_string_r_sp.html"},{"title":"new_string – PIC","text":"elemental module function new_string(string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) Source Code elemental module function new_string ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( string_type ) :: new if ( present ( string )) then new % raw = string end if end function new_string","tags":"","url":"proc/new_string.html"},{"title":"new_string_from_integer_int32 – PIC","text":"elemental module function new_string_from_integer_int32(val) result(new) Constructor for new string instances from an integer of kind int32. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) Calls proc~~new_string_from_integer_int32~~CallsGraph proc~new_string_from_integer_int32 new_string_from_integer_int32 interface~to_string to_string proc~new_string_from_integer_int32->interface~to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental module function new_string_from_integer_int32 ( val ) result ( new ) integer ( int32 ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_integer_int32","tags":"","url":"proc/new_string_from_integer_int32.html"},{"title":"new_string_from_integer_int64 – PIC","text":"elemental module function new_string_from_integer_int64(val) result(new) Constructor for new string instances from an integer of kind int64. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) Calls proc~~new_string_from_integer_int64~~CallsGraph proc~new_string_from_integer_int64 new_string_from_integer_int64 interface~to_string to_string proc~new_string_from_integer_int64->interface~to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental module function new_string_from_integer_int64 ( val ) result ( new ) integer ( int64 ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_integer_int64","tags":"","url":"proc/new_string_from_integer_int64.html"},{"title":"new_string_from_logical_fbool – PIC","text":"elemental module function new_string_from_logical_fbool(val) result(new) Constructor for new string instances from a logical of kind fbool. Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: val Return Value type( string_type ) Calls proc~~new_string_from_logical_fbool~~CallsGraph proc~new_string_from_logical_fbool new_string_from_logical_fbool interface~to_string to_string proc~new_string_from_logical_fbool->interface~to_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental module function new_string_from_logical_fbool ( val ) result ( new ) logical ( fbool ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_logical_fbool","tags":"","url":"proc/new_string_from_logical_fbool.html"},{"title":"pic_sorting_sort – PIC","text":"This submodule implements the overloaded sorting subroutine SORT that can be used to sort four kinds of INTEGER arrays and three kinds\n of REAL arrays. Sorting is in order of increasing value, with the worst\n case run time performance of O(N Ln(N)) . SORT uses the INTROSORT sorting algorithm of David Musser,\n http://www.cs.rpi.edu/~musser/gp/introsort.ps. introsort is a hybrid\n unstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm is always O(N Ln(N)) it is relatively\n fast on randomly ordered data, but inconsistent in performance on partly\n sorted data, sometimes having merge sort performance, sometimes having\n better than quicksort performance. The generic subroutine implementing the SORT algorithm to return\n an input array with its elements sorted in order of (non-)decreasing\n value. Its use has the syntax: call sort( array[, reverse] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) , type(bitset_64) , type(bitset_large) . If both the type\n   of array is real and at least one of the elements is a NaN , then\n   the ordering of the result is undefined. Otherwise it is defined to be the\n   original elements in non-decreasing order. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in unstable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in unstable order. Example ... ! Read random data from a file call read_file ( 'dummy_file' , array ) ! Sort the random data call sort ( array ) ! Process the sorted data call array_search ( array , values ) ... Uses pic_optional_value pic_types module~~pic_sorting_sort~~UsesGraph module~pic_sorting_sort pic_sorting_sort module~pic_optional_value pic_optional_value module~pic_sorting_sort->module~pic_optional_value module~pic_types pic_types module~pic_sorting_sort->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_sorting_sort~~UsedByGraph module~pic_sorting_sort pic_sorting_sort module~pic_sorting pic_sorting module~pic_sorting->module~pic_sorting_sort Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface sort The generic subroutine interface implementing the SORT algorithm, based\non the introsort of David Musser.\n( Specification ) private pure module subroutine char_sort(array, reverse) Implementation → char_sort( array[, reverse] ) sorts the input ARRAY of type character(len=*) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine dp_sort(array, reverse) Implementation → dp_sort( array[, reverse] ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine int32_sort(array, reverse) Implementation → int32_sort( array[, reverse] ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine int64_sort(array, reverse) Implementation → int64_sort( array[, reverse] ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure module subroutine sp_sort(array, reverse) Implementation → sp_sort( array[, reverse] ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the introsort of David Musser.\nThe algorithm is of order O(N Ln(N)) for all inputs.\nBecause it relies on quicksort , the coefficient of the O(N Ln(N))\nbehavior is small for random data compared to other sorting algorithms. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse Subroutines private pure subroutine char_decrease_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) private pure subroutine char_increase_sort (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) private pure module subroutine char_sort (array, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure subroutine dp_decrease_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) private pure subroutine dp_increase_sort (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) private pure module subroutine dp_sort (array, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure subroutine int32_decrease_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) private pure subroutine int32_increase_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) private pure module subroutine int32_sort (array, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure subroutine int64_decrease_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) private pure subroutine int64_increase_sort (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) private pure module subroutine int64_sort (array, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) logical, intent(in), optional :: reverse private pure subroutine sp_decrease_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) private pure subroutine sp_increase_sort (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) private pure module subroutine sp_sort (array, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) logical, intent(in), optional :: reverse","tags":"","url":"module/pic_sorting_sort.html"},{"title":"pic_flop_recorder – PIC","text":"general flop recorder module Uses pic_types module~~pic_flop_recorder~~UsesGraph module~pic_flop_recorder pic_flop_recorder module~pic_types pic_types module~pic_flop_recorder->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_flop_recorder~~UsedByGraph module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_flop_recorder Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Components Type Visibility Attributes Name Initial integer(kind=int64), private :: flop_count = 0_int64 Type-Bound Procedures procedure, public, non_overridable :: add => add_flops procedure, public, non_overridable :: get => get_flops procedure, public, non_overridable :: reset => reset_flop_counter Functions private  function get_flops (self) result(flops) Get the int64 number of FLOPs we currently have in the counter Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) Subroutines private  subroutine add_flops (self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops private  subroutine reset_flop_counter (self) Resets the flop counter to 0_int64 Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self","tags":"","url":"module/pic_flop_recorder.html"},{"title":"pic_test_helpers – PIC","text":"simple reusable helpers for random things Uses pic_global_definitions pic_types module~~pic_test_helpers~~UsesGraph module~pic_test_helpers pic_test_helpers module~pic_global_definitions pic_global_definitions module~pic_test_helpers->module~pic_global_definitions module~pic_types pic_types module~pic_test_helpers->module~pic_types module~pic_global_definitions->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface is_equal The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about\ncomparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that\nthe two reals are exactly equal due to floating point precision issues. The functions are defined as elemental Usage: if (is_equal(a, b)) then\nwhere a and b are real numbers, and the function will return true if they are\nequal within the tolerance defined in pic_global_definitions. private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical Functions private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical Subroutines public  subroutine dummy_work () this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely Read more… Arguments None","tags":"","url":"module/pic_test_helpers.html"},{"title":"pic_types – PIC","text":"main module for defining types for integer and double precision Uses iso_c_binding iso_fortran_env module~~pic_types~~UsesGraph module~pic_types pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_types~~UsedByGraph module~pic_types pic_types module~pic_array pic_array module~pic_array->module~pic_types module~pic_io pic_io module~pic_array->module~pic_io module~pic_optional_value pic_optional_value module~pic_array->module~pic_optional_value module~pic_ascii pic_ascii module~pic_ascii->module~pic_types module~pic_command_line pic_command_line module~pic_command_line->module~pic_types module~pic_constants pic_constants module~pic_constants->module~pic_types module~pic_device pic_device module~pic_device->module~pic_types module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_types module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_flop_rate->module~pic_io module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_flop_recorder->module~pic_types module~pic_global_definitions pic_global_definitions module~pic_global_definitions->module~pic_types module~pic_hash_32bit pic_hash_32bit module~pic_hash_32bit->module~pic_types module~pic_hash_32bit_fnv pic_hash_32bit_fnv module~pic_hash_32bit->module~pic_hash_32bit_fnv module~pic_hash_32bit_fnv->module~pic_types module~pic_io->module~pic_types module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_types module~pic_logger pic_logger module~pic_knowledge->module~pic_logger module~pic_string_type pic_string_type module~pic_knowledge->module~pic_string_type module~pic_logger->module~pic_types module~pic_logger->module~pic_global_definitions module~pic_optional_value->module~pic_types module~pic_sorting pic_sorting module~pic_sorting->module~pic_types module~pic_sorting->module~pic_optional_value module~pic_sorting_ord_sort pic_sorting_ord_sort module~pic_sorting->module~pic_sorting_ord_sort module~pic_sorting_radix_sort pic_sorting_radix_sort module~pic_sorting->module~pic_sorting_radix_sort module~pic_sorting_sort pic_sorting_sort module~pic_sorting->module~pic_sorting_sort module~pic_sorting_sort_index pic_sorting_sort_index module~pic_sorting->module~pic_sorting_sort_index module~pic_sorting_ord_sort->module~pic_types module~pic_sorting_ord_sort->module~pic_optional_value module~pic_sorting_radix_sort->module~pic_types module~pic_sorting_radix_sort->module~pic_optional_value module~pic_sorting_sort->module~pic_types module~pic_sorting_sort->module~pic_optional_value module~pic_sorting_sort_index->module~pic_types module~pic_sorting_sort_index->module~pic_optional_value module~pic_string_type->module~pic_types module~pic_string_type->module~pic_ascii module~pic_string_type->module~pic_optional_value module~pic_strings pic_strings module~pic_strings->module~pic_types module~pic_strings->module~pic_ascii module~pic_strings->module~pic_optional_value module~pic_strings->module~pic_string_type module~pic_test_helpers pic_test_helpers module~pic_test_helpers->module~pic_types module~pic_test_helpers->module~pic_global_definitions module~pic_timer->module~pic_types module~pic_timer->module~pic_io module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type_constructor->module~pic_string_type module~pic_string_type_constructor->module~pic_strings module~pic_strings_to_string pic_strings_to_string module~pic_strings_to_string->module~pic_string_type module~pic_strings_to_string->module~pic_strings proc~chomp_set_string_char chomp_set_string_char proc~chomp_set_string_char->module~pic_string_type proc~chomp_string chomp_string proc~chomp_string->module~pic_string_type proc~chomp_substring_string_char chomp_substring_string_char proc~chomp_substring_string_char->module~pic_string_type proc~chomp_substring_string_string chomp_substring_string_string proc~chomp_substring_string_string->module~pic_string_type proc~strip_string strip_string proc~strip_string->module~pic_string_type Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: default_complex = dp default complex is double precision integer, public, parameter :: default_int = int32 the default integer kind in PIC is int32 which faciliates the interfaces to MPI\npay special attention if linking PIC to a code that use default int size of 8 integer, public, parameter :: default_real = dp naturally, our default real is double precision integer, public, parameter :: dp = SELECTED_REAL_KIND(15, 307) double precision size integer, public, parameter :: fbool = kind(.true.) integer, public, parameter :: int_index = int64 Integer kind for indexing integer, public, parameter :: int_index_low = int32 Integer kind for indexing using less than huge(1_int32) values integer, public, parameter :: qp = SELECTED_REAL_KIND(33, 4931) quadruple precision size, varies by compiler integer, public, parameter :: sp = SELECTED_REAL_KIND(6, 37) single precision size","tags":"","url":"module/pic_types.html"},{"title":"pic_string_type – PIC","text":"Implementation of a string type to hold an arbitrary sequence of characters. This module provides string type compatible with all Fortran instrinsic character\nprocedures as well as overloaded operators for working with character variables. A string type can be easily constructed by creating a new instance from a\ncharacter variable or literal by invoking its constructor or by assigning it\nto a string type. Generally, the string type behaves similar to a deferred\nlength character in most regards but adds memory access safety. Uses pic_optional_value pic_ascii pic_types module~~pic_string_type~~UsesGraph module~pic_string_type pic_string_type module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: pic_string_type_constructor module~~pic_string_type~~UsedByGraph module~pic_string_type pic_string_type module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_string_type module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type_constructor->module~pic_string_type module~pic_strings pic_strings module~pic_string_type_constructor->module~pic_strings module~pic_strings->module~pic_string_type module~pic_strings_to_string pic_strings_to_string module~pic_strings_to_string->module~pic_string_type module~pic_strings_to_string->module~pic_strings proc~chomp_set_string_char chomp_set_string_char proc~chomp_set_string_char->module~pic_string_type proc~chomp_string chomp_string proc~chomp_string->module~pic_string_type proc~chomp_substring_string_char chomp_substring_string_char proc~chomp_substring_string_char->module~pic_string_type proc~chomp_substring_string_string chomp_substring_string_string proc~chomp_substring_string_string->module~pic_string_type proc~strip_string strip_string proc~strip_string->module~pic_string_type Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: long = selected_int_kind(18) Interfaces public        interface adjustl Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. private elemental function adjustl_string (string) result(adjusted_string) Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface adjustr Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. This method is elemental and returns a scalar character value. private elemental function adjustr_string (string) result(adjusted_string) Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface assignment(=) Assign a character sequence to a string. private elemental subroutine assign_string_char (lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs public        interface char Return the character sequence represented by the string. This method is elemental and returns a scalar character value. private pure function char_string (string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) private elemental function char_string_pos (string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private pure function char_string_range (string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last) public        interface iachar Code in ASCII collating sequence. This method is elemental and returns a default integer scalar value. private elemental function iachar_string (string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public        interface ichar Character-to-integer conversion function. This method is elemental and returns a default integer scalar value. private elemental function ichar_string (string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public        interface index Position of a substring within a string . Returns the position of the start of the leftmost or rightmost occurrence\nof string substring in string , counting from one. If substring is not\npresent in string , zero is returned. This method is elemental and returns a default integer scalar value. private elemental function index_string_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_char_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer public        interface len_trim Returns the length of the character sequence without trailing spaces\nrepresented by the string. This method is elemental and returns a default integer scalar value. private elemental function len_trim_string (string) result(length) Returns the length of the character sequence without trailing spaces\nrepresented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public        interface lge Lexically compare the order of two character sequences being greater equal,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. private elemental function lge_string_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_char_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface lgt Lexically compare the order of two character sequences being greater,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. private elemental function lgt_string_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_char_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface lle Lexically compare the order of two character sequences being less equal,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. private elemental function lle_string_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_char_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface llt Lexically compare the order of two character sequences being less,\nThe left-hand side, the right-hand side or both character sequences can\nbe represented by a string. This method is elemental and returns a default logical scalar value. private elemental function llt_string_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_char_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface move Moves the allocated character scalar from ‘from’ to ‘to’ private elemental subroutine move_string_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout), target :: from type( string_type ), intent(inout), target :: to private pure subroutine move_string_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: from character(len=:), intent(out), allocatable :: to private pure subroutine move_char_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from type( string_type ), intent(out) :: to private pure subroutine move_char_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from character(len=:), intent(out), allocatable :: to public        interface operator(//) Concatenate two character sequences, the left-hand side, the right-hand side\nor both character sequences can be represented by a string. This operator is elemental and returns a scalar character value. private elemental function concat_string_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_char (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_char_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) public        interface operator(/=) Compare two character sequences for inequality, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function ne_string_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_char_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface operator(<) Compare two character sequences for being less, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function lt_string_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_char_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface operator(<=) Compare two character sequences for being less than, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function le_string_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_char_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface operator(==) Compare two character sequences for equality, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function eq_string_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_char_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface operator(>) Compare two character sequences for being greater, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function gt_string_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_char_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface operator(>=) Compare two character sequences for being greater than, the left-hand side,\nthe right-hand side or both character sequences can be represented by\na string. This operator is elemental and returns a default logical scalar value. private elemental function ge_string_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_char_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical public        interface read (formatted) Read a character sequence from a connected unformatted unit into the string. private  subroutine read_formatted (string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public        interface read (unformatted) Read a character sequence from a connected unformatted unit into the string. private  subroutine read_unformatted (string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public        interface repeat Repeats the character sequence hold by the string by the number of\nspecified copies. This method is elemental and returns a scalar character value. private elemental function repeat_string (string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\nspecified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type ) public        interface reverse Reverses the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\nreverse character sequence private elemental function reverse_string (string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface scan Scan a string for the presence of a set of characters. Scans a string for\nany of the characters in a set of characters. If back is either absent or false , this function returns the position\nof the leftmost character of string that is in set . If back is true ,\nthe rightmost position is returned. If no character of set is found in string , the result is zero. This method is elemental and returns a default integer scalar value. private elemental function scan_string_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version both the character sequence and the character set are\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_char_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public        interface slen Returns the length of the character sequence represented by the string. This method is elemental and returns a default integer scalar value. private elemental function len_string (string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer public        interface string_type Constructor for new string instances private elemental module function new_string(string) result(new) Implementation → Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) private elemental module function new_string_from_integer_int32(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_integer_int64(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) private elemental module function new_string_from_logical_fbool(val) result(new) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: val Return Value type( string_type ) public        interface to_lower Returns the lowercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\nlowercase character sequence private elemental function to_lower_string (string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface to_sentence Returns the sentencecase version of the character sequence hold by the input string This method is elemental and returns a new string_type instance which holds this\nsentencecase character sequence private elemental function to_sentence_string (string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface to_title Returns the titlecase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\ntitlecase character sequence private elemental function to_title_string (string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface to_upper Returns the uppercase version of the character sequence hold by the input string This method is Elemental and returns a new string_type instance which holds this\nuppercase character sequence private elemental function to_upper_string (string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface trim Returns the character sequence hold by the string without trailing spaces. This method is elemental and returns a scalar character value. private elemental function trim_string (string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) public        interface verify Scan a string for the absence of a set of characters. Verifies that all\nthe characters in string belong to the set of characters in set. If back is either absent or false , this function returns the position\nof the leftmost character of string that is not in set . If back is true ,\nthe rightmost position is returned. If all characters of string are found\nin set , the result is zero. This method is elemental and returns a default integer scalar value. private elemental function verify_string_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version both the character sequence and\nthe character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the character sequences is\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_char_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the set of characters is\nrepresented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer public        interface write (formatted) Write the character sequence hold by the string to a connected formatted\nunit. private  subroutine write_formatted (string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg public        interface write (unformatted) Write the character sequence hold by the string to a connected unformatted\nunit. private  subroutine write_unformatted (string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg Derived Types type, public, sequence  :: string_type String type holding an arbitrary sequence of characters. Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: raw Constructor Constructor for new string instances private\n\n                    elemental, module\n                    function new_string (string) private\n\n                    elemental, module\n                    function new_string_from_integer_int32 (val) private\n\n                    elemental, module\n                    function new_string_from_integer_int64 (val) private\n\n                    elemental, module\n                    function new_string_from_logical_fbool (val) Functions private elemental function adjustl_string (string) result(adjusted_string) Left-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function adjustr_string (string) result(adjusted_string) Right-adjust the character sequence represented by the string.\nThe length of the character sequence remains unchanged. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function char_string (string) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) private elemental function char_string_pos (string, pos) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: pos Return Value character(len=1) private pure function char_string_range (string, start, last) result(character_string) Return the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: start integer, intent(in) :: last Return Value character(len=last) private elemental function concat_char_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_char (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value type( string_type ) private elemental function concat_string_string (lhs, rhs) result(string) Concatenate two character sequences.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value type( string_type ) private elemental function eq_char_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function eq_string_char (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function eq_string_string (lhs, rhs) result(is_eq) Compare two character sequences for equality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_char_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ge_string_char (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ge_string_string (lhs, rhs) result(is_ge) Compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_char_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function gt_string_char (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function gt_string_string (lhs, rhs) result(is_gt) Compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function iachar_string (string) result(ich) Code in ASCII collating sequence. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer private elemental function ichar_string (string) result(ich) Character-to-integer conversion function. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer private elemental function index_char_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the sub character sequence is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_char (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version the main character sequence is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function index_string_string (string, substring, back) result(pos) Position of a sequence of character within a character sequence.\nIn this version both character sequences are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring logical, intent(in), optional :: back Return Value integer private elemental function le_char_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function le_string_char (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function le_string_string (lhs, rhs) result(is_le) Compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function len_string (string) result(length) Returns the length of the character sequence represented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer private elemental function len_trim_string (string) result(length) Returns the length of the character sequence without trailing spaces\nrepresented by the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value integer private elemental function lge_char_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lge_string_char (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lge_string_string (lhs, rhs) result(is_lge) Lexically compare two character sequences for being greater or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_char_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lgt_string_char (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lgt_string_string (lhs, rhs) result(is_lgt) Lexically compare two character sequences for being greater.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_char_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lle_string_char (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lle_string_string (lhs, rhs) result(is_lle) Lexically compare two character sequences for being less or equal.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_char_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function llt_string_char (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function llt_string_string (lhs, rhs) result(is_llt) Lexically compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_char_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function lt_string_char (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function lt_string_string (lhs, rhs) result(is_lt) Compare two character sequences for being less.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private pure function maybe (string) result(maybe_string) Safely return the character sequences represented by the string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value character(len=slen) private elemental function ne_char_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the right-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function ne_string_char (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version the left-hand side character sequences is by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs character(len=*), intent(in) :: rhs Return Value logical private elemental function ne_string_string (lhs, rhs) result(is_ne) Compare two character sequences for inequality.\nIn this version both character sequences are by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: lhs type( string_type ), intent(in) :: rhs Return Value logical private elemental function repeat_string (string, ncopies) result(repeated_string) Repeats the character sequence hold by the string by the number of\nspecified copies. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: ncopies Return Value type( string_type ) private elemental function reverse_string (string) result(reversed_string) Reverse the character sequence hold by the input string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function scan_char_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the set of characters is represented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_char (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version the character sequences is represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function scan_string_string (string, set, back) result(pos) Scan a character sequence for any of the characters in a set of characters.\nIn this version both the character sequence and the character set are\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function to_lower_string (string) result(lowercase_string) Convert the character sequence hold by the input string to lower case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function to_sentence_string (string) result(sentence_string) Convert the character sequence hold by the input string to sentence case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function to_title_string (string) result(titlecase_string) Convert the character sequence hold by the input string to title case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function to_upper_string (string) result(uppercase_string) Convert the character sequence hold by the input string to upper case Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function trim_string (string) result(trimmed_string) Returns the character sequence hold by the string without trailing spaces. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private elemental function verify_char_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the set of characters is\nrepresented by a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_char (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version the character sequences is\nrepresented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: set logical, intent(in), optional :: back Return Value integer private elemental function verify_string_string (string, set, back) result(pos) Verify a character sequence for the absence any of the characters in\na set of characters. In this version both the character sequence and\nthe character set are represented by a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: set logical, intent(in), optional :: back Return Value integer Subroutines private elemental subroutine assign_string_char (lhs, rhs) Assign a character sequence to a string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: lhs character(len=*), intent(in) :: rhs private pure subroutine move_char_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from character(len=:), intent(out), allocatable :: to private pure subroutine move_char_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name character(len=:), intent(inout), allocatable :: from type( string_type ), intent(out) :: to private pure subroutine move_string_char (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: from character(len=:), intent(out), allocatable :: to private elemental subroutine move_string_string (from, to) Moves the allocated character scalar from ‘from’ to ‘to’\nNo output Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout), target :: from type( string_type ), intent(inout), target :: to private  subroutine read_formatted (string, unit, iotype, v_list, iostat, iomsg) Read a character sequence from a connected formatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg private  subroutine read_unformatted (string, unit, iostat, iomsg) Read a character sequence from a connected unformatted unit into the string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(inout) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg private elemental subroutine unused_dummy_argument (dummy) Do nothing but mark an unused dummy argument as such to acknowledge compile\ntime warning like: Read more… Arguments Type Intent Optional Attributes Name class(*), intent(in) :: dummy private  subroutine write_formatted (string, unit, iotype, v_list, iostat, iomsg) Write the character sequence hold by the string to a connected formatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit character(len=*), intent(in) :: iotype integer, intent(in) :: v_list (:) integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg private  subroutine write_unformatted (string, unit, iostat, iomsg) Write the character sequence hold by the string to a connected unformatted\nunit. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: unit integer, intent(out) :: iostat character(len=*), intent(inout) :: iomsg","tags":"","url":"module/pic_string_type.html"},{"title":"pic_ascii – PIC","text":"The stdlib_ascii module provides procedures for handling and manipulating\nintrinsic character variables and constants. Uses pic_types module~~pic_ascii~~UsesGraph module~pic_ascii pic_ascii module~pic_types pic_types module~pic_ascii->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_ascii~~UsedByGraph module~pic_ascii pic_ascii module~pic_string_type pic_string_type module~pic_string_type->module~pic_ascii module~pic_strings pic_strings module~pic_strings->module~pic_ascii module~pic_strings->module~pic_string_type module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_string_type module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type_constructor->module~pic_string_type module~pic_string_type_constructor->module~pic_strings module~pic_strings_to_string pic_strings_to_string module~pic_strings_to_string->module~pic_string_type module~pic_strings_to_string->module~pic_strings proc~chomp_set_string_char chomp_set_string_char proc~chomp_set_string_char->module~pic_string_type proc~chomp_string chomp_string proc~chomp_string->module~pic_string_type proc~chomp_substring_string_char chomp_substring_string_char proc~chomp_substring_string_char->module~pic_string_type proc~chomp_substring_string_string chomp_substring_string_string proc~chomp_substring_string_string->module~pic_string_type proc~strip_string strip_string proc~strip_string->module~pic_string_type Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), public, parameter :: ACK = achar(int(z'06')) Acknowledge character(len=1), public, parameter :: BEL = achar(int(z'07')) Bell character(len=1), public, parameter :: BS = achar(int(z'08')) Backspace character(len=1), public, parameter :: CAN = achar(int(z'18')) Cancel character(len=1), public, parameter :: CR = achar(int(z'0D')) Carriage return character(len=1), public, parameter :: DC1 = achar(int(z'11')) Device control 1 character(len=1), public, parameter :: DC2 = achar(int(z'12')) Device control 2 character(len=1), public, parameter :: DC3 = achar(int(z'13')) Device control 3 character(len=1), public, parameter :: DC4 = achar(int(z'14')) Device control 4 character(len=1), public, parameter :: DEL = achar(int(z'7F')) Delete character(len=1), public, parameter :: DLE = achar(int(z'10')) Data link escape character(len=1), public, parameter :: EM = achar(int(z'19')) End of medium character(len=1), public, parameter :: ENQ = achar(int(z'05')) Enquiry character(len=1), public, parameter :: EOT = achar(int(z'04')) End of transmission character(len=1), public, parameter :: ESC = achar(int(z'1B')) Escape character(len=1), public, parameter :: ETB = achar(int(z'17')) End of transmission block character(len=1), public, parameter :: ETX = achar(int(z'03')) End of text character(len=1), public, parameter :: FF = achar(int(z'0C')) NP form feed, new page character(len=1), public, parameter :: FS = achar(int(z'1C')) File separator character(len=1), public, parameter :: GS = achar(int(z'1D')) Group separator character(len=1), public, parameter :: LF = achar(int(z'0A')) NL line feed, new line character(len=1), public, parameter :: NAK = achar(int(z'15')) Negative acknowledge character(len=1), public, parameter :: NUL = achar(int(z'00')) Null character(len=1), public, parameter :: RS = achar(int(z'1E')) Record separator character(len=1), public, parameter :: SI = achar(int(z'0F')) Shift in character(len=1), public, parameter :: SO = achar(int(z'0E')) Shift out character(len=1), public, parameter :: SOH = achar(int(z'01')) Start of heading character(len=1), public, parameter :: STX = achar(int(z'02')) Start of text character(len=1), public, parameter :: SUB = achar(int(z'1A')) Substitute character(len=1), public, parameter :: SYN = achar(int(z'16')) Synchronous idle character(len=1), public, parameter :: TAB = achar(int(z'09')) Horizontal tab character(len=1), public, parameter :: US = achar(int(z'1F')) Unit separator character(len=1), public, parameter :: VT = achar(int(z'0B')) Vertical tab character(len=*), public, parameter :: digits = hex_digits(1:10) 0 .. 9 character(len=*), public, parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" 0 .. 9A .. Fa .. f character(len=*), public, parameter :: hex_digits = fullhex_digits(1:16) 0 .. 9A .. F character(len=*), public, parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" A .. Za .. z character(len=*), public, parameter :: lowercase = letters(27:) a .. z character(len=*), public, parameter :: lowerhex_digits = \"0123456789abcdef\" 0 .. 9a .. f character(len=*), public, parameter :: octal_digits = digits(1:8) 0 .. 7 character(len=*), public, parameter :: uppercase = letters(1:26) A .. Z character(len=*), public, parameter :: whitespace = \" \"//TAB//VT//CR//LF//FF ASCII _whitespace Interfaces private        interface reverse Returns a new character sequence which is reverse of\nthe input charater sequence\nThis method is elemental and returns a character sequence private  interface reverse () Returns a new character sequence which is reverse of\nthe input charater sequence\nThis method is elemental and returns a character sequence Arguments None private        interface to_lower Returns a new character sequence which is the lower case\nversion of the input character sequence\nThis method is elemental and returns a character sequence private  interface to_lower () Returns a new character sequence which is the lower case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None private        interface to_sentence Returns a new character sequence which is the sentence case\nversion of the input character sequence\nThis method is elemental and returns a character sequence private  interface to_sentence () Returns a new character sequence which is the sentence case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None private        interface to_title Returns a new character sequence which is the title case\nversion of the input character sequence\nThis method is elemental and returns a character sequence private  interface to_title () Returns a new character sequence which is the title case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None private        interface to_upper Returns a new character sequence which is the upper case\nversion of the input character sequence\nThis method is elemental and returns a character sequence private  interface to_upper () Returns a new character sequence which is the upper case\nversion of the input character sequence\nThis method is elemental and returns a character sequence Arguments None Functions public elemental function is_alpha (c) Checks whether c is an ASCII letter (A .. Z, a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_alphanum (c) Checks whether c is a letter or a number (0 .. 9, a .. z, A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_ascii (c) Checks whether or not c is in the ASCII character set -\ni.e. in the range 0 .. 0x7F. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_blank (c) Checks whether or not c is a blank character. That includes the\nonly the space and tab characters Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_control (c) Checks whether c is a control character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_digit (c) Checks whether c is a digit (0 .. 9). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_graphical (c) Checks whether or not c is a printable character other than the\nspace character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_hex_digit (c) Checks whether c is a digit in base 16 (0 .. 9, A .. F, a .. f). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_lower (c) Checks whether c is a lowercase ASCII letter (a .. z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_octal_digit (c) Checks whether c is a digit in base 8 (0 .. 7). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_printable (c) Checks whether or not c is a printable character - including the\nspace character. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_punctuation (c) Checks whether or not c is a punctuation character. That includes\nall ASCII characters which are not control characters, letters,\ndigits, or whitespace. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_upper (c) Checks whether c is an uppercase ASCII letter (A .. Z). Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function is_white (c) Checks whether or not c is a whitespace character. That includes the\nspace, tab, vertical tab, form feed, carriage return, and linefeed\ncharacters. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c The character to test. Return Value logical public elemental function reverse (string) result(reverse_string) Reverse the character order in the input character variable Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) public elemental function to_lower (string) result(lower_string) Convert character variable to lower case Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) public elemental function to_sentence (string) result(sentence_string) Converts character sequence to sentence case Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) public elemental function to_title (string) result(title_string) Converts character sequence to title case Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) public elemental function to_upper (string) result(upper_string) Convert character variable to upper case Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=len) private elemental function char_to_lower (c) result(t) Returns the corresponding lowercase letter, if c is an uppercase\nASCII character, otherwise c itself. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1) private elemental function char_to_upper (c) result(t) Returns the corresponding uppercase letter, if c is a lowercase\nASCII character, otherwise c itself. Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: c A character. Return Value character(len=1)","tags":"","url":"module/pic_ascii.html"},{"title":"pic_strings – PIC","text":"This module implements basic string handling routines. Uses pic_optional_value iso_c_binding pic_string_type pic_ascii pic_types module~~pic_strings~~UsesGraph module~pic_strings pic_strings iso_c_binding iso_c_binding module~pic_strings->iso_c_binding module~pic_ascii pic_ascii module~pic_strings->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_strings->module~pic_optional_value module~pic_string_type pic_string_type module~pic_strings->module~pic_string_type module~pic_types pic_types module~pic_strings->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types module~pic_string_type->module~pic_ascii module~pic_string_type->module~pic_optional_value module~pic_string_type->module~pic_types module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by Descendants: pic_strings_to_string module~~pic_strings~~UsedByGraph module~pic_strings pic_strings module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type_constructor->module~pic_strings module~pic_strings_to_string pic_strings_to_string module~pic_strings_to_string->module~pic_strings Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface chomp Remove trailing characters in set from string.\nIf no character set is provided trailing whitespace is removed. Version: experimental private pure function chomp_string (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function chomp_char (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable private pure function chomp_set_string_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) private pure function chomp_set_char_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:), allocatable private pure function chomp_substring_string_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:), allocatable private pure function chomp_substring_string_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_char_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:), allocatable public        interface count Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’ private elemental function count_string_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer public        interface ends_with Check whether a string ends with substring or not Version: experimental private elemental function ends_with_string_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function ends_with_string_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_char_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function ends_with_char_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical public        interface find Finds the starting index of substring ‘pattern’ in the input ‘string’ Specifications Version: experimental private elemental function find_string_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer public        interface join Joins an array of strings into a single string.\nThe chunks are separated with a space, or an optional user-defined separator. private pure function join_string (strings, separator) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value type( string_type ) private pure function join_char (strings, separator) result(joined) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable public        interface padl Left pad the input string private pure function padl_string_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padl_string_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padl_char_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padl_char_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) public        interface padr Right pad the input string private pure function padr_string_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padr_string_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padr_char_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padr_char_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) public        interface replace_all Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nVersion: experimental private pure function replace_all_string_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_string_char_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_char_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_char_char (string, pattern, replacement) result(res) Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable public        interface slice Extracts characters from the input string to return a new string Version: experimental private elemental function slice_string (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) private pure function slice_char (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:), allocatable public        interface starts_with Check whether a string starts with substring or not Version: experimental private elemental function starts_with_string_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function starts_with_string_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_char_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function starts_with_char_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical public        interface strip Remove leading and trailing whitespace characters. Version: experimental private pure function strip_string (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function strip_char (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable public        interface to_c_char Format or transfer other types as a string. private pure function to_c_char_from_char (value) result(cstr) Convert a Fortran character string to a C character array Version: experimental Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(kind=c_char, len=1), (len(value)+1) private pure function to_c_char_from_string (value) result(cstr) Convert a Fortran string type to a C character array Version: experimental Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: value Return Value character(kind=c_char, len=1), (slen(value)+1) public        interface to_string Format or transfer other types as a string. private pure module function to_string_1_i_int32(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value Return Value character(len=:), allocatable private pure module function to_string_1_i_int64(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value Return Value character(len=:), allocatable private pure module function to_string_1_l_fbool(value) result(string) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value Return Value character(len=1) private pure module function to_string_2_i_int32(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_2_i_int64(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_2_l_fbool(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable private pure module function to_string_r_dp(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable private pure module function to_string_r_sp(value, format) result(string) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable public        interface zfill Left pad the input string with zeros. private pure function zfill_string (string, output_length) result(res) Left pad the input string with zeros Returns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function zfill_char (string, output_length) result(res) Left pad the input string with zeros Returns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) Functions private pure function chomp_char (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable private pure function chomp_set_char_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value character(len=:), allocatable private pure function chomp_set_string_char (string, set) result(chomped_string) Remove trailing characters in set from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=1), intent(in) :: set (:) Return Value type( string_type ) private pure function chomp_string (string) result(chomped_string) Remove trailing characters in set from string.\nDefault character set variant where trailing whitespace is removed. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function chomp_substring_char_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value character(len=:), allocatable private pure function chomp_substring_char_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value character(len=:), allocatable private pure function chomp_substring_string_char (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value type( string_type ) private pure function chomp_substring_string_string (string, substring) result(chomped_string) Remove trailing substrings from string. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value type( string_type ) private pure function compute_lps (string) result(lps_array) Computes longest prefix suffix for each index of the input ‘string’ Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value integer, (len(string)) private elemental function count_char_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_char_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_char (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function count_string_string (string, pattern, consider_overlapping) result(res) Returns the number of times substring ‘pattern’ has appeared in the\ninput string ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern logical, intent(in), optional :: consider_overlapping Return Value integer private pure function ends_with_char_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_char_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function ends_with_string_char (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function ends_with_string_string (string, substring) result(match) Check whether a string ends with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function find_char_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_char_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_char (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private elemental function find_string_string (string, pattern, occurrence, consider_overlapping) result(res) Returns the starting index of the ‘occurrence’th occurrence of substring ‘pattern’\nin input ‘string’\nReturns an integer Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern integer, intent(in), optional :: occurrence logical, intent(in), optional :: consider_overlapping Return Value integer private pure function join_char (strings, separator) result(joined) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value character(len=:), allocatable private pure function join_string (strings, separator) Joins a list of strings with a separator (default: space).\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: strings (:) character(len=*), intent(in), optional :: separator Return Value type( string_type ) private pure function padl_char_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padl_char_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) private pure function padl_string_default (string, output_length) result(res) Left pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padl_string_pad_with (string, output_length, pad_with) result(res) Left pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function padr_char_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function padr_char_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value character(kind=output_length), len=max) private pure function padr_string_default (string, output_length) result(res) Right pad the input string with ” ” (1 whitespace) Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type ) private pure function padr_string_pad_with (string, output_length, pad_with) result(res) Right pad the input string with the ‘pad_with’ character Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length character(len=1), intent(in) :: pad_with Return Value type( string_type ) private pure function replace_all_char_char_char (string, pattern, replacement) result(res) Replaces all the occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_char_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value character(len=:), allocatable private pure function replace_all_string_char_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_char_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_char (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern character(len=*), intent(in) :: replacement Return Value type( string_type ) private pure function replace_all_string_string_string (string, pattern, replacement) result(res) Replaces all occurrences of substring ‘pattern’ in the input ‘string’\nwith the replacement ‘replacement’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: pattern type( string_type ), intent(in) :: replacement Return Value type( string_type ) private pure function set_to_string (set) result(string) Implementation to transfer a set of characters to a string representing the set. Read more… Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: set (:) Return Value character(len=size) private pure function slice_char (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value character(len=:), allocatable private elemental function slice_string (string, first, last, stride) result(sliced_string) Extract the characters from the region between ‘first’ and ‘last’ index (both inclusive)\nof the input ‘string’ by taking strides of length ‘stride’\nReturns a new string Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in), optional :: first integer, intent(in), optional :: last integer, intent(in), optional :: stride Return Value type( string_type ) private pure function starts_with_char_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_char_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private elemental function starts_with_string_char (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string character(len=*), intent(in) :: substring Return Value logical private elemental function starts_with_string_string (string, substring) result(match) Check whether a string starts with substring or not Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string type( string_type ), intent(in) :: substring Return Value logical private pure function strip_char (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Return Value character(len=:), allocatable private pure function strip_string (string) result(stripped_string) Remove leading and trailing whitespace characters. Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string Return Value type( string_type ) private pure function to_c_char_from_char (value) result(cstr) Convert a Fortran character string to a C character array Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: value Return Value character(kind=c_char, len=1), (len(value)+1) private pure function to_c_char_from_string (value) result(cstr) Convert a Fortran string type to a C character array Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: value Return Value character(kind=c_char, len=1), (slen(value)+1) private pure function zfill_char (string, output_length) result(res) Left pad the input string with zeros Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string integer, intent(in) :: output_length Return Value character(kind=output_length), len=max) private pure function zfill_string (string, output_length) result(res) Left pad the input string with zeros Read more… Arguments Type Intent Optional Attributes Name type( string_type ), intent(in) :: string integer, intent(in) :: output_length Return Value type( string_type )","tags":"","url":"module/pic_strings.html"},{"title":"pic_sorting_ord_sort – PIC","text":"The generic subroutine implementing the ORD_SORT algorithm to return\n an input array with its elements sorted in order of (non-)decreasing\n value. Its use has the syntax: call ord_sort( array[, work, reverse] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) , type(bitset_64) , type(bitset_large) . If both the\n   type of array is real and at least one of the elements is a NaN , then the ordering of the result is undefined. Otherwise it\n   is defined to be the original elements in non-decreasing order. work (optional): shall be a rank 1 array of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as “scratch” memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in stable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in stable order. Example ... ! Read arrays from sorted files call read_sorted_file ( 'dummy_file1' , array1 ) call read_sorted_file ( 'dummy_file2' , array2 ) ! Concatenate the arrays allocate ( array ( size ( array1 ) + size ( array2 ) ) ) array ( 1 : size ( array1 ) ) = array1 (:) array ( size ( array1 ) + 1 : size ( array1 ) + size ( array2 ) ) = array2 (:) ! Sort the resulting array call ord_sort ( array , work ) ! Process the sorted array call array_search ( array , values ) ... Uses pic_optional_value pic_types module~~pic_sorting_ord_sort~~UsesGraph module~pic_sorting_ord_sort pic_sorting_ord_sort module~pic_optional_value pic_optional_value module~pic_sorting_ord_sort->module~pic_optional_value module~pic_types pic_types module~pic_sorting_ord_sort->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_sorting_ord_sort~~UsedByGraph module~pic_sorting_ord_sort pic_sorting_ord_sort module~pic_sorting pic_sorting module~pic_sorting->module~pic_sorting_ord_sort Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_merge_stack = int(ceiling(log(2._dp**64)/log(1.6180339887_dp))) Interfaces public        interface ord_sort The generic subroutine interface implementing the ORD_SORT algorithm,\na translation to Fortran 2008, of the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\nand insertion sort . It is always at worst O(N Ln(N)) in sorting random\ndata, having a performance about 25% slower than SORT on such\ndata, but has much better performance than SORT on partially\nsorted data, having O(N) performance on uniformly non-increasing or\nnon-decreasing data. private module subroutine char_ord_sort(array, work, reverse) Implementation → char_ord_sort( array ) sorts the input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine dp_ord_sort(array, work, reverse) Implementation → dp_ord_sort( array ) sorts the input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine int32_ord_sort(array, work, reverse) Implementation → int32_ord_sort( array ) sorts the input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine int64_ord_sort(array, work, reverse) Implementation → int64_ord_sort( array ) sorts the input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private module subroutine sp_ord_sort(array, work, reverse) Implementation → sp_ord_sort( array ) sorts the input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse Derived Types type, private :: run_type Used to pass state around in a stack among helper functions for the ORD_SORT and SORT_INDEX algorithms Components Type Visibility Attributes Name Initial integer(kind=int_index), public :: base = 0 integer(kind=int_index), public :: len = 0 Subroutines private  subroutine char_decrease_ord_sort (array, work) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) private  subroutine char_increase_ord_sort (array, work) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) private module subroutine char_ord_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) character(len=len), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private  subroutine dp_decrease_ord_sort (array, work) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) private  subroutine dp_increase_ord_sort (array, work) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) private module subroutine dp_ord_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) real(kind=dp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private  subroutine int32_decrease_ord_sort (array, work) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) private  subroutine int32_increase_ord_sort (array, work) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) private module subroutine int32_ord_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int32), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private  subroutine int64_decrease_ord_sort (array, work) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) private  subroutine int64_increase_ord_sort (array, work) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) private module subroutine int64_ord_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int64), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse private  subroutine sp_decrease_ord_sort (array, work) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) private  subroutine sp_increase_ord_sort (array, work) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) private module subroutine sp_ord_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) real(kind=sp), intent(out), optional :: work (0:) logical, intent(in), optional :: reverse","tags":"","url":"module/pic_sorting_ord_sort.html"},{"title":"pic_global_definitions – PIC","text":"Global definitions for input output Uses pic_types module~~pic_global_definitions~~UsesGraph module~pic_global_definitions pic_global_definitions module~pic_types pic_types module~pic_global_definitions->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_global_definitions~~UsedByGraph module~pic_global_definitions pic_global_definitions module~pic_logger pic_logger module~pic_logger->module~pic_global_definitions module~pic_test_helpers pic_test_helpers module~pic_test_helpers->module~pic_global_definitions module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: logfile_unit = 99 assign output unit 99 for the logfile integer(kind=default_int), public, parameter :: stdout = 6 assign output unit 6 for stdout real(kind=dp), public, parameter :: tol_dp = 1.0e-12_dp real(kind=sp), public, parameter :: tol_sp = 1.0e-6_sp","tags":"","url":"module/pic_global_definitions.html"},{"title":"pic_constants – PIC","text":"this will be the physical constants module Uses pic_types module~~pic_constants~~UsesGraph module~pic_constants pic_constants module~pic_types pic_types module~pic_constants->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: gravity = 9.81_dp","tags":"","url":"module/pic_constants.html"},{"title":"pic_sorting – PIC","text":"This module implements overloaded sorting subroutines named ORD_SORT , SORT_INDEX , and SORT , that each can be used to sort two kinds\nof INTEGER arrays, two kinds of REAL arrays, character(len=*) arrays By default sorting is in order of\nincreasing value, but there is an option to sort in decreasing order.\nAll the subroutines have worst case run time performance of O(N Ln(N)) ,\nbut on largely sorted data ORD_SORT and SORT_INDEX can have a run time\nperformance of O(N) . ORD_SORT is a translation of the \"Rust\" sort sorting algorithm in slice.rs :\nhttps://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs\nwhich in turn is inspired by the timsort algorithm of Tim Peters,\nhttp://svn.python.org/projects/python/trunk/Objects/listsort.txt. ORD_SORT is a hybrid stable comparison algorithm combining merge sort ,\nand insertion sort . It is always at worst O(N Ln(N)) in sorting random\ndata, having a performance about 25% slower than SORT on such\ndata, but has much better performance than SORT on partially\nsorted data, having O(N) performance on uniformly non-increasing or\nnon-decreasing data. SORT_INDEX is a modification of ORD_SORT so that in addition to\nsorting the input array, it returns the indices that map to a\nstable sort of the original array. These indices are\nintended to be used to sort data that is correlated with the input\narray, e.g., different arrays in a database, different columns of a\nrank 2 array, different elements of a derived type. It is less\nefficient than ORD_SORT at sorting a simple array. SORT uses the INTROSORT sorting algorithm of David Musser,\nhttp://www.cs.rpi.edu/~musser/gp/introsort.ps. introsort is a hybrid\nunstable comparison algorithm combining quicksort , insertion sort , and heap sort . While this algorithm is always O(N Ln(N)) it is relatively\nfast on randomly ordered data, but inconsistent in performance on partly\nsorted data, sometimes having merge sort performance, sometimes having\nbetter than quicksort performance. UNORD_SOORT is about 25%\nmore efficient than ORD_SORT at sorting purely random data, but af an\norder of Ln(N) less efficient at sorting partially sorted data. Uses pic_optional_value pic_sorting_radix_sort pic_sorting_sort pic_sorting_sort_index pic_types pic_sorting_ord_sort module~~pic_sorting~~UsesGraph module~pic_sorting pic_sorting module~pic_optional_value pic_optional_value module~pic_sorting->module~pic_optional_value module~pic_sorting_ord_sort pic_sorting_ord_sort module~pic_sorting->module~pic_sorting_ord_sort module~pic_sorting_radix_sort pic_sorting_radix_sort module~pic_sorting->module~pic_sorting_radix_sort module~pic_sorting_sort pic_sorting_sort module~pic_sorting->module~pic_sorting_sort module~pic_sorting_sort_index pic_sorting_sort_index module~pic_sorting->module~pic_sorting_sort_index module~pic_types pic_types module~pic_sorting->module~pic_types module~pic_optional_value->module~pic_types module~pic_sorting_ord_sort->module~pic_optional_value module~pic_sorting_ord_sort->module~pic_types module~pic_sorting_radix_sort->module~pic_optional_value module~pic_sorting_radix_sort->module~pic_types module~pic_sorting_sort->module~pic_optional_value module~pic_sorting_sort->module~pic_types module~pic_sorting_sort_index->module~pic_optional_value module~pic_sorting_sort_index->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/pic_sorting.html"},{"title":"pic_command_line – PIC","text":"command line interaction module Uses pic_types module~~pic_command_line~~UsesGraph module~pic_command_line pic_command_line module~pic_types pic_types module~pic_command_line->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_first_arg_from_command_line () result(filename) get the first argument from the command line, this is expected to be a filename Read more… Arguments None Return Value character(len=255)","tags":"","url":"module/pic_command_line.html"},{"title":"pic_device – PIC","text":"contains the general routines that interface to the pic_gpu_runtime module\nthere are not C interfaces in this file Uses iso_c_binding pic_types pic_gpu_runtime module~~pic_device~~UsesGraph module~pic_device pic_device iso_c_binding iso_c_binding module~pic_device->iso_c_binding module~pic_gpu_runtime pic_gpu_runtime module~pic_device->module~pic_gpu_runtime module~pic_types pic_types module~pic_device->module~pic_types module~pic_gpu_runtime->iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface to_string convenient way to print the device_type using to_string(my_device) private  function to_string_device (self) result(str) cute printing routine for the pic device type, transforms the contents into a\nstring of chars Arguments Type Intent Optional Attributes Name class( device_type ), intent(in) :: self Return Value character(len=:), allocatable Derived Types type, public :: device_type general device container, contains the id, free, total , and used memory Components Type Visibility Attributes Name Initial integer(kind=c_int), public :: device_id = -1_c_int real(kind=dp), public :: free_mb = 0.0_dp real(kind=dp), public :: total_mb = 0.0_dp real(kind=dp), public :: used_mb = 0.0_dp Type-Bound Procedures procedure, public, non_overridable :: get_device_info => get_gpu_information Functions private  function to_string_device (self) result(str) cute printing routine for the pic device type, transforms the contents into a\nstring of chars Arguments Type Intent Optional Attributes Name class( device_type ), intent(in) :: self Return Value character(len=:), allocatable Subroutines public  subroutine get_device_id (mem) routine to get the device id for the device_type Arguments Type Intent Optional Attributes Name type( device_type ), intent(inout) :: mem public  subroutine get_gpu_information (self) call my_device%get_gpu_informatio() style subroutine to populate the object Arguments Type Intent Optional Attributes Name class( device_type ), intent(inout) :: self public  subroutine get_gpu_memory_info (mem) routine to get the free and total memory for the device_type object\ncan be used independently with call get_gpu_memory_info(device_object) Arguments Type Intent Optional Attributes Name type( device_type ), intent(inout) :: mem","tags":"","url":"module/pic_device.html"},{"title":"pic_hash_32bit – PIC","text":"Uses pic_types pic_hash_32bit_fnv module~~pic_hash_32bit~~UsesGraph module~pic_hash_32bit pic_hash_32bit module~pic_hash_32bit_fnv pic_hash_32bit_fnv module~pic_hash_32bit->module~pic_hash_32bit_fnv module~pic_types pic_types module~pic_hash_32bit->module~pic_types module~pic_hash_32bit_fnv->module~pic_types iso_fortran_env iso_fortran_env module~pic_hash_32bit_fnv->iso_fortran_env iso_c_binding iso_c_binding module~pic_types->iso_c_binding module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private, parameter :: pow32_over_phi = int(z'9E3779B9', int32)","tags":"","url":"module/pic_hash_32bit.html"},{"title":"pic_gpu_runtime – PIC","text":"gpu runtime interfaces via iso_c Uses iso_c_binding module~~pic_gpu_runtime~~UsesGraph module~pic_gpu_runtime pic_gpu_runtime iso_c_binding iso_c_binding module~pic_gpu_runtime->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_gpu_runtime~~UsedByGraph module~pic_gpu_runtime pic_gpu_runtime module~pic_device pic_device module~pic_device->module~pic_gpu_runtime Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine gpugetdevice (device_id, ierr) get current device id from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: device_id integer(kind=c_int), intent(out) :: ierr public  subroutine gpugetdevicecount (device_count, ierr) get device count available from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(out) :: device_count integer(kind=c_int), intent(out) :: ierr public  subroutine gpugetmeminfo (freeMem, totalMem, ierr) get free and total memory from the GPU runtime Arguments Type Intent Optional Attributes Name integer(kind=c_size_t), intent(out) :: freeMem integer(kind=c_size_t), intent(out) :: totalMem integer(kind=c_int), intent(out) :: ierr","tags":"","url":"module/pic_gpu_runtime.html"},{"title":"pic_knowledge – PIC","text":"a simple module that collects phrases and prints them out randomly, like fortune Uses pic_string_type pic_types pic_logger module~~pic_knowledge~~UsesGraph module~pic_knowledge pic_knowledge module~pic_logger pic_logger module~pic_knowledge->module~pic_logger module~pic_string_type pic_string_type module~pic_knowledge->module~pic_string_type module~pic_types pic_types module~pic_knowledge->module~pic_types module~pic_logger->module~pic_types module~pic_global_definitions pic_global_definitions module~pic_logger->module~pic_global_definitions module~pic_string_type->module~pic_types module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env module~pic_ascii->module~pic_types module~pic_global_definitions->module~pic_types module~pic_optional_value->module~pic_types Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine get_knowledge () I print random knowledge Arguments None","tags":"","url":"module/pic_knowledge.html"},{"title":"pic_logger – PIC","text":"this is the logger module Uses pic_global_definitions pic_types module~~pic_logger~~UsesGraph module~pic_logger pic_logger module~pic_global_definitions pic_global_definitions module~pic_logger->module~pic_global_definitions module~pic_types pic_types module~pic_logger->module~pic_types module~pic_global_definitions->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_logger~~UsedByGraph module~pic_logger pic_logger module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_logger Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: debug_level = 10 integer(kind=default_int), public, parameter :: error_level = 5 type( logger_type ), public :: global_logger integer(kind=default_int), public, parameter :: info_level = 8 integer(kind=default_int), public, parameter :: knowledge_level = 4 integer(kind=default_int), public, parameter :: performance_level = 7 integer(kind=default_int), public, parameter :: verbose_level = 9 integer(kind=default_int), public, parameter :: warning_level = 6 character(len=*), private, parameter :: name = \"pic_logger\" Derived Types type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info logical, private :: log_file_open = .false. integer(kind=default_int), private :: log_file_unit = -1 Type-Bound Procedures procedure, public, pass(self), non_overridable :: close_log_file Close the log file, needs to be called at the end of the program.\nUsage: call my_logger%close_log_file() procedure, public, pass(self), non_overridable :: configuration Get the current logger verbosity configuration.\nUsage: call my_logger%configuration(level) procedure, public, pass(self), non_overridable :: configure Configure the logger to be a certain verbosity level.\nUsage: call my_logger%configure(level) procedure, public, pass(self), non_overridable :: configure_file_output Configure the logger to file to be a certain verbosity level.\nUsage: call my_logger%configure_file_output(filename, level) procedure, public, pass(self), non_overridable :: debug Log a message that will only be printed at the debug level of verbosity.\nUsage: call my_logger%debug(“MESSAGE”) procedure, public, pass(self), non_overridable :: error Log a message that will only be printed at the error level of verbosity.\nUsage: call my_logger%error(“MESSAGE”) procedure, public, pass(self), non_overridable :: info Log a message that will only be printed at the info level of verbosity.\nUsage: call my_logger%info(“MESSAGE”) procedure, public, pass(self), non_overridable :: knowledge Log a message that will only be printed at the knowledge level of verbosity.\nUsage: call my_logger%knowledge(“MESSAGE”) procedure, public, pass(self), non_overridable :: performance Log a message that will only be printed at the performance level of verbosity.\nUsage: call my_logger%performance(“MESSAGE”) procedure, public, pass(self), non_overridable :: verbose Log a message that will only be printed at the verbose level of verbosity.\nUsage: call my_logger%verbose(“MESSAGE”) procedure, public, pass(self), non_overridable :: warning Log a message that will only be printed at the warning level of verbosity.\nUsage: call my_logger%warning(“MESSAGE”) procedure, private, pass(self), non_overridable :: log Processes the message and filters it according to the verbosity level set by the user or the default Subroutines private  subroutine close_log_file (self) Close the log file, needs to be called at the end of the program Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self private pure subroutine configuration (self, level) Get the current logger verbosity configuration Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level private pure subroutine configure (self, level) Configure the logger to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level private  subroutine configure_file_output (self, filename, level) Configure the logger to file to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level private  subroutine debug (self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine error (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine info (self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine knowledge (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine log (self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine performance (self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine verbose (self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine warning (self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine write_log_line (unit, level, message, module, procedure) Internal subroutine that will write the message to the log\nno interface to the public Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: unit character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure","tags":"","url":"module/pic_logger.html"},{"title":"pic_array – PIC","text":"Please do not modify this file to implement new methods, please go look at tools/autogen/pic_array_cpu.fypp\nand edit the generator. Uses pic_optional_value pic_types pic_io module~~pic_array~~UsesGraph module~pic_array pic_array module~pic_io pic_io module~pic_array->module~pic_io module~pic_optional_value pic_optional_value module~pic_array->module~pic_optional_value module~pic_types pic_types module~pic_array->module~pic_types module~pic_io->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: ASCENDING = 1 integer(kind=default_int), public, parameter :: DESCENDING = 2 integer(kind=default_int), private, parameter :: block_size = 32 This is the size to block over for matrices for performance purposes character(len=5), private, parameter :: default_format = \"NUMPY\" supported formats: NUMPY, MATHEMATICA, and PLAIN which resembles numpy character(len=*), private, parameter :: fmt_edge = \"(A)\" character(len=*), private, parameter :: fmt_in = '(A, \", \")' logical, private :: use_threaded_default = .false. Interfaces public        interface get_threading_mode get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() private  function get_threading_mode_ () result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical public        interface is_sorted is_sorted provides a simple way to checking if a 1d array is sorted\nit is implemented for int32, int64, sp, and dp datatypes. The default\nis to check if an array is sorted in ascending fashion. Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_char (array, order) result(sorted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical public        interface pic_copy copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy\nif you built pic with BLAS use the copy interface provided there, I will not beat BLAS\ncopy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types Usage: call pic_copy(destination, source, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:,:) integer(kind=int32), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:,:) integer(kind=int64), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:,:) real(kind=sp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:,:) real(kind=dp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded public        interface pic_fill fill provides a generic interface to assing a value\nalpha of types (int32, int64, sp, dp) as defined in pic_types.F90\nThe inteface supports filling 1d and 2d arrays of the specified\nvariables Usage: call pic_fill(array, value, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int32 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: tensor (:,:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int64 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: tensor (:,:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_sp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: tensor (:,:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_dp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (:,:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded public        interface pic_print_array Generic interface for printing arrays of different types Usage: call pic_print_array(array, [optional] format)\nWhere format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) Implemented types are: array(:)   -> int32, int64, sp, dp array(:,:) -> int32, int64, sp, dp array(:) (packed matrix) -> sp, dp array(:,:,:) -> sp, dp private  subroutine print_vector_int32 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int32 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int64 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type public        interface pic_scramble_array private  subroutine scramble_array_int32 (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (:) private  subroutine scramble_array_int64 (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (:) private  subroutine scramble_array_sp (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (:) private  subroutine scramble_array_dp (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (:) private  subroutine scramble_array_character (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (:) public        interface pic_sum pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will\nbe too slow for large sizes of vectors and matrices. Note that this provides the total\nsum. As opposed to the blas alternative XASUM which does the absolute sum pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays Usage: result = pic_sum(array, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_3d_tensor_int32 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_3d_tensor_int64 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_3d_tensor_sp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_3d_tensor_dp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) public        interface pic_transpose pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic\nwhich will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded public        interface set_threading_mode set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) private  subroutine set_threading_mode_ (threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Usage: call set_threading(.true.) or call set_threading(.false.) Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded Functions private  function get_threading_mode_ () result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical private pure function is_sorted_char (array, order) result(sorted) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private  function sum_3d_tensor_dp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_3d_tensor_int32 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_3d_tensor_int64 (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_3d_tensor_sp (tensor, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: tensor (:,:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Subroutines private  subroutine copy_3d_tensor_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:,:) real(kind=dp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:,:) integer(kind=int32), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:,:) integer(kind=int64), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_3d_tensor_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:,:) real(kind=sp), intent(in) :: source (:,:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_dp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: tensor (:,:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int32 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: tensor (:,:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_int64 (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: tensor (:,:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_3d_tensor_sp (tensor, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: tensor (:,:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int32 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_int64 (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int32 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of  values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine scramble_array_character (array) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (:) private  subroutine scramble_array_dp (array) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (:) private  subroutine scramble_array_int32 (array) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (:) private  subroutine scramble_array_int64 (array) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (:) private  subroutine scramble_array_sp (array) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (:) private  subroutine set_brackets (format_type, open_bracket, close_bracket) Set brackets based on output format type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: format_type character(len=1), intent(out) :: open_bracket character(len=1), intent(out) :: close_bracket private  subroutine set_threading_mode_ (threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded","tags":"","url":"module/pic_array.html"},{"title":"pic_sorting_radix_sort – PIC","text":"The generic subroutine implementing the LSD radix sort algorithm to return\n an input array with its elements sorted in order of (non-)decreasing\n value. Its use has the syntax: call radix_sort( array[, work, reverse] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) .\n   If both the type of array is real and at least one of the\n   elements is a NaN , then the ordering of the result is undefined.\n   Otherwise it is defined to be the original elements in\n   non-decreasing order. Especially, -0.0 is lesser than 0.0. work (optional): shall be a rank 1 array of the same type as array , and shall have at least size(array) elements. It is an intent(inout) argument to be used as buffer. Its value on return is\n   undefined. If it is not present, radix_sort will allocate a\n   buffer for use, and deallocate it before return. If you do several\n   similar radix_sort s, reusing the work array is a good parctice.\n   This argument is not present for int8_radix_sort because it use\n   counting sort, so no buffer is needed. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then array will be sorted in order of non-increasing values in stable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in stable order. Example ... ! Read random data from a file call read_file ( 'dummy_file' , array ) ! Sort the random data call radix_sort ( array ) ... Uses pic_optional_value pic_types module~~pic_sorting_radix_sort~~UsesGraph module~pic_sorting_radix_sort pic_sorting_radix_sort module~pic_optional_value pic_optional_value module~pic_sorting_radix_sort->module~pic_optional_value module~pic_types pic_types module~pic_sorting_radix_sort->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_sorting_radix_sort~~UsedByGraph module~pic_sorting_radix_sort pic_sorting_radix_sort module~pic_sorting pic_sorting module~pic_sorting->module~pic_sorting_radix_sort Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: radix_bits = 8 integer(kind=int32), private, parameter :: radix_bits_i32 = 8_int32 integer(kind=int64), private, parameter :: radix_bits_i64 = 8_int64 integer, private, parameter :: radix_mask = 255 integer(kind=int32), private, parameter :: radix_mask_i32 = 255_int32 integer(kind=int64), private, parameter :: radix_mask_i64 = 255_int64 Interfaces public        interface radix_sort The generic subroutine interface implementing the LSD radix sort algorithm,\nsee https://en.wikipedia.org/wiki/Radix_sort for more details.\nIt is always O(N) in sorting random data, but need a O(N) buffer.\n( Specification ) private module subroutine dp_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:), target :: array real(kind=dp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int32_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: array integer(kind=int32), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int64_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: array integer(kind=int64), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private module subroutine sp_radix_sort(array, work, reverse) Implementation → Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), dimension(:), target :: array real(kind=sp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse Subroutines private module subroutine dp_radix_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout), dimension(:), target :: array real(kind=dp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int32_radix_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout), dimension(:) :: array integer(kind=int32), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure module subroutine int64_radix_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout), dimension(:) :: array integer(kind=int64), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse private pure subroutine radix_sort_u32_helper (N, arr, buf) Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: N integer(kind=int32), intent(inout), dimension(N) :: arr integer(kind=int32), intent(inout), dimension(N) :: buf private pure subroutine radix_sort_u64_helper (N, arr, buffer) Arguments Type Intent Optional Attributes Name integer(kind=int_index), intent(in) :: N integer(kind=int64), intent(inout), dimension(N) :: arr integer(kind=int64), intent(inout), dimension(N) :: buffer private module subroutine sp_radix_sort (array, work, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout), dimension(:), target :: array real(kind=sp), intent(inout), optional, dimension(:), target :: work logical, intent(in), optional :: reverse","tags":"","url":"module/pic_sorting_radix_sort.html"},{"title":"pic_optional_value – PIC","text":"This module provides functions to handle optional arguments Uses pic_types module~~pic_optional_value~~UsesGraph module~pic_optional_value pic_optional_value module~pic_types pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_optional_value~~UsedByGraph module~pic_optional_value pic_optional_value module~pic_array pic_array module~pic_array->module~pic_optional_value module~pic_sorting pic_sorting module~pic_sorting->module~pic_optional_value module~pic_sorting_ord_sort pic_sorting_ord_sort module~pic_sorting->module~pic_sorting_ord_sort module~pic_sorting_radix_sort pic_sorting_radix_sort module~pic_sorting->module~pic_sorting_radix_sort module~pic_sorting_sort pic_sorting_sort module~pic_sorting->module~pic_sorting_sort module~pic_sorting_sort_index pic_sorting_sort_index module~pic_sorting->module~pic_sorting_sort_index module~pic_sorting_ord_sort->module~pic_optional_value module~pic_sorting_radix_sort->module~pic_optional_value module~pic_sorting_sort->module~pic_optional_value module~pic_sorting_sort_index->module~pic_optional_value module~pic_string_type pic_string_type module~pic_string_type->module~pic_optional_value module~pic_strings pic_strings module~pic_strings->module~pic_optional_value module~pic_strings->module~pic_string_type module~pic_knowledge pic_knowledge module~pic_knowledge->module~pic_string_type module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type_constructor->module~pic_string_type module~pic_string_type_constructor->module~pic_strings module~pic_strings_to_string pic_strings_to_string module~pic_strings_to_string->module~pic_string_type module~pic_strings_to_string->module~pic_strings proc~chomp_set_string_char chomp_set_string_char proc~chomp_set_string_char->module~pic_string_type proc~chomp_string chomp_string proc~chomp_string->module~pic_string_type proc~chomp_substring_string_char chomp_substring_string_char proc~chomp_substring_string_char->module~pic_string_type proc~chomp_substring_string_string chomp_substring_string_string proc~chomp_substring_string_string->module~pic_string_type proc~strip_string strip_string proc~strip_string->module~pic_string_type Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface pic_optional Overloaded interface for optional value retrieval, supported types are:\n- integer(int32), integer(int64), real(sp), real(dp), character(len=*), logical private pure function optional_int32 (input_value, default_value) result(output) Handle optional integer(int32) value Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Handle optional integer(int64) value Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_sp (input_value, default_value) result(output) Handle optional real(sp) value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) private pure function optional_dp (input_value, default_value) result(output) Handle optional real(dp) value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_char (input_value, default_value) result(output) Handle optional character(len=*) value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable private pure function optional_logical (input_value, default_value) result(output) Handle optional logical value Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: input_value logical, intent(in) :: default_value Return Value logical Functions private pure function optional_char (input_value, default_value) result(output) Handle optional character(len=*) value Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable private pure function optional_dp (input_value, default_value) result(output) Handle optional real(dp) value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_int32 (input_value, default_value) result(output) Handle optional integer(int32) value Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Handle optional integer(int64) value Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_logical (input_value, default_value) result(output) Handle optional logical value Arguments Type Intent Optional Attributes Name logical, intent(in), optional :: input_value logical, intent(in) :: default_value Return Value logical private pure function optional_sp (input_value, default_value) result(output) Handle optional real(sp) value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp)","tags":"","url":"module/pic_optional_value.html"},{"title":"pic_flop_rate – PIC","text":"pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer\nit is used to measure the flop rate of a given operation, and report it Uses pic_types pic_flop_recorder pic_io pic_timer module~~pic_flop_rate~~UsesGraph module~pic_flop_rate pic_flop_rate module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_io pic_io module~pic_flop_rate->module~pic_io module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_types pic_types module~pic_flop_rate->module~pic_types module~pic_flop_recorder->module~pic_types module~pic_io->module~pic_types module~pic_timer->module~pic_io module~pic_timer->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Components Type Visibility Attributes Name Initial real(kind=dp), private :: m_flop_rate private by default so that people use the accessor functions type( flop_recorder_type ), private :: m_flops type( timer_type ), private :: m_timer Type-Bound Procedures procedure, public, non_overridable :: add_flops => flop_rate_add_flops procedure, public, non_overridable :: get_flop_rate => flop_rate_get_flop_rate procedure, public, non_overridable :: get_flops => flop_rate_get_flops procedure, public, non_overridable :: get_time => flop_rate_get_time procedure, public, non_overridable :: report => flop_rate_report procedure, public, non_overridable :: reset => flop_rate_reset procedure, public, non_overridable :: start_time => flop_rate_start_time procedure, public, non_overridable :: stop_time => flop_rate_stop_time Functions private  function flop_rate_get_flop_rate (self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) private  function flop_rate_get_flops (self) result(flops) get the number of flops recorded in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) private  function flop_rate_get_time (self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) Subroutines private  subroutine flop_rate_add_flops (self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops private  subroutine flop_rate_report (self) report the flop rate, this will print the flop rate in GFLOP/s Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_reset (self) reset the flop rate type, this will reset the timer and the flop recorder Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_start_time (self) Calls the start method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_stop_time (self) Calls the stop method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self","tags":"","url":"module/pic_flop_rate.html"},{"title":"pic_hash_32bit_fnv – PIC","text":"An implementation of the FNV hashes 1 and 1a of Glenn Fowler, Landon Curt\nNoll, and Kiem-Phong-Vo,\nhttps://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function Uses pic_types iso_fortran_env module~~pic_hash_32bit_fnv~~UsesGraph module~pic_hash_32bit_fnv pic_hash_32bit_fnv iso_fortran_env iso_fortran_env module~pic_hash_32bit_fnv->iso_fortran_env module~pic_types pic_types module~pic_hash_32bit_fnv->module~pic_types module~pic_types->iso_fortran_env iso_c_binding iso_c_binding module~pic_types->iso_c_binding Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_hash_32bit_fnv~~UsedByGraph module~pic_hash_32bit_fnv pic_hash_32bit_fnv module~pic_hash_32bit pic_hash_32bit module~pic_hash_32bit->module~pic_hash_32bit_fnv Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: int_hash = int32 logical, public, parameter :: little_endian = (1==transfer([1_int8, 0_int8], 0_int16)) integer, private, parameter :: bits_char = character_storage_size integer, private, parameter :: bits_int16 = bit_size(0_int16) integer, private, parameter :: bits_int32 = bit_size(0_int32) integer, private, parameter :: bits_int64 = bit_size(0_int64) integer, private, parameter :: bits_int8 = bit_size(0_int8) integer, private, parameter :: bytes_char = bits_char/bits_int8 integer, private, parameter :: bytes_int16 = bits_int16/bits_int8 integer, private, parameter :: bytes_int32 = bits_int32/bits_int8 integer, private, parameter :: bytes_int64 = bits_int64/bits_int8 integer, private, parameter :: bytes_int8 = bits_int8/bits_int8 integer(kind=int_hash), private, parameter :: offset_basis = int(z'811C9DC5', int_hash) The number of bits in the output hash integer(kind=int_hash), private, parameter :: prime = int(z'01000193', int_hash) The number of bits in the output hash Interfaces public        interface fnv_1_hash FNV_1 interfaces private elemental module function character_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for default character string keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private pure module function int16_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int16 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1(key) result(hash_code) Implementation → FNV_1 hash function for rank 1 array keys of kind int8 Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash) public        interface fnv_1a_hash FNV_1A interfaces private elemental module function character_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for default character string keys Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private pure module function int16_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int16 Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int32 Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int64 Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1a(key) result(hash_value) Implementation → FNV_1A hash function for rank 1 array keys of kind int8 Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash) Functions private elemental module function character_fnv_1 (key) result(hash_code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private elemental module function character_fnv_1a (key) result(hash_code) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: key Return Value integer(kind=int_hash) private pure module function int16_fnv_1 (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int16_fnv_1a (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int16), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1 (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int32_fnv_1a (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1 (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int64_fnv_1a (key) result(hash_code) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1 (key) result(hash_code) The original FNV-1 8-bit key algorithm. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash) private pure module function int8_fnv_1a (key) result(hash_code) The original FNV-1a 8-bit key algorithm. Arguments Type Intent Optional Attributes Name integer(kind=int8), intent(in) :: key (:) Return Value integer(kind=int_hash)","tags":"","url":"module/pic_hash_32bit_fnv.html"},{"title":"pic_io – PIC","text":"Assorted output helper routines Uses pic_types module~~pic_io~~UsesGraph module~pic_io pic_io module~pic_types pic_types module~pic_io->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_io~~UsedByGraph module~pic_io pic_io module~pic_array pic_array module~pic_array->module~pic_io module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_io module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_timer->module~pic_io Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private, parameter :: default_dp_precision = 12 integer(kind=default_int), private, parameter :: default_sp_precision = 6 integer(kind=default_int), private :: dp_precision = default_dp_precision integer(kind=default_int), private :: sp_precision = default_sp_precision Interfaces public        interface set_precision This routine overrides the default dp precision used for\nprinting strings in the to_char function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Usage: call set_precision(variable) where variable is default_int private  subroutine set_precision_internal (precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision public        interface to_char converts a variable of type (int32, int64, sp, dp, char, logical)\nto a series of chars which is just a collecting of chars. Usage result = to_char(variable) arrays. Please use pic_print_array_v2 module for this private  function to_char_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_char_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable private  function to_char_vector_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_matrix_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:,:) Return Value character(len=:), allocatable private        interface get_precision Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result private  interface get_precision () Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result Arguments None private        interface pad adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) private  interface pad () adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) Arguments None private        interface to_upper takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) private  interface to_upper () takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) Arguments None Functions public  function get_precision () result(precision) Get the current precision for real numbers Arguments None Return Value integer(kind=default_int) public  function pad (s, width) result(padded) function to pad a string with a certain number of characters for nice printing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer(kind=default_int), intent(in) :: width Return Value character(len=:), allocatable public  function to_upper (str) result(upper_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) private  function to_char_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_char_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_char_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable private  function to_char_matrix_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_matrix_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:,:) Return Value character(len=:), allocatable private  function to_char_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable private  function to_char_vector_dp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_int32 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_int64 (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) Return Value character(len=:), allocatable private  function to_char_vector_sp (array) result(trimmed_str) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) Return Value character(len=:), allocatable Subroutines public  subroutine print_asterisk_row (n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print private  subroutine set_precision_internal (precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision","tags":"","url":"module/pic_io.html"},{"title":"pic_sorting_sort_index – PIC","text":"The generic subroutine implementing the SORT_INDEX algorithm to\n return an index array whose elements would sort the input array in the\n desired direction. It is primarily intended to be used to sort a\n derived type array based on the values of a component of the array.\n Its use has the syntax: call sort_index( array, index[, work, iwork, reverse ] ) with the arguments: array: the rank 1 array to be sorted. It is an intent(inout) argument of any of the types integer(int8) , integer(int16) , integer(int32) , integer(int64) , real(real32) , real(real64) , real(real128) , character(*) , type(string_type) , type(bitset_64) , type(bitset_large) . If both the\n   type of array is real and at least one of the elements is a NaN ,\n   then the ordering of the array and index results is undefined.\n   Otherwise it is defined to be as specified by reverse. index: a rank 1 array of sorting indices. It is an intent(out) argument of the type integer(int_index) . Its size shall be the\n   same as array . On return, if defined, its elements would\n   sort the input array in the direction specified by reverse . work (optional): shall be a rank 1 array of the same type as array , and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as “scratch” memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. iwork (optional): shall be a rank 1 integer array of kind int_index ,\n   and shall have at least size(array)/2 elements. It is an intent(out) argument to be used as “scratch” memory\n   for internal record keeping. If associated with an array in static\n   storage, its use can significantly reduce the stack memory requirements\n   for the code. Its value on return is undefined. reverse (optional): shall be a scalar of type default logical. It\n   is an intent(in) argument. If present with a value of .true. then index will sort array in order of non-increasing values in stable\n   order. Otherwise index will sort array in order of non-decreasing\n   values in stable order. Examples Sorting a related rank one array: subroutine sort_related_data ( a , b , work , index , iwork ) ! Sort `b` in terms or its related array `a` integer , intent ( inout ) :: a (:) integer ( int32 ), intent ( inout ) :: b (:) ! The same size as a integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) ! Find the indices to sort a call sort_index ( a , index ( 1 : size ( a )),& work ( 1 : size ( a ) / 2 ), iwork ( 1 : size ( a ) / 2 )) ! Sort b based on the sorting of a b (:) = b ( index ( 1 : size ( a )) ) end subroutine sort_related_data Sorting a rank 2 array based on the data in a column subroutine sort_related_data ( array , column , work , index , iwork ) ! Sort `a_data` in terms or its component `a` integer , intent ( inout ) :: a (:,:) integer ( int32 ), intent ( in ) :: column integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) integer , allocatable :: dummy (:) integer :: i allocate ( dummy ( size ( a , dim = 1 ))) ! Extract a component of `a_data` dummy (:) = a (:, column ) ! Find the indices to sort the column call sort_index ( dummy , index ( 1 : size ( dummy )),& work ( 1 : size ( dummy ) / 2 ), iwork ( 1 : size ( dummy ) / 2 )) ! Sort a based on the sorting of its column do i = 1 , size ( a , dim = 2 ) a (:, i ) = a ( index ( 1 : size ( a , dim = 1 )), i ) end do end subroutine sort_related_data Sorting an array of a derived type based on the dsta in one component subroutine sort_a_data ( a_data , a , work , index , iwork ) ! Sort `a_data` in terms or its component `a` type ( a_type ), intent ( inout ) :: a_data (:) integer ( int32 ), intent ( inout ) :: a (:) integer ( int32 ), intent ( out ) :: work (:) integer ( int_index ), intent ( out ) :: index (:) integer ( int_index ), intent ( out ) :: iwork (:) ! Extract a component of `a_data` a ( 1 : size ( a_data )) = a_data (:) % a ! Find the indices to sort the component call sort_index ( a ( 1 : size ( a_data )), index ( 1 : size ( a_data )),& work ( 1 : size ( a_data ) / 2 ), iwork ( 1 : size ( a_data ) / 2 )) ! Sort a_data based on the sorting of that component a_data (:) = a_data ( index ( 1 : size ( a_data )) ) end subroutine sort_a_data Uses pic_optional_value pic_types module~~pic_sorting_sort_index~~UsesGraph module~pic_sorting_sort_index pic_sorting_sort_index module~pic_optional_value pic_optional_value module~pic_sorting_sort_index->module~pic_optional_value module~pic_types pic_types module~pic_sorting_sort_index->module~pic_types module~pic_optional_value->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_sorting_sort_index~~UsedByGraph module~pic_sorting_sort_index pic_sorting_sort_index module~pic_sorting pic_sorting module~pic_sorting->module~pic_sorting_sort_index Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: max_merge_stack = int(ceiling(log(2._dp**64)/log(1.6180339887_dp))) Interfaces public        interface sort_index The generic subroutine interface implementing the SORT_INDEX algorithm,\nbased on the \"Rust\" sort algorithm found in slice.rs https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159\nbut modified to return an array of indices that would provide a stable\nsort of the rank one ARRAY input. The indices by default correspond to a\nnon-decreasing sort, but if the optional argument REVERSE is present\nwith a value of .TRUE. the indices correspond to a non-increasing sort. private module subroutine char_sort_index_default(array, index, work, iwork, reverse) Implementation → char_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine char_sort_index_low(array, index, work, iwork, reverse) Implementation → char_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type character(len=*) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_default(array, index, work, iwork, reverse) Implementation → dp_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_low(array, index, work, iwork, reverse) Implementation → dp_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(dp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_default(array, index, work, iwork, reverse) Implementation → int32_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_low(array, index, work, iwork, reverse) Implementation → int32_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int32) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_default(array, index, work, iwork, reverse) Implementation → int64_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_low(array, index, work, iwork, reverse) Implementation → int64_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type integer(int64) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_default(array, index, work, iwork, reverse) Implementation → sp_sort_index_default( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_low(array, index, work, iwork, reverse) Implementation → sp_sort_index_low( array, index[, work, iwork, reverse] ) sorts\nan input ARRAY of type real(sp) using a hybrid sort based on the \"Rust\" sort algorithm found in slice.rs and returns the sorted ARRAY and an array INDEX of indices in the\norder that would sort the input ARRAY in the desired direction. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse Derived Types type, private :: run_type Used to pass state around in a stack among helper functions for the ORD_SORT and SORT_INDEX algorithms Components Type Visibility Attributes Name Initial integer(kind=int_index), public :: base = 0 integer(kind=int_index), public :: len = 0 Subroutines private module subroutine char_sort_index_default (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine char_sort_index_low (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) character(len=len), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_default (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine dp_sort_index_low (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=dp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_default (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int32_sort_index_low (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int32), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_default (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine int64_sort_index_low (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) integer(kind=int64), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_default (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse private module subroutine sp_sort_index_low (array, index, work, iwork, reverse) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: array (0:) integer(kind=int_index_low), intent(out) :: index (0:) real(kind=sp), intent(out), optional :: work (0:) integer(kind=int_index_low), intent(out), optional :: iwork (0:) logical, intent(in), optional :: reverse","tags":"","url":"module/pic_sorting_sort_index.html"},{"title":"pic – PIC","text":"simple interface module that prints banner and other information about the library\nmostly here to verify installs, etc. Subroutines public  subroutine pic_print_banner () my cool banner, work in progress Arguments None","tags":"","url":"module/pic.html"},{"title":"pic_timer – PIC","text":"contains a simple timer module to measure and record time Uses pic_types pic_io module~~pic_timer~~UsesGraph module~pic_timer pic_timer module~pic_io pic_io module~pic_timer->module~pic_io module~pic_types pic_types module~pic_timer->module~pic_types module~pic_io->module~pic_types iso_c_binding iso_c_binding module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_timer~~UsedByGraph module~pic_timer pic_timer module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_timer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: timer_type derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp. If PIC is compiled with OpenMP the default\ntimer will be the omp time. This is mostly to minimize problems with threading\nand system clock Components Type Visibility Attributes Name Initial integer(kind=default_int), private :: count_rate = 1_default_int logical, private :: is_running = .false. integer(kind=default_int), private :: start_count = 0_default_int real(kind=dp), private :: start_time = 0.0_dp integer(kind=default_int), private :: stop_count = 0_default_int real(kind=dp), private :: stop_time = 0.0_dp real(kind=dp), private :: walltime Type-Bound Procedures procedure, public, non_overridable :: get_elapsed_time => timer_get_elapsed_time procedure, public, non_overridable :: print_time => timer_print_time procedure, public, non_overridable :: start => timer_start procedure, public, non_overridable :: stop => timer_stop Functions private  function timer_get_elapsed_time (self) result(elapsed) Returns the elapsed time as a real(dp) variable Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self Return Value real(kind=dp) Subroutines private  subroutine timer_print_time (self) Prints the elapsed time at the time of calling Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(in) :: self private  subroutine timer_start (self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self private  subroutine timer_stop (self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( timer_type ), intent(inout) :: self","tags":"","url":"module/pic_timer.html"},{"title":"pic_strings_to_string – PIC","text":"Uses pic_string_type Ancestors: pic_strings module~~pic_strings_to_string~~UsesGraph module~pic_strings_to_string pic_strings_to_string module~pic_string_type pic_string_type module~pic_strings_to_string->module~pic_string_type module~pic_strings pic_strings module~pic_strings_to_string->module~pic_strings module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_strings->module~pic_string_type iso_c_binding iso_c_binding module~pic_strings->iso_c_binding module~pic_strings->module~pic_ascii module~pic_strings->module~pic_optional_value module~pic_strings->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, private, parameter :: buffer_len = 128 character(len=*), private, parameter :: err_sym = \"[*]\" Functions pure function fix_nvhpc_octal_format (fmt) result(fixed) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fmt Return Value character(len=:), allocatable Module Functions pure module function to_string_1_i_int32 (value) result(string) Represent an integer of kind int32 as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: value Return Value character(len=:), allocatable pure module function to_string_1_i_int64 (value) result(string) Represent an integer of kind int64 as character sequence. Arguments Type Intent Optional Attributes Name integer(kind=ik), intent(in) :: value Return Value character(len=:), allocatable pure module function to_string_1_l_fbool (value) result(string) Represent an logical of kind fbool as character sequence. Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value Return Value character(len=1) pure module function to_string_2_i_int32 (value, format) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable pure module function to_string_2_i_int64 (value, format) result(string) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable pure module function to_string_2_l_fbool (value, format) result(string) Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: value character(len=*), intent(in) :: format Return Value character(len=:), allocatable pure module function to_string_r_dp (value, format) result(string) Format or transfer a real(dp) scalar as a string. Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable pure module function to_string_r_sp (value, format) result(string) Format or transfer a real(sp) scalar as a string. Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: value character(len=*), intent(in), optional :: format Return Value character(len=:), allocatable","tags":"","url":"module/pic_strings_to_string.html"},{"title":"pic_string_type_constructor – PIC","text":"Uses pic_strings Ancestors: pic_string_type module~~pic_string_type_constructor~~UsesGraph module~pic_string_type_constructor pic_string_type_constructor module~pic_string_type pic_string_type module~pic_string_type_constructor->module~pic_string_type module~pic_strings pic_strings module~pic_string_type_constructor->module~pic_strings module~pic_ascii pic_ascii module~pic_string_type->module~pic_ascii module~pic_optional_value pic_optional_value module~pic_string_type->module~pic_optional_value module~pic_types pic_types module~pic_string_type->module~pic_types module~pic_strings->module~pic_string_type iso_c_binding iso_c_binding module~pic_strings->iso_c_binding module~pic_strings->module~pic_ascii module~pic_strings->module~pic_optional_value module~pic_strings->module~pic_types module~pic_ascii->module~pic_types module~pic_optional_value->module~pic_types module~pic_types->iso_c_binding iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Functions elemental module function new_string (string) result(new) Constructor for new string instances from a scalar character value. Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: string Return Value type( string_type ) elemental module function new_string_from_integer_int32 (val) result(new) Constructor for new string instances from an integer of kind int32. Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: val Return Value type( string_type ) elemental module function new_string_from_integer_int64 (val) result(new) Constructor for new string instances from an integer of kind int64. Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: val Return Value type( string_type ) elemental module function new_string_from_logical_fbool (val) result(new) Constructor for new string instances from a logical of kind fbool. Arguments Type Intent Optional Attributes Name logical(kind=fbool), intent(in) :: val Return Value type( string_type )","tags":"","url":"module/pic_string_type_constructor.html"},{"title":"pic_sorting_sort.f90 – PIC","text":"This file is subjec† both to the Fortran Standard Library license, and\nto additional licensing requirements as it contains translations of\nother software. The Fortran Standard Library, including this file, is distributed under\nthe MIT license that should be included with the library’s distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n  copy of this software and associated documentation files (the\n  “Software”),  to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sellcopies of the Software, and to permit\n  persons to whom the Software is furnished to do so, subject to the\n  following conditions: The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, SORT , is substantially a\ntranslation to Fortran 2008, of the introsort of David Musser.\nDavid Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license provided\nwe cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,”\n  Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. This file depends on sourcefile~~pic_sorting_sort.f90~~EfferentGraph sourcefile~pic_sorting_sort.f90 pic_sorting_sort.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_sorting_sort.f90~~AfferentGraph sourcefile~pic_sorting_sort.f90 pic_sorting_sort.f90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Licensing: !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `SORT`, is substantially a !! translation to Fortran 2008, of the `introsort` of David Musser. !! David Musser has given permission to include a variant of `introsort` !! in the Fortran Standard Library under the MIT license provided !! we cite: !! !!   Musser, D.R., “Introspective Sorting and Selection Algorithms,” !!   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). !! !! as the official source of the algorithm. !submodule(pic_sorting) pic_sorting_sort module pic_sorting_sort use pic_types , only : int32 , int64 , sp , dp , int_index use pic_optional_value , only : pic_optional !! This submodule implements the overloaded sorting subroutine `SORT` !! that can be used to sort four kinds of `INTEGER` arrays and three kinds !! of `REAL` arrays. Sorting is in order of increasing value, with the worst !! case run time performance of `O(N Ln(N))`. !! !! `SORT` uses the `INTROSORT` sorting algorithm of David Musser, !! http://www.cs.rpi.edu/~musser/gp/introsort.ps. `introsort` is a hybrid !! unstable comparison algorithm combining `quicksort`, `insertion sort`, and !! `heap sort`. While this algorithm is always O(N Ln(N)) it is relatively !! fast on randomly ordered data, but inconsistent in performance on partly !! sorted data, sometimes having `merge sort` performance, sometimes having !! better than `quicksort` performance. implicit none public :: sort !! The generic subroutine implementing the `SORT` algorithm to return !! an input array with its elements sorted in order of (non-)decreasing !! value. Its use has the syntax: !! !!     call sort( array[, reverse] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`, !!   `type(bitset_64)`, `type(bitset_large)`. If both the type !!   of `array` is real and at least one of the elements is a `NaN`, then !!   the ordering of the result is undefined. Otherwise it is defined to be the !!   original elements in non-decreasing order. !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `array` will be sorted in order of non-increasing values in unstable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in unstable order. !! !!#### Example !! !!```fortran !!    ... !!    ! Read random data from a file !!    call read_file( 'dummy_file', array ) !!    ! Sort the random data !!    call sort( array ) !!    ! Process the sorted data !!    call array_search( array, values ) !!    ... !!``` private interface sort !! The generic subroutine interface implementing the `SORT` algorithm, based !! on the `introsort` of David Musser. !! ([Specification](../page/specs/stdlib_sorting.html#sort-sorts-an-input-array)) pure module subroutine int32_sort ( array , reverse ) !! `int32_sort( array[, reverse] )` sorts the input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort pure module subroutine int64_sort ( array , reverse ) !! `int64_sort( array[, reverse] )` sorts the input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort pure module subroutine sp_sort ( array , reverse ) !! `sp_sort( array[, reverse] )` sorts the input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort pure module subroutine dp_sort ( array , reverse ) !! `dp_sort( array[, reverse] )` sorts the input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort pure module subroutine char_sort ( array , reverse ) !! `char_sort( array[, reverse] )` sorts the input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `introsort` of David Musser. !! The algorithm is of order O(N Ln(N)) for all inputs. !! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) !! behavior is small for random data compared to other sorting algorithms. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort end interface sort contains pure module subroutine int32_sort ( array , reverse ) integer ( int32 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call int32_decrease_sort ( array ) else call int32_increase_sort ( array ) end if end subroutine int32_sort pure module subroutine int64_sort ( array , reverse ) integer ( int64 ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call int64_decrease_sort ( array ) else call int64_increase_sort ( array ) end if end subroutine int64_sort pure module subroutine sp_sort ( array , reverse ) real ( sp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call sp_decrease_sort ( array ) else call sp_increase_sort ( array ) end if end subroutine sp_sort pure module subroutine dp_sort ( array , reverse ) real ( dp ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call dp_decrease_sort ( array ) else call dp_increase_sort ( array ) end if end subroutine dp_sort pure module subroutine char_sort ( array , reverse ) character ( len =* ), intent ( inout ) :: array ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call char_decrease_sort ( array ) else call char_increase_sort ( array ) end if end subroutine char_sort pure subroutine int32_increase_sort ( array ) ! `int32_increase_sort( array )` sorts the input `ARRAY` of type `integer(int32)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int32_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int32 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int32 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int32 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int32_increase_sort pure subroutine int64_increase_sort ( array ) ! `int64_increase_sort( array )` sorts the input `ARRAY` of type `integer(int64)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int64_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int64 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int64 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int64 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int64_increase_sort pure subroutine sp_increase_sort ( array ) ! `sp_increase_sort( array )` sorts the input `ARRAY` of type `real(sp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `sp_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( sp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( sp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( sp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine sp_increase_sort pure subroutine dp_increase_sort ( array ) ! `dp_increase_sort( array )` sorts the input `ARRAY` of type `real(dp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `dp_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( dp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( dp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( dp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine dp_increase_sort pure subroutine char_increase_sort ( array ) ! `char_increase_sort( array )` sorts the input `ARRAY` of type `character(len=*)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `char_increase_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index character ( len = len ( array )) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u > v ) . neqv . ( u > w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v < u ) . neqv . ( v < w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) <= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size character ( len = len ( array )) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest character ( len = len ( array )) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) > array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) > array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine char_increase_sort pure subroutine int32_decrease_sort ( array ) ! `int32_decrease_sort( array )` sorts the input `ARRAY` of type `integer(int32)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int32_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int32 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int32 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int32 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int32_decrease_sort pure subroutine int64_decrease_sort ( array ) ! `int64_decrease_sort( array )` sorts the input `ARRAY` of type `integer(int64)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `int64_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index integer ( int64 ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size integer ( int64 ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest integer ( int64 ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine int64_decrease_sort pure subroutine sp_decrease_sort ( array ) ! `sp_decrease_sort( array )` sorts the input `ARRAY` of type `real(sp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `sp_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( sp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( sp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( sp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine sp_decrease_sort pure subroutine dp_decrease_sort ( array ) ! `dp_decrease_sort( array )` sorts the input `ARRAY` of type `real(dp)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `dp_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index real ( dp ) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size real ( dp ) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest real ( dp ) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine dp_decrease_sort pure subroutine char_decrease_sort ( array ) ! `char_decrease_sort( array )` sorts the input `ARRAY` of type `character(len=*)` ! using a hybrid sort based on the `introsort` of David Musser. As with ! `introsort`, `char_decrease_sort( array )` is an unstable hybrid comparison ! algorithm using `quicksort` for the main body of the sort tree, ! supplemented by `insertion sort` for the outer branches, but if ! `quicksort` is converging too slowly the algorithm resorts ! to `heapsort`. The algorithm is of order O(N Ln(N)) for all inputs. ! Because it relies on `quicksort`, the coefficient of the O(N Ln(N)) ! behavior is typically small compared to other sorting algorithms. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: depth_limit depth_limit = 2 * int ( floor ( log ( real ( size ( array , kind = int_index ), & kind = dp )) / log ( 2.0_dp )), & kind = int32 ) call introsort ( array , depth_limit ) contains pure recursive subroutine introsort ( array , depth_limit ) ! It devolves to `insertionsort` if the remaining number of elements ! is fewer than or equal to `INSERT_SIZE`, `heapsort` if the completion ! of the `quicksort` is too slow as estimated from `DEPTH_LIMIT`, ! otherwise sorting is done by a `quicksort`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( in ) :: depth_limit integer ( int_index ), parameter :: insert_size = 16_int_index integer ( int_index ) :: index if ( size ( array , kind = int_index ) <= insert_size ) then ! May be best at the end of SORT processing the whole array ! See Musser, D.R., “Introspective Sorting and Selection ! Algorithms,” Software—Practice and Experience, Vol. 27(8), ! 983–993 (August 1997). call insertion_sort ( array ) else if ( depth_limit == 0 ) then call heap_sort ( array ) else call partition ( array , index ) call introsort ( array ( 0 : index - 1 ), depth_limit - 1 ) call introsort ( array ( index + 1 :), depth_limit - 1 ) end if end subroutine introsort pure subroutine partition ( array , index ) ! quicksort partition using median of three. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index character ( len = len ( array )) :: u , v , w , x , y integer ( int_index ) :: i , j ! Determine median of three and exchange it with the end. u = array ( 0 ) v = array ( size ( array , kind = int_index ) / 2 - 1 ) w = array ( size ( array , kind = int_index ) - 1 ) if (( u < v ) . neqv . ( u < w )) then x = u y = array ( 0 ) array ( 0 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else if (( v > u ) . neqv . ( v > w )) then x = v y = array ( size ( array , kind = int_index ) / 2 - 1 ) array ( size ( array , kind = int_index ) / 2 - 1 ) = & array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y else x = w end if ! Partition the array. i = - 1_int_index do j = 0_int_index , size ( array , kind = int_index ) - 2 if ( array ( j ) >= x ) then i = i + 1 y = array ( i ) array ( i ) = array ( j ) array ( j ) = y end if end do y = array ( i + 1 ) array ( i + 1 ) = array ( size ( array , kind = int_index ) - 1 ) array ( size ( array , kind = int_index ) - 1 ) = y index = i + 1 end subroutine partition pure subroutine insertion_sort ( array ) ! Bog standard insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1_int_index , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure subroutine heap_sort ( array ) ! A bog standard heap sort character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , heap_size character ( len = len ( array )) :: y heap_size = size ( array , kind = int_index ) ! Build the max heap do i = ( heap_size - 2 ) / 2_int_index , 0_int_index , - 1_int_index call max_heapify ( array , i , heap_size ) end do do i = heap_size - 1 , 1_int_index , - 1_int_index ! Swap the first element with the current final element y = array ( 0 ) array ( 0 ) = array ( i ) array ( i ) = y ! Sift down using max_heapify call max_heapify ( array , 0_int_index , i ) end do end subroutine heap_sort pure recursive subroutine max_heapify ( array , i , heap_size ) ! Transform the array into a max heap character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: i , heap_size integer ( int_index ) :: l , r , largest character ( len = len ( array )) :: y largest = i l = 2_int_index * i + 1_int_index r = l + 1_int_index if ( l < heap_size ) then if ( array ( l ) < array ( largest )) largest = l end if if ( r < heap_size ) then if ( array ( r ) < array ( largest )) largest = r end if if ( largest /= i ) then y = array ( i ) array ( i ) = array ( largest ) array ( largest ) = y call max_heapify ( array , largest , heap_size ) end if end subroutine max_heapify end subroutine char_decrease_sort end module pic_sorting_sort !end submodule pic_sorting_sort","tags":"","url":"sourcefile/pic_sorting_sort.f90.html"},{"title":"pic_flop_recorder.f90 – PIC","text":"flop recorder This file depends on sourcefile~~pic_flop_recorder.f90~~EfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_flop_recorder.f90~~AfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop recorder module pic_flop_recorder !! general flop recorder module use pic_types , only : int64 implicit none private public :: flop_recorder_type type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure , non_overridable :: add => add_flops procedure , non_overridable :: get => get_flops procedure , non_overridable :: reset => reset_flop_counter end type flop_recorder_type contains subroutine add_flops ( self , flops ) !! Add an int64 variable which contains the FLOPs !! we use int64 since we might reach very large FLOP counts !! !! Usage: call my_flop_recorder%add(flops) !! class ( flop_recorder_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops self % flop_count = self % flop_count + flops end subroutine add_flops function get_flops ( self ) result ( flops ) !! Get the int64 number of FLOPs we currently have in the counter !! !! Usage: flops = my_flop_recorder%get() !! class ( flop_recorder_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % flop_count end function get_flops subroutine reset_flop_counter ( self ) !! Resets the flop counter to 0_int64 !! !! Usage: call my_flop_recorder%reset() !! class ( flop_recorder_type ), intent ( inout ) :: self self % flop_count = 0_int64 end subroutine reset_flop_counter end module pic_flop_recorder","tags":"","url":"sourcefile/pic_flop_recorder.f90.html"},{"title":"pic_blas_interfaces.F90 – PIC","text":"Source Code #ifdef PIC_HAVE_BLAS !! this file contains the interfaces for the BLAS routines of all levels !! I might consider splitting them up later but alas, I don't have the time now !! the idea of this file is to provide something akin to !! interface blas_gemm !!  subroutine sgemm() !!  subroutine dgemm() !!   ... etc, !! end interface blas_gemm !! so that I can use the same interface for all BLAS routines module pic_blas_interfaces !! pic_blas_interfaces.F90 provides the interfaces for the BLAS routines !! the idea is to have a two level interface, first pic_blas_xyz which !! is the way programmers will use BLAS, it'll do some checks and then !! call the \"overloaded\" BLAS interfaces to call the correct BLAS routine use pic_types , only : sp , dp , default_int implicit none private ! these are the cool overloaded interfaces, the pic_xyz function ! has the procedures pic_(type)xyz which will call the correct BLAS routine ! depending on the data type of the arguments ! this _needs_ allocatable arrays since we deduce shapes from the arrays themselves public :: pic_gemm , pic_gemv , pic_asum , pic_axpy , pic_copy , pic_dot , pic_scal , pic_iamax ! tested interface pic_gemm !! general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, CGEMM !! !! Usage: call pic_gemm(A, B, C, [optional] transa, [optional] transb, [optional] alpha, [optional] beta) !! !! where A, B, C are matrices, transa and transb are optional transpose options, !! alpha and beta are optional scaling factors !! !! By default, if not specified transA and transB are \"N\" (no transpose), !! and alpha and beta are 1.0 and 0.0 respectively. !! !! The matrices A, B, C must be allocatable arrays, we deduce the shapes from them. module procedure :: pic_sgemm module procedure :: pic_dgemm end interface pic_gemm interface pic_gemv !! general interface of the BLAS GEMV routines, will call SGEMV, DGEMV, CGEMV, ZGEMV !! !! Usage: call pic_gemv(A, x, y, [optional] transa, [optional] alpha, [optional] beta) !! !! where A is a matrix, x and y are vectors, transa is an optional transpose option, !! alpha and beta are optional scaling factors. !! !! The matrix A must be an allocatable array, we deduce the shapes from it. !! TransA is \"N\" (no transpose) by default. And alpha and beta are 1.0 and 0.0 respectively. !! module procedure :: pic_sgemv module procedure :: pic_dgemv end interface pic_gemv ! tested interface pic_asum !! general interface of the BLAS ASUM routines, will call SASUM, DASUM, SCASUM, DZASUM !! !! Usage: result = pic_asum(x, incx) !! !! where x is a vector and incx is the increment, this will return the sum of the absolute values !! of the elements of x. !! !! The vector x must be an allocatable array, we deduce the shape from it. !! The increment incx is 1 by default. !! module procedure :: pic_sasum module procedure :: pic_dasum module procedure :: pic_scasum module procedure :: pic_dzasum end interface pic_asum interface pic_axpy !! general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY !! !! Usage: call pic_axpy(n, alpha, x, incx, y, incy) !! !! where n is the number of elements, alpha is the scaling factor, !! x is the input vector, incx is the increment for x, y is the output vector, !! and incy is the increment for y. !! !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! The increments incx and incy are 1 by default. !! module procedure :: pic_saxpy module procedure :: pic_daxpy end interface pic_axpy interface pic_copy !! general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY !! !! Usage: call pic_copy(x, y) !! !! where x is the input vector, y is the output vector. !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! module procedure :: pic_scopy module procedure :: pic_dcopy end interface pic_copy interface pic_dot !! general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC !! !! Usage: result = pic_dot(x, y) !! !! where x is the input vector, y is the output vector. !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! module procedure :: pic_sdot module procedure :: pic_ddot end interface pic_dot interface pic_scal !! general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL !! !! Usage: call pic_scal(x, [optional] alpha) !! !! where x is the input vector, alpha is the scaling factor. !! The vector x must be an allocatable array, we deduce the shape from it. !! The scaling factor alpha is 1.0 by default. !! module procedure :: pic_sscal module procedure :: pic_dscal end interface pic_scal interface pic_iamax !! general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX !! !! Usage: idx = pic_iamax(x, incx) !! !! where x is the input vector, incx is the increment. !! The vector x must be an allocatable array, we deduce the shape from it. !! The increment incx is 1 by default. !! module procedure :: pic_isamax module procedure :: pic_idamax end interface pic_iamax interface blas_asum !! this is the interface for the BLAS ASUM routines, it will call SASUM, DASUM, SCASUM, DZASUM !! Usage: result = blas_asum(x, incx) !! where x is the input vector, incx is the increment. !! !! This is not a public interface, it is used internally by pic_asum pure function sasum ( n , x , incx ) result ( res_sasum ) import :: sp , default_int implicit none real ( sp ) :: res_sasum real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function sasum pure function dasum ( n , x , incx ) result ( res_dasum ) import :: dp , default_int implicit none real ( dp ) :: res_dasum real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dasum pure function scasum ( n , x , incx ) result ( res_scasum ) import :: sp , default_int implicit none real ( sp ) :: res_scasum complex ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function scasum pure function dzasum ( n , x , incx ) result ( res_dzasum ) import :: dp , default_int implicit none real ( dp ) :: res_dzasum complex ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dzasum end interface blas_asum interface blas_axpy !! explicit interface for BLAS AXPY routines !! !! Usage: call blas_axpy(n, alpha, x, incx, y, incy) !! !! This is not a public interface, it is used internally by pic_axpy pure subroutine saxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine saxpy pure subroutine daxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine daxpy pure subroutine caxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine caxpy pure subroutine zaxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine zaxpy end interface blas_axpy interface blas_copy !! explicit interface for BLAS COPY routines !! !! Usage: call blas_copy(x, y) !! !! This is not a public interface, it is used internally by pic_copy pure subroutine scopy ( n , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine scopy pure subroutine dcopy ( n , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine dcopy end interface blas_copy interface blas_dot !! explicit interface for BLAS DOT routines !! !! Usage: result = blas_dot(x, y, incx, incy, n) !! This is not a public interface, it is used internally by pic_dot !! pure function sdot ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none real ( sp ) :: res real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function sdot pure function ddot ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none real ( dp ) :: res real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function ddot pure function cdotc ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none complex ( sp ) :: res complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function cdotc pure function zdotc ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none complex ( dp ) :: res complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function zdotc end interface blas_dot interface blas_scal !! explicit interface for BLAS SCAL routines !! !! Usage: call blas_scal(n, alpha, x, incx) !! !! This is not a public interface, it is used internally by pic_scal pure subroutine sscal ( n , alpha , x , incx ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine sscal pure subroutine dscal ( n , alpha , x , incx ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine dscal end interface blas_scal interface blas_iamax !! explicit interface for BLAS IAMAX routines !! !! Usage: idx = blas_iamax(x, incx) !! !! This is not a public interface, it is used internally by pic_iamax pure function isamax ( n , x , incx ) result ( idx ) import :: sp , default_int implicit none integer ( default_int ) :: idx real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function isamax pure function idamax ( n , x , incx ) result ( idx ) import :: dp , default_int implicit none integer ( default_int ) :: idx real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function idamax end interface blas_iamax interface blas_gemv !! explicit interface for BLAS GEMV routines !! !! Usage: call blas_gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) !! !! This is not a public interface, it is used internally by pic_gemv pure subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemv pure subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemv pure subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemv pure subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemv end interface blas_gemv interface blas_gemm !! explicit interface for BLAS GEMM routines !! !! Usage: call blas_gemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) !! !! This is not a public interface, it is used internally by pic_gemm pure subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: b ( ldb , * ) real ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemm pure subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: b ( ldb , * ) real ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemm pure subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: b ( ldb , * ) complex ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemm pure subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: b ( ldb , * ) complex ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemm end interface blas_gemm contains pure subroutine pic_sgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: B (:, :) real ( sp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( sp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_sgemm pure subroutine pic_dgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: B (:, :) real ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_dgemm pure subroutine pic_sgemv ( A , x , y , trans_a , alpha , beta ) !! interface for single precision matrix-vector multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta real ( sp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_sgemv pure subroutine pic_dgemv ( A , x , y , trans_a , alpha , beta ) !! interface for double precision matrix-vector multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta real ( dp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_dgemv function pic_sasum ( x ) result ( res ) !! interface for single precision absolute sum real ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_sasum function pic_dasum ( x ) result ( res ) !! interface for double precision absolute sum real ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dasum function pic_scasum ( x ) result ( res ) !! interface for single precision complex absolute sum complex ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_scasum function pic_dzasum ( x ) result ( res ) !! interface for double precision complex absolute sum complex ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dzasum subroutine pic_saxpy ( x , y , alpha ) !! interface for single precision AXPY real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_saxpy subroutine pic_daxpy ( x , y , alpha ) !! interface for double precision AXPY real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_daxpy subroutine pic_scopy ( x , y ) !! interface for single precision copy real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_scopy subroutine pic_dcopy ( x , y ) !! interface for double precision copy real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_dcopy function pic_sdot ( x , y ) result ( res ) !! interface for single precision dot product real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( in ) :: y (:) real ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_sdot function pic_ddot ( x , y ) result ( res ) !! interface for double precision dot product real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( in ) :: y (:) real ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_ddot subroutine pic_sscal ( x , alpha ) !! interface for single precision scaling real ( sp ), intent ( inout ) :: x (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_sscal subroutine pic_dscal ( x , alpha ) !! interface for double precision scaling real ( dp ), intent ( inout ) :: x (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_dscal function pic_isamax ( x ) result ( idx ) !! interface for single precision index of maximum absolute value real ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_isamax function pic_idamax ( x ) result ( idx ) !! interface for double precision index of maximum absolute value real ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_idamax end module pic_blas_interfaces #endif","tags":"","url":"sourcefile/pic_blas_interfaces.f90.html"},{"title":"pic_helpers.f90 – PIC","text":"General helpers This file depends on sourcefile~~pic_helpers.f90~~EfferentGraph sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! General helpers module pic_test_helpers !! simple reusable helpers for random things use pic_types , only : int64 , dp , default_int , sp use pic_global_definitions , only : tol_sp , tol_dp implicit none private public :: dummy_work , is_equal interface is_equal !! The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about !! comparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that !! the two reals are exactly equal due to floating point precision issues. The functions are defined as elemental !! !! Usage: if (is_equal(a, b)) then !! where a and b are real numbers, and the function will return true if they are !! equal within the tolerance defined in pic_global_definitions. module procedure is_equal_sp module procedure is_equal_dp end interface is_equal contains elemental function is_equal_sp ( a , b ) result ( res ) real ( sp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_sp end function is_equal_sp elemental function is_equal_dp ( a , b ) result ( res ) real ( dp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_dp end function is_equal_dp subroutine dummy_work () !! this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely !! !! Usage: call dummy_work() !! !! it will simply do a 256 by 256 dgemm, woo integer ( int64 ) :: i , j , k integer ( default_int ) :: m real ( dp ), allocatable :: A (:, :), B (:, :), C (:, :) m = 256_default_int allocate ( A ( m , m ), B ( m , m ), C ( m , m )) A = 1.0_dp B = 1.0_dp C = 0.0_dp do i = 1 , m do j = 1 , m do k = 1 , m C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do print * , C ( 1 , 1 ) deallocate ( A , B , C ) end subroutine dummy_work end module pic_test_helpers","tags":"","url":"sourcefile/pic_helpers.f90.html"},{"title":"pic_types.F90 – PIC","text":"pic_types.F90 controls the standarized sizes for the datatypes across\npic, this is key for interfacing with other codes specially those that\nuse default sizes Files dependent on this one sourcefile~~pic_types.f90~~AfferentGraph sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_array.f90->sourcefile~pic_types.f90 sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_array.f90->sourcefile~pic_io.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_array.f90->sourcefile~pic_optional.f90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 sourcefile~pic_constants.f90 pic_constants.f90 sourcefile~pic_constants.f90->sourcefile~pic_types.f90 sourcefile~pic_device.f90 pic_device.f90 sourcefile~pic_device.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_io.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 sourcefile~pic_hash_32bit.f90 pic_hash_32bit.f90 sourcefile~pic_hash_32bit.f90->sourcefile~pic_types.f90 sourcefile~pic_hash_32bit_fnv.f90 pic_hash_32bit_fnv.f90 sourcefile~pic_hash_32bit.f90->sourcefile~pic_hash_32bit_fnv.f90 sourcefile~pic_hash_32bit_fnv.f90->sourcefile~pic_types.f90 sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_io.f90->sourcefile~pic_types.f90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_logger.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_knowledge.f90->sourcefile~pic_string_type.f90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_ord_sort.f90 pic_sorting_ord_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_ord_sort.f90 sourcefile~pic_sorting_radix_sort.f90 pic_sorting_radix_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_radix_sort.f90 sourcefile~pic_sorting_sort.f90 pic_sorting_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort.f90 sourcefile~pic_sorting_sort_index.f90 pic_sorting_sort_index.F90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort_index.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_strings.f90->sourcefile~pic_types.f90 sourcefile~pic_strings.f90->sourcefile~pic_ascii.f90 sourcefile~pic_strings.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_io.f90 sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! pic_types.F90 controls the standarized sizes for the datatypes across !! pic, this is key for interfacing with other codes specially those that !! use default sizes module pic_types !! main module for defining types for integer and double precision use , intrinsic :: iso_fortran_env , only : int8 , int16 , int32 , int64 use , intrinsic :: iso_c_binding , only : c_bool , c_char implicit none private public :: int8 , int16 , int32 , int64 public :: c_bool , c_char ! Define kinds for different data types ! int32 and int64 are defined in the iso_fortran_env, if you need to change things please do so here integer , parameter , public :: sp = SELECTED_REAL_KIND ( 6 , 37 ) !! single precision size integer , parameter , public :: dp = SELECTED_REAL_KIND ( 15 , 307 ) !! double precision size integer , parameter , public :: qp = SELECTED_REAL_KIND ( 33 , 4931 ) !! quadruple precision size, varies by compiler ! Define default types #ifdef USE_INT8 integer , parameter , public :: default_int = int64 !! if you compile PIC requesting USE_INT8 the default_int will be set to int64 this is kinda equivalent !! to compiling with -i8. If linking to a legacy codebase that relies on this, compile PIC with USE_INT8 #else integer , parameter , public :: default_int = int32 !! the default integer kind in PIC is int32 which faciliates the interfaces to MPI !! pay special attention if linking PIC to a code that use default int size of 8 #endif integer , parameter , public :: default_real = dp !! naturally, our default real is double precision integer , parameter , public :: default_complex = dp !! default complex is double precision integer , parameter , public :: int_index = int64 !! Integer kind for indexing integer , parameter , public :: int_index_low = int32 !! Integer kind for indexing using less than `huge(1_int32)` values integer , parameter , public :: fbool = kind (. true .) end module pic_types","tags":"","url":"sourcefile/pic_types.f90.html"},{"title":"pic_string_type.F90 – PIC","text":"This file depends on sourcefile~~pic_string_type.f90~~EfferentGraph sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_string_type.f90~~AfferentGraph sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! SPDX-Identifier: MIT !> Implementation of a string type to hold an arbitrary sequence of characters. !> !> This module provides string type compatible with all Fortran instrinsic character !> procedures as well as overloaded operators for working with character variables. !> !> A string type can be easily constructed by creating a new instance from a !> character variable or literal by invoking its constructor or by assigning it !> to a string type. Generally, the string type behaves similar to a deferred !> length character in most regards but adds memory access safety. !> module pic_string_type use pic_ascii , only : to_lower_ => to_lower , to_upper_ => to_upper , & & to_title_ => to_title , to_sentence_ => to_sentence , reverse_ => reverse use pic_types , only : int32 , int64 , fbool use pic_optional_value , only : pic_optional implicit none private public :: string_type public :: slen , len_trim , trim , index , scan , verify , repeat , adjustr , adjustl public :: lgt , lge , llt , lle , char , ichar , iachar public :: to_lower , to_upper , to_title , to_sentence , reverse , move public :: assignment ( = ) public :: operator ( > ), operator ( >= ), operator ( < ), operator ( <= ) public :: operator ( == ), operator ( /= ), operator ( // ) #ifndef __NVCOMPILER_LLVM__ public :: write ( formatted ), write ( unformatted ) public :: read ( formatted ), read ( unformatted ) #endif integer , parameter :: long = selected_int_kind ( 18 ) !> String type holding an arbitrary sequence of characters. type :: string_type ! Use the sequence statement below as a hack to prevent extending this type. ! It is not used for storage association. sequence private character ( len = :), allocatable :: raw end type string_type !> Returns the length of the character sequence represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface slen module procedure :: len_string end interface slen !> Constructor for new string instances interface string_type elemental module function new_string ( string ) result ( new ) implicit none character ( len =* ), intent ( in ), optional :: string type ( string_type ) :: new end function new_string elemental module function new_string_from_integer_int32 ( val ) result ( new ) implicit none integer ( int32 ), intent ( in ) :: val type ( string_type ) :: new end function new_string_from_integer_int32 elemental module function new_string_from_integer_int64 ( val ) result ( new ) implicit none integer ( int64 ), intent ( in ) :: val type ( string_type ) :: new end function new_string_from_integer_int64 elemental module function new_string_from_logical_fbool ( val ) result ( new ) implicit none logical ( fbool ), intent ( in ) :: val type ( string_type ) :: new end function new_string_from_logical_fbool end interface string_type !> Returns the length of the character sequence without trailing spaces !> represented by the string. !> !> This method is elemental and returns a default integer scalar value. interface len_trim module procedure :: len_trim_string end interface len_trim !> Returns the character sequence hold by the string without trailing spaces. !> !> This method is elemental and returns a scalar character value. interface trim module procedure :: trim_string end interface trim !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustl module procedure :: adjustl_string end interface adjustl !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. !> !> This method is elemental and returns a scalar character value. interface adjustr module procedure :: adjustr_string end interface adjustr !> Repeats the character sequence hold by the string by the number of !> specified copies. !> !> This method is elemental and returns a scalar character value. interface repeat module procedure :: repeat_string end interface repeat !> Returns the lowercase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> lowercase character sequence interface to_lower module procedure :: to_lower_string end interface to_lower !> Returns the uppercase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> uppercase character sequence interface to_upper module procedure :: to_upper_string end interface to_upper !> Returns the titlecase version of the character sequence hold by the input string !> !> This method is Elemental and returns a new string_type instance which holds this !> titlecase character sequence interface to_title module procedure :: to_title_string end interface to_title !> Returns the sentencecase version of the character sequence hold by the input string !> !> This method is elemental and returns a new string_type instance which holds this !> sentencecase character sequence interface to_sentence module procedure :: to_sentence_string end interface to_sentence !> Reverses the character sequence hold by the input string !> !> This method is elemental and returns a new string_type instance which holds this !> reverse character sequence interface reverse module procedure :: reverse_string end interface reverse !> Return the character sequence represented by the string. !> !> This method is elemental and returns a scalar character value. interface char module procedure :: char_string module procedure :: char_string_pos module procedure :: char_string_range end interface char !> Character-to-integer conversion function. !> !> This method is elemental and returns a default integer scalar value. interface ichar module procedure :: ichar_string end interface ichar !> Code in ASCII collating sequence. !> !> This method is elemental and returns a default integer scalar value. interface iachar module procedure :: iachar_string end interface iachar !> Position of a *substring* within a *string*. !> !> Returns the position of the start of the leftmost or rightmost occurrence !> of string *substring* in *string*, counting from one. If *substring* is not !> present in *string*, zero is returned. !> !> This method is elemental and returns a default integer scalar value. interface index module procedure :: index_string_string module procedure :: index_string_char module procedure :: index_char_string end interface index !> Scan a *string* for the presence of a *set* of characters. Scans a *string* for !> any of the characters in a *set* of characters. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is in *set*. If *back* is *true*, !> the rightmost position is returned. If no character of *set* is found in !> *string*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface scan module procedure :: scan_string_string module procedure :: scan_string_char module procedure :: scan_char_string end interface scan !> Scan a string for the absence of a set of characters. Verifies that all !> the characters in string belong to the set of characters in set. !> !> If *back* is either absent or *false*, this function returns the position !> of the leftmost character of *string* that is not in *set*. If *back* is *true*, !> the rightmost position is returned. If all characters of *string* are found !> in *set*, the result is zero. !> !> This method is elemental and returns a default integer scalar value. interface verify module procedure :: verify_string_string module procedure :: verify_string_char module procedure :: verify_char_string end interface verify !> Version: experimental !> !> Moves the allocated character scalar from 'from' to 'to' interface move module procedure :: move_string_string module procedure :: move_string_char module procedure :: move_char_string module procedure :: move_char_char end interface move !> Lexically compare the order of two character sequences being greater, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lgt module procedure :: lgt_string_string module procedure :: lgt_string_char module procedure :: lgt_char_string end interface lgt !> Lexically compare the order of two character sequences being less, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface llt module procedure :: llt_string_string module procedure :: llt_string_char module procedure :: llt_char_string end interface llt !> Lexically compare the order of two character sequences being greater equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lge module procedure :: lge_string_string module procedure :: lge_string_char module procedure :: lge_char_string end interface lge !> Lexically compare the order of two character sequences being less equal, !> The left-hand side, the right-hand side or both character sequences can !> be represented by a string. !> !> This method is elemental and returns a default logical scalar value. interface lle module procedure :: lle_string_string module procedure :: lle_string_char module procedure :: lle_char_string end interface lle !> Assign a character sequence to a string. interface assignment ( = ) module procedure :: assign_string_char end interface assignment ( = ) !> Compare two character sequences for being greater, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( > ) module procedure :: gt_string_string module procedure :: gt_string_char module procedure :: gt_char_string end interface operator ( > ) !> Compare two character sequences for being less, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( < ) module procedure :: lt_string_string module procedure :: lt_string_char module procedure :: lt_char_string end interface operator ( < ) !> Compare two character sequences for being greater than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( >= ) module procedure :: ge_string_string module procedure :: ge_string_char module procedure :: ge_char_string end interface operator ( >= ) !> Compare two character sequences for being less than, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( <= ) module procedure :: le_string_string module procedure :: le_string_char module procedure :: le_char_string end interface operator ( <= ) !> Compare two character sequences for equality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( == ) module procedure :: eq_string_string module procedure :: eq_string_char module procedure :: eq_char_string end interface operator ( == ) !> Compare two character sequences for inequality, the left-hand side, !> the right-hand side or both character sequences can be represented by !> a string. !> !> This operator is elemental and returns a default logical scalar value. interface operator ( /= ) module procedure :: ne_string_string module procedure :: ne_string_char module procedure :: ne_char_string end interface operator ( /= ) !> Concatenate two character sequences, the left-hand side, the right-hand side !> or both character sequences can be represented by a string. !> !> This operator is elemental and returns a scalar character value. interface operator ( // ) module procedure :: concat_string_string module procedure :: concat_string_char module procedure :: concat_char_string end interface operator ( // ) #ifndef __NVCOMPILER_LLVM__ !> Write the character sequence hold by the string to a connected formatted !> unit. interface write ( formatted ) module procedure :: write_formatted end interface !> Write the character sequence hold by the string to a connected unformatted !> unit. interface write ( unformatted ) module procedure :: write_unformatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( formatted ) module procedure :: read_formatted end interface !> Read a character sequence from a connected unformatted unit into the string. interface read ( unformatted ) module procedure :: read_unformatted end interface #endif contains !> Assign a character sequence to a string. elemental subroutine assign_string_char ( lhs , rhs ) type ( string_type ), intent ( inout ) :: lhs character ( len =* ), intent ( in ) :: rhs lhs % raw = rhs end subroutine assign_string_char !> Returns the length of the character sequence represented by the string. elemental function len_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length if ( allocated ( string % raw )) then length = len ( string % raw ) else length = 0 end if end function len_string !> Returns the length of the character sequence without trailing spaces !> represented by the string. elemental function len_trim_string ( string ) result ( length ) type ( string_type ), intent ( in ) :: string integer :: length length = merge ( len_trim ( string % raw ), 0 , allocated ( string % raw )) end function len_trim_string !> Character-to-integer conversion function. elemental function ichar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . slen ( string ) > 0 ) then ich = ichar ( string % raw ( 1 : 1 )) else ich = 0 end if end function ichar_string !> Code in ASCII collating sequence. elemental function iachar_string ( string ) result ( ich ) type ( string_type ), intent ( in ) :: string integer :: ich if ( allocated ( string % raw ) . and . slen ( string ) > 0 ) then ich = iachar ( string % raw ( 1 : 1 )) else ich = 0 end if end function iachar_string !> Return the character sequence represented by the string. pure function char_string ( string ) result ( character_string ) type ( string_type ), intent ( in ) :: string character ( len = slen ( string )) :: character_string character_string = maybe ( string ) end function char_string !> Return the character sequence represented by the string. elemental function char_string_pos ( string , pos ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: pos character ( len = 1 ) :: character_string character_string = merge ( string % raw ( pos : pos ), ' ' , allocated ( string % raw )) end function char_string_pos !> Return the character sequence represented by the string. pure function char_string_range ( string , start , last ) result ( character_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: start integer , intent ( in ) :: last character ( len = last - start + 1 ) :: character_string character_string = merge ( string % raw ( int ( start , long ): int ( last , long )), & repeat ( ' ' , int ( len ( character_string ), long )), allocated ( string % raw )) end function char_string_range !> Returns the character sequence hold by the string without trailing spaces. elemental function trim_string ( string ) result ( trimmed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: trimmed_string trimmed_string = trim ( maybe ( string )) end function trim_string !> Left-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustl_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustl ( maybe ( string )) end function adjustl_string !> Right-adjust the character sequence represented by the string. !> The length of the character sequence remains unchanged. elemental function adjustr_string ( string ) result ( adjusted_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: adjusted_string adjusted_string = adjustr ( maybe ( string )) end function adjustr_string !> Repeats the character sequence hold by the string by the number of !> specified copies. elemental function repeat_string ( string , ncopies ) result ( repeated_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: ncopies type ( string_type ) :: repeated_string repeated_string = repeat ( maybe ( string ), ncopies ) end function repeat_string !> Convert the character sequence hold by the input string to lower case elemental function to_lower_string ( string ) result ( lowercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: lowercase_string lowercase_string % raw = to_lower_ ( maybe ( string )) end function to_lower_string !> Convert the character sequence hold by the input string to upper case elemental function to_upper_string ( string ) result ( uppercase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: uppercase_string uppercase_string % raw = to_upper_ ( maybe ( string )) end function to_upper_string !> Convert the character sequence hold by the input string to title case elemental function to_title_string ( string ) result ( titlecase_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: titlecase_string titlecase_string % raw = to_title_ ( maybe ( string )) end function to_title_string !> Convert the character sequence hold by the input string to sentence case elemental function to_sentence_string ( string ) result ( sentence_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: sentence_string sentence_string % raw = to_sentence_ ( maybe ( string )) end function to_sentence_string !> Reverse the character sequence hold by the input string elemental function reverse_string ( string ) result ( reversed_string ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: reversed_string reversed_string % raw = reverse_ ( maybe ( string )) end function reverse_string !> Position of a sequence of character within a character sequence. !> In this version both character sequences are represented by a string. elemental function index_string_string ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), maybe ( substring ), pic_optional ( back , . false .)) end function index_string_string !> Position of a sequence of character within a character sequence. !> In this version the main character sequence is represented by a string. elemental function index_string_char ( string , substring , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( maybe ( string ), substring , pic_optional ( back , . false .)) end function index_string_char !> Position of a sequence of character within a character sequence. !> In this version the sub character sequence is represented by a string. elemental function index_char_string ( string , substring , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical , intent ( in ), optional :: back integer :: pos pos = index ( string , maybe ( substring ), pic_optional ( back , . false .)) end function index_char_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version both the character sequence and the character set are !> represented by a string. elemental function scan_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), maybe ( set ), pic_optional ( back , . false .)) end function scan_string_string !> Scan a character sequence for any of the characters in a set of characters. !> In this version the character sequences is represented by a string. elemental function scan_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( maybe ( string ), set , pic_optional ( back , . false .)) end function scan_string_char !> Scan a character sequence for any of the characters in a set of characters. !> In this version the set of characters is represented by a string. elemental function scan_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = scan ( string , maybe ( set ), pic_optional ( back , . false .)) end function scan_char_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version both the character sequence and !> the character set are represented by a string. elemental function verify_string_string ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), maybe ( set ), pic_optional ( back , . false .)) end function verify_string_string !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the character sequences is !> represented by a string. elemental function verify_string_char ( string , set , back ) result ( pos ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( maybe ( string ), set , pic_optional ( back , . false .)) end function verify_string_char !> Verify a character sequence for the absence any of the characters in !> a set of characters. In this version the set of characters is !> represented by a string. elemental function verify_char_string ( string , set , back ) result ( pos ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: set logical , intent ( in ), optional :: back integer :: pos pos = verify ( string , maybe ( set ), pic_optional ( back , . false .)) end function verify_char_string !> Moves the allocated character scalar from 'from' to 'to' !> No output elemental subroutine move_string_string ( from , to ) type ( string_type ), intent ( inout ), target :: from type ( string_type ), intent ( inout ), target :: to type ( string_type ), pointer :: fromp fromp => from if ( associated ( fromp , to )) return call move_alloc ( from % raw , to % raw ) end subroutine move_string_string !> Moves the allocated character scalar from 'from' to 'to' !> No output pure subroutine move_string_char ( from , to ) type ( string_type ), intent ( inout ) :: from character ( len = :), intent ( out ), allocatable :: to call move_alloc ( from % raw , to ) end subroutine move_string_char !> Moves the allocated character scalar from 'from' to 'to' !> No output pure subroutine move_char_string ( from , to ) character ( len = :), intent ( inout ), allocatable :: from type ( string_type ), intent ( out ) :: to call move_alloc ( from , to % raw ) end subroutine move_char_string !> Moves the allocated character scalar from 'from' to 'to' !> No output pure subroutine move_char_char ( from , to ) character ( len = :), intent ( inout ), allocatable :: from character ( len = :), intent ( out ), allocatable :: to call move_alloc ( from , to ) end subroutine move_char_char !> Compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function gt_string_string ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > maybe ( rhs ) end function gt_string_string !> Compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function gt_string_char ( lhs , rhs ) result ( is_gt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_gt is_gt = maybe ( lhs ) > rhs end function gt_string_char !> Compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function gt_char_string ( lhs , rhs ) result ( is_gt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_gt is_gt = lhs > maybe ( rhs ) end function gt_char_string !> Compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function lt_string_string ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_string !> Compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function lt_string_char ( lhs , rhs ) result ( is_lt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_string_char !> Compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function lt_char_string ( lhs , rhs ) result ( is_lt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lt is_lt = rhs > lhs end function lt_char_string !> Compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function ge_string_string ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_string !> Compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function ge_string_char ( lhs , rhs ) result ( is_ge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_string_char !> Compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function ge_char_string ( lhs , rhs ) result ( is_ge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ge is_ge = . not . ( rhs > lhs ) end function ge_char_string !> Compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function le_string_string ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_string !> Compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function le_string_char ( lhs , rhs ) result ( is_le ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_string_char !> Compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function le_char_string ( lhs , rhs ) result ( is_le ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_le is_le = . not . ( lhs > rhs ) end function le_char_string !> Compare two character sequences for equality. !> In this version both character sequences are by a string. elemental function eq_string_string ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_string_string !> Compare two character sequences for equality. !> In this version the left-hand side character sequences is by a string. elemental function eq_string_char ( lhs , rhs ) result ( is_eq ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_string_char !> Compare two character sequences for equality. !> In this version the right-hand side character sequences is by a string. elemental function eq_char_string ( lhs , rhs ) result ( is_eq ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_eq is_eq = . not . ( lhs > rhs ) if ( is_eq ) then is_eq = . not . ( rhs > lhs ) end if end function eq_char_string !> Compare two character sequences for inequality. !> In this version both character sequences are by a string. elemental function ne_string_string ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_string !> Compare two character sequences for inequality. !> In this version the left-hand side character sequences is by a string. elemental function ne_string_char ( lhs , rhs ) result ( is_ne ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_string_char !> Compare two character sequences for inequality. !> In this version the right-hand side character sequences is by a string. elemental function ne_char_string ( lhs , rhs ) result ( is_ne ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_ne is_ne = lhs > rhs if (. not . is_ne ) then is_ne = rhs > lhs end if end function ne_char_string !> Lexically compare two character sequences for being greater. !> In this version both character sequences are by a string. elemental function lgt_string_string ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), maybe ( rhs )) end function lgt_string_string !> Lexically compare two character sequences for being greater. !> In this version the left-hand side character sequences is by a string. elemental function lgt_string_char ( lhs , rhs ) result ( is_lgt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( maybe ( lhs ), rhs ) end function lgt_string_char !> Lexically compare two character sequences for being greater. !> In this version the right-hand side character sequences is by a string. elemental function lgt_char_string ( lhs , rhs ) result ( is_lgt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lgt is_lgt = lgt ( lhs , maybe ( rhs )) end function lgt_char_string !> Lexically compare two character sequences for being less. !> In this version both character sequences are by a string. elemental function llt_string_string ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), maybe ( rhs )) end function llt_string_string !> Lexically compare two character sequences for being less. !> In this version the left-hand side character sequences is by a string. elemental function llt_string_char ( lhs , rhs ) result ( is_llt ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( maybe ( lhs ), rhs ) end function llt_string_char !> Lexically compare two character sequences for being less. !> In this version the right-hand side character sequences is by a string. elemental function llt_char_string ( lhs , rhs ) result ( is_llt ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_llt is_llt = llt ( lhs , maybe ( rhs )) end function llt_char_string !> Lexically compare two character sequences for being greater or equal. !> In this version both character sequences are by a string. elemental function lge_string_string ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), maybe ( rhs )) end function lge_string_string !> Lexically compare two character sequences for being greater or equal. !> In this version the left-hand side character sequences is by a string. elemental function lge_string_char ( lhs , rhs ) result ( is_lge ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( maybe ( lhs ), rhs ) end function lge_string_char !> Lexically compare two character sequences for being greater or equal !> In this version the right-hand side character sequences is by a string. elemental function lge_char_string ( lhs , rhs ) result ( is_lge ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lge is_lge = lge ( lhs , maybe ( rhs )) end function lge_char_string !> Lexically compare two character sequences for being less or equal. !> In this version both character sequences are by a string. elemental function lle_string_string ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), maybe ( rhs )) end function lle_string_string !> Lexically compare two character sequences for being less or equal. !> In this version the left-hand side character sequences is by a string. elemental function lle_string_char ( lhs , rhs ) result ( is_lle ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( maybe ( lhs ), rhs ) end function lle_string_char !> Lexically compare two character sequences for being less or equal !> In this version the right-hand side character sequences is by a string. elemental function lle_char_string ( lhs , rhs ) result ( is_lle ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs logical :: is_lle is_lle = lle ( lhs , maybe ( rhs )) end function lle_char_string !> Concatenate two character sequences. !> In this version both character sequences are by a string. elemental function concat_string_string ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( lhs ) // maybe ( rhs ) end function concat_string_string !> Concatenate two character sequences. !> In this version the left-hand side character sequences is by a string. elemental function concat_string_char ( lhs , rhs ) result ( string ) type ( string_type ), intent ( in ) :: lhs character ( len =* ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = maybe ( lhs ) // rhs end function concat_string_char !> Concatenate two character sequences. !> In this version the right-hand side character sequences is by a string. elemental function concat_char_string ( lhs , rhs ) result ( string ) character ( len =* ), intent ( in ) :: lhs type ( string_type ), intent ( in ) :: rhs type ( string_type ) :: string string % raw = lhs // maybe ( rhs ) end function concat_char_string #ifndef __NVCOMPILER_LLVM__ !> Write the character sequence hold by the string to a connected unformatted !> unit. subroutine write_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg write ( unit , iostat = iostat , iomsg = iomsg ) int ( slen ( string ), long ) if ( iostat == 0 ) then write ( unit , iostat = iostat , iomsg = iomsg ) maybe ( string ) end if end subroutine write_unformatted !> Write the character sequence hold by the string to a connected formatted !> unit. subroutine write_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg select case ( iotype ) case ( \"LISTDIRECTED\" ) write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist output\" case default ! DT* select case ( size ( v_list )) case ( 0 ) ! DT write ( unit , '(a)' , iostat = iostat , iomsg = iomsg ) maybe ( string ) case default error stop \"[Fatal] This implementation does not support v_list formatters\" end select end select end subroutine write_formatted !> Read a character sequence from a connected unformatted unit into the string. subroutine read_unformatted ( string , unit , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: buffer integer ( long ) :: chunk read ( unit , iostat = iostat , iomsg = iomsg ) chunk if ( iostat == 0 ) then allocate ( character ( len = chunk ) :: buffer ) read ( unit , iostat = iostat , iomsg = iomsg ) buffer string % raw = buffer end if end subroutine read_unformatted !> Read a character sequence from a connected formatted unit into the string. subroutine read_formatted ( string , unit , iotype , v_list , iostat , iomsg ) type ( string_type ), intent ( inout ) :: string integer , intent ( in ) :: unit character ( len =* ), intent ( in ) :: iotype integer , intent ( in ) :: v_list (:) integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg character ( len = :), allocatable :: line call unused_dummy_argument ( v_list ) select case ( iotype ) case ( \"LISTDIRECTED\" ) call read_line ( unit , line , iostat , iomsg ) case ( \"NAMELIST\" ) error stop \"[Fatal] This implementation does not support namelist input\" case default ! DT* error stop \"[Fatal] This implementation does not support dt formatters\" end select string % raw = line contains !> Internal routine to read a whole record from a formatted unit subroutine read_line ( unit , line , iostat , iomsg ) integer , intent ( in ) :: unit character ( len = :), allocatable , intent ( out ) :: line integer , intent ( out ) :: iostat character ( len =* ), intent ( inout ) :: iomsg integer , parameter :: buffer_size = 512 character ( len = buffer_size ) :: buffer integer :: chunk line = '' do read ( unit , '(a)' , iostat = iostat , iomsg = iomsg , size = chunk , advance = 'no' ) & buffer if ( iostat > 0 ) exit line = line // buffer (: chunk ) if ( iostat < 0 ) exit end do if ( is_iostat_eor ( iostat )) then iostat = 0 end if end subroutine read_line end subroutine read_formatted #endif !> Do nothing but mark an unused dummy argument as such to acknowledge compile !> time warning like: !> !>   Warning: Unused dummy argument ‘dummy’ at (1) [-Wunused-dummy-argument] !> !> We deeply trust in the compiler to inline and optimize this piece of code away. elemental subroutine unused_dummy_argument ( dummy ) class ( * ), intent ( in ) :: dummy associate ( dummy => dummy ); end associate end subroutine unused_dummy_argument !> Safely return the character sequences represented by the string pure function maybe ( string ) result ( maybe_string ) type ( string_type ), intent ( in ) :: string character ( len = slen ( string )) :: maybe_string if ( allocated ( string % raw )) then maybe_string = string % raw else maybe_string = '' end if end function maybe end module pic_string_type","tags":"","url":"sourcefile/pic_string_type.f90.html"},{"title":"pic_ascii.f90 – PIC","text":"This file depends on sourcefile~~pic_ascii.f90~~EfferentGraph sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_ascii.f90~~AfferentGraph sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_strings.f90->sourcefile~pic_ascii.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !> The `stdlib_ascii` module provides procedures for handling and manipulating !> intrinsic character variables and constants. !> module pic_ascii use pic_types , only : int32 , int64 , fbool implicit none private ! Character validation functions public :: is_alpha , is_alphanum public :: is_digit , is_hex_digit , is_octal_digit public :: is_control , is_white , is_blank public :: is_ascii , is_punctuation public :: is_graphical , is_printable public :: is_lower , is_upper ! Character conversion functions public :: to_lower , to_upper , to_title , to_sentence , reverse ! All control characters in the ASCII table (see www.asciitable.com). character ( len = 1 ), public , parameter :: NUL = achar ( int ( z '00' )) !! Null character ( len = 1 ), public , parameter :: SOH = achar ( int ( z '01' )) !! Start of heading character ( len = 1 ), public , parameter :: STX = achar ( int ( z '02' )) !! Start of text character ( len = 1 ), public , parameter :: ETX = achar ( int ( z '03' )) !! End of text character ( len = 1 ), public , parameter :: EOT = achar ( int ( z '04' )) !! End of transmission character ( len = 1 ), public , parameter :: ENQ = achar ( int ( z '05' )) !! Enquiry character ( len = 1 ), public , parameter :: ACK = achar ( int ( z '06' )) !! Acknowledge character ( len = 1 ), public , parameter :: BEL = achar ( int ( z '07' )) !! Bell character ( len = 1 ), public , parameter :: BS = achar ( int ( z '08' )) !! Backspace character ( len = 1 ), public , parameter :: TAB = achar ( int ( z '09' )) !! Horizontal tab character ( len = 1 ), public , parameter :: LF = achar ( int ( z '0A' )) !! NL line feed, new line character ( len = 1 ), public , parameter :: VT = achar ( int ( z '0B' )) !! Vertical tab character ( len = 1 ), public , parameter :: FF = achar ( int ( z '0C' )) !! NP form feed, new page character ( len = 1 ), public , parameter :: CR = achar ( int ( z '0D' )) !! Carriage return character ( len = 1 ), public , parameter :: SO = achar ( int ( z '0E' )) !! Shift out character ( len = 1 ), public , parameter :: SI = achar ( int ( z '0F' )) !! Shift in character ( len = 1 ), public , parameter :: DLE = achar ( int ( z '10' )) !! Data link escape character ( len = 1 ), public , parameter :: DC1 = achar ( int ( z '11' )) !! Device control 1 character ( len = 1 ), public , parameter :: DC2 = achar ( int ( z '12' )) !! Device control 2 character ( len = 1 ), public , parameter :: DC3 = achar ( int ( z '13' )) !! Device control 3 character ( len = 1 ), public , parameter :: DC4 = achar ( int ( z '14' )) !! Device control 4 character ( len = 1 ), public , parameter :: NAK = achar ( int ( z '15' )) !! Negative acknowledge character ( len = 1 ), public , parameter :: SYN = achar ( int ( z '16' )) !! Synchronous idle character ( len = 1 ), public , parameter :: ETB = achar ( int ( z '17' )) !! End of transmission block character ( len = 1 ), public , parameter :: CAN = achar ( int ( z '18' )) !! Cancel character ( len = 1 ), public , parameter :: EM = achar ( int ( z '19' )) !! End of medium character ( len = 1 ), public , parameter :: SUB = achar ( int ( z '1A' )) !! Substitute character ( len = 1 ), public , parameter :: ESC = achar ( int ( z '1B' )) !! Escape character ( len = 1 ), public , parameter :: FS = achar ( int ( z '1C' )) !! File separator character ( len = 1 ), public , parameter :: GS = achar ( int ( z '1D' )) !! Group separator character ( len = 1 ), public , parameter :: RS = achar ( int ( z '1E' )) !! Record separator character ( len = 1 ), public , parameter :: US = achar ( int ( z '1F' )) !! Unit separator character ( len = 1 ), public , parameter :: DEL = achar ( int ( z '7F' )) !! Delete ! Constant character sequences character ( len =* ), public , parameter :: fullhex_digits = \"0123456789ABCDEFabcdef\" !! 0 .. 9A .. Fa .. f character ( len =* ), public , parameter :: hex_digits = fullhex_digits ( 1 : 16 ) !! 0 .. 9A .. F character ( len =* ), public , parameter :: lowerhex_digits = \"0123456789abcdef\" !! 0 .. 9a .. f character ( len =* ), public , parameter :: digits = hex_digits ( 1 : 10 ) !! 0 .. 9 character ( len =* ), public , parameter :: octal_digits = digits ( 1 : 8 ) !! 0 .. 7 character ( len =* ), public , parameter :: letters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\" !! A .. Za .. z character ( len =* ), public , parameter :: uppercase = letters ( 1 : 26 ) !! A .. Z character ( len =* ), public , parameter :: lowercase = letters ( 27 :) !! a .. z character ( len =* ), public , parameter :: whitespace = \" \" // TAB // VT // CR // LF // FF !! ASCII _whitespace !> Returns a new character sequence which is the lower case !> version of the input character sequence !> This method is elemental and returns a character sequence interface to_lower module procedure :: to_lower end interface to_lower !> Returns a new character sequence which is the upper case !> version of the input character sequence !> This method is elemental and returns a character sequence interface to_upper module procedure :: to_upper end interface to_upper !> Returns a new character sequence which is the title case !> version of the input character sequence !> This method is elemental and returns a character sequence interface to_title module procedure :: to_title end interface to_title !> Returns a new character sequence which is the sentence case !> version of the input character sequence !> This method is elemental and returns a character sequence interface to_sentence module procedure :: to_sentence end interface to_sentence !> Returns a new character sequence which is reverse of !> the input charater sequence !> This method is elemental and returns a character sequence interface reverse module procedure :: reverse end interface reverse contains !> Checks whether `c` is an ASCII letter (A .. Z, a .. z). elemental logical function is_alpha ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alpha = ( c >= 'A' . and . c <= 'Z' ) . or . ( c >= 'a' . and . c <= 'z' ) end function is_alpha !> Checks whether `c` is a letter or a number (0 .. 9, a .. z, A .. Z). elemental logical function is_alphanum ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_alphanum = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'z' ) & . or . ( c >= 'A' . and . c <= 'Z' ) end function is_alphanum !> Checks whether or not `c` is in the ASCII character set - !> i.e. in the range 0 .. 0x7F. elemental logical function is_ascii ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_ascii = iachar ( c ) <= int ( z '7F' ) end function is_ascii !> Checks whether `c` is a control character. elemental logical function is_control ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_control = ic < int ( z '20' ) . or . ic == int ( z '7F' ) end function is_control !> Checks whether `c` is a digit (0 .. 9). elemental logical function is_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_digit = ( '0' <= c ) . and . ( c <= '9' ) end function is_digit !> Checks whether `c` is a digit in base 8 (0 .. 7). elemental logical function is_octal_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_octal_digit = ( c >= '0' ) . and . ( c <= '7' ) end function is_octal_digit !> Checks whether `c` is a digit in base 16 (0 .. 9, A .. F, a .. f). elemental logical function is_hex_digit ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_hex_digit = ( c >= '0' . and . c <= '9' ) . or . ( c >= 'a' . and . c <= 'f' ) & . or . ( c >= 'A' . and . c <= 'F' ) end function is_hex_digit !> Checks whether or not `c` is a punctuation character. That includes !> all ASCII characters which are not control characters, letters, !> digits, or whitespace. elemental logical function is_punctuation ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !       '~'                 '!' is_punctuation = ( ic <= int ( z '7E' )) . and . ( ic >= int ( z '21' )) . and . & (. not . is_alphanum ( c )) end function is_punctuation !> Checks whether or not `c` is a printable character other than the !> space character. elemental logical function is_graphical ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is graphical if it's between '!' and '~' in the ASCII table, !that is: printable but not a space is_graphical = ( int ( z '21' ) <= ic ) . and . ( ic <= int ( z '7E' )) end function is_graphical !> Checks whether or not `c` is a printable character - including the !> space character. elemental logical function is_printable ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) !The character is printable if it's between ' ' and '~' in the ASCII table is_printable = ic >= iachar ( ' ' ) . and . ic <= int ( z '7E' ) end function is_printable !> Checks whether `c` is a lowercase ASCII letter (a .. z). elemental logical function is_lower ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) is_lower = ic >= iachar ( 'a' ) . and . ic <= iachar ( 'z' ) end function is_lower !> Checks whether `c` is an uppercase ASCII letter (A .. Z). elemental logical function is_upper ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. is_upper = ( c >= 'A' ) . and . ( c <= 'Z' ) end function is_upper !> Checks whether or not `c` is a whitespace character. That includes the !> space, tab, vertical tab, form feed, carriage return, and linefeed !> characters. elemental logical function is_white ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB, LF, VT, FF, CR is_white = ( c == ' ' ) . or . ( ic >= int ( z '09' ) . and . ic <= int ( z '0D' )) end function is_white !> Checks whether or not `c` is a blank character. That includes the !> only the space and tab characters elemental logical function is_blank ( c ) character ( len = 1 ), intent ( in ) :: c !! The character to test. integer :: ic ic = iachar ( c ) ! TAB is_blank = ( c == ' ' ) . or . ( ic == int ( z '09' )) end function is_blank !> Returns the corresponding lowercase letter, if `c` is an uppercase !> ASCII character, otherwise `c` itself. elemental function char_to_lower ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer , parameter :: wp = iachar ( 'a' ) - iachar ( 'A' ), BA = iachar ( 'A' ), BZ = iachar ( 'Z' ) integer :: k !Check whether the integer equivalent is between BA=65 and BZ=90 k = ichar ( c ) if ( k >= BA . and . k <= BZ ) k = k + wp t = char ( k ) end function char_to_lower !> Returns the corresponding uppercase letter, if `c` is a lowercase !> ASCII character, otherwise `c` itself. elemental function char_to_upper ( c ) result ( t ) character ( len = 1 ), intent ( in ) :: c !! A character. character ( len = 1 ) :: t integer , parameter :: wp = iachar ( 'a' ) - iachar ( 'A' ), la = iachar ( 'a' ), lz = iachar ( 'z' ) integer :: k !Check whether the integer equivalent is between la=97 and lz=122 k = ichar ( c ) if ( k >= la . and . k <= lz ) k = k - wp t = char ( k ) end function char_to_upper !> Convert character variable to lower case !> !> Version: experimental elemental function to_lower ( string ) result ( lower_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: lower_string integer :: i do i = 1 , len ( string ) lower_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_lower !> Convert character variable to upper case !> !> Version: experimental elemental function to_upper ( string ) result ( upper_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: upper_string integer :: i do i = 1 , len ( string ) upper_string ( i : i ) = char_to_upper ( string ( i : i )) end do end function to_upper !> Converts character sequence to title case !> !> Version: experimental elemental function to_title ( string ) result ( title_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: title_string integer :: i logical :: capitalize_switch capitalize_switch = . true . do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then if ( capitalize_switch ) then title_string ( i : i ) = char_to_upper ( string ( i : i )) capitalize_switch = . false . else title_string ( i : i ) = char_to_lower ( string ( i : i )) end if else title_string ( i : i ) = string ( i : i ) capitalize_switch = . true . end if end do end function to_title !> Converts character sequence to sentence case !> !> Version: experimental elemental function to_sentence ( string ) result ( sentence_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: sentence_string integer :: i , n n = len ( string ) do i = 1 , len ( string ) if ( is_alphanum ( string ( i : i ))) then sentence_string ( i : i ) = char_to_upper ( string ( i : i )) n = i exit else sentence_string ( i : i ) = string ( i : i ) end if end do do i = n + 1 , len ( string ) sentence_string ( i : i ) = char_to_lower ( string ( i : i )) end do end function to_sentence !> Reverse the character order in the input character variable !> !> Version: experimental elemental function reverse ( string ) result ( reverse_string ) character ( len =* ), intent ( in ) :: string character ( len = len ( string )) :: reverse_string integer :: i , n n = len ( string ) do i = 1 , n reverse_string ( n - i + 1 : n - i + 1 ) = string ( i : i ) end do end function reverse end module pic_ascii","tags":"","url":"sourcefile/pic_ascii.f90.html"},{"title":"pic_strings.f90 – PIC","text":"This file depends on sourcefile~~pic_strings.f90~~EfferentGraph sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_strings.f90->sourcefile~pic_ascii.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_strings.f90->sourcefile~pic_optional.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_strings.f90->sourcefile~pic_types.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_strings.f90~~AfferentGraph sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code ! SPDX-Identifier: MIT !> This module implements basic string handling routines. !> module pic_strings use pic_ascii , only : whitespace use pic_string_type , only : string_type , char , verify , repeat , slen , len_trim , move use pic_optional_value , only : pic_optional use pic_types , only : sp , dp , int32 , int64 , fbool use iso_c_binding , only : c_null_char , c_char implicit none private public :: to_string public :: to_c_char public :: strip , chomp public :: starts_with , ends_with public :: slice , find , replace_all , padl , padr , count , zfill , join !> Version: experimental !> !> Format or transfer other types as a string. interface to_string pure module function to_string_r_sp ( value , format ) result ( string ) implicit none real ( sp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string end function to_string_r_sp pure module function to_string_r_dp ( value , format ) result ( string ) implicit none real ( dp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string end function to_string_r_dp pure module function to_string_1_i_int32 ( value ) result ( string ) implicit none integer ( int32 ), intent ( in ) :: value character ( len = :), allocatable :: string end function to_string_1_i_int32 pure module function to_string_2_i_int32 ( value , format ) result ( string ) implicit none integer ( int32 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string end function to_string_2_i_int32 pure module function to_string_1_i_int64 ( value ) result ( string ) implicit none integer ( int64 ), intent ( in ) :: value character ( len = :), allocatable :: string end function to_string_1_i_int64 pure module function to_string_2_i_int64 ( value , format ) result ( string ) implicit none integer ( int64 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string end function to_string_2_i_int64 pure module function to_string_1_l_fbool ( value ) result ( string ) implicit none logical ( fbool ), intent ( in ) :: value character ( len = 1 ) :: string end function to_string_1_l_fbool pure module function to_string_2_l_fbool ( value , format ) result ( string ) implicit none logical ( fbool ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string end function to_string_2_l_fbool end interface to_string !> Version: experimental !> !> Format or transfer other types as a string. interface to_c_char module procedure to_c_char_from_char module procedure to_c_char_from_string end interface to_c_char !> Remove leading and trailing whitespace characters. !> !> Version: experimental interface strip module procedure :: strip_string module procedure :: strip_char end interface strip !> Remove trailing characters in set from string. !> If no character set is provided trailing whitespace is removed. !> !> Version: experimental interface chomp module procedure :: chomp_string module procedure :: chomp_char module procedure :: chomp_set_string_char module procedure :: chomp_set_char_char module procedure :: chomp_substring_string_string module procedure :: chomp_substring_char_string module procedure :: chomp_substring_string_char module procedure :: chomp_substring_char_char end interface chomp !> Check whether a string starts with substring or not !> !> Version: experimental interface starts_with module procedure :: starts_with_string_string module procedure :: starts_with_string_char module procedure :: starts_with_char_string module procedure :: starts_with_char_char end interface starts_with !> Check whether a string ends with substring or not !> !> Version: experimental interface ends_with module procedure :: ends_with_string_string module procedure :: ends_with_string_char module procedure :: ends_with_char_string module procedure :: ends_with_char_char end interface ends_with !> Extracts characters from the input string to return a new string !> !> Version: experimental interface slice module procedure :: slice_string module procedure :: slice_char end interface slice !> Finds the starting index of substring 'pattern' in the input 'string' !> [Specifications](link to the specs - to be completed) !> !> Version: experimental interface find module procedure :: find_string_string module procedure :: find_string_char module procedure :: find_char_string module procedure :: find_char_char end interface find !> Replaces all the occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Version: experimental interface replace_all module procedure :: replace_all_string_string_string module procedure :: replace_all_string_string_char module procedure :: replace_all_string_char_string module procedure :: replace_all_char_string_string module procedure :: replace_all_string_char_char module procedure :: replace_all_char_string_char module procedure :: replace_all_char_char_string module procedure :: replace_all_char_char_char end interface replace_all !> Version: experimental !> !> Left pad the input string interface padl module procedure :: padl_string_default module procedure :: padl_string_pad_with module procedure :: padl_char_default module procedure :: padl_char_pad_with end interface padl !> Version: experimental !> !> Right pad the input string interface padr module procedure :: padr_string_default module procedure :: padr_string_pad_with module procedure :: padr_char_default module procedure :: padr_char_pad_with end interface padr !> Version: experimental !> !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' interface count module procedure :: count_string_string module procedure :: count_string_char module procedure :: count_char_string module procedure :: count_char_char end interface count !> Version: experimental !> !> Left pad the input string with zeros. interface zfill module procedure :: zfill_string module procedure :: zfill_char end interface zfill !> Version: experimental !> !> Joins an array of strings into a single string. !> The chunks are separated with a space, or an optional user-defined separator. interface join module procedure :: join_string module procedure :: join_char end interface join contains !> Remove leading and trailing whitespace characters. pure function strip_string ( string ) result ( stripped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: stripped_string stripped_string = strip ( char ( string )) end function strip_string !> Remove leading and trailing whitespace characters. pure function strip_char ( string ) result ( stripped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: stripped_string integer :: first , last first = verify ( string , whitespace ) if ( first == 0 ) then stripped_string = \"\" else last = verify ( string , whitespace , back = . true .) stripped_string = string ( first : last ) end if end function strip_char !> Remove trailing characters in set from string. !> Default character set variant where trailing whitespace is removed. pure function chomp_string ( string ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ) :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = char ( string , 1 , last ) end function chomp_string !> Remove trailing characters in set from string. !> Default character set variant where trailing whitespace is removed. pure function chomp_char ( string ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , whitespace , back = . true .) chomped_string = string ( 1 : last ) end function chomp_char !> Remove trailing characters in set from string. pure function chomp_set_string_char ( string , set ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), set ) end function chomp_set_string_char !> Remove trailing characters in set from string. pure function chomp_set_char_char ( string , set ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len = 1 ), intent ( in ) :: set (:) character ( len = :), allocatable :: chomped_string integer :: last last = verify ( string , set_to_string ( set ), back = . true .) chomped_string = string ( 1 : last ) end function chomp_set_char_char !> Remove trailing substrings from string. pure function chomp_substring_string_string ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), char ( substring )) end function chomp_substring_string_string !> Remove trailing substrings from string. pure function chomp_substring_string_char ( string , substring ) result ( chomped_string ) ! Avoid polluting the module scope and use the assignment only in this scope use pic_string_type , only : assignment ( = ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring type ( string_type ) :: chomped_string chomped_string = chomp ( char ( string ), substring ) end function chomp_substring_string_char !> Remove trailing substrings from string. pure function chomp_substring_char_string ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string chomped_string = chomp ( string , char ( substring )) end function chomp_substring_char_string !> Remove trailing substrings from string. pure function chomp_substring_char_char ( string , substring ) result ( chomped_string ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring character ( len = :), allocatable :: chomped_string integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( nsub > 0 . and . nsub <= last ) then do while ( last >= nsub ) if ( string ( last - nsub + 1 : last ) == substring ) then last = last - nsub else exit end if end do end if if ( last <= 0 ) then chomped_string = '' else chomped_string = string ( 1 : last ) end if end function chomp_substring_char_char !> Implementation to transfer a set of characters to a string representing the set. !> !> This function is internal and not part of the public API. pure function set_to_string ( set ) result ( string ) character ( len = 1 ), intent ( in ) :: set (:) character ( len = size ( set )) :: string string = transfer ( set , string ) end function set_to_string !> Check whether a string starts with substring or not pure function starts_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: nsub nsub = len ( substring ) if ( len ( string ) < nsub ) then match = . false . return end if match = string ( 1 : nsub ) == substring end function starts_with_char_char !> Check whether a string starts with substring or not elemental function starts_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), substring ) end function starts_with_string_char !> Check whether a string starts with substring or not elemental function starts_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( string , char ( substring )) end function starts_with_char_string !> Check whether a string starts with substring or not elemental function starts_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = starts_with ( char ( string ), char ( substring )) end function starts_with_string_string !> Check whether a string ends with substring or not pure function ends_with_char_char ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match integer :: last , nsub last = len ( string ) nsub = len ( substring ) if ( last < nsub ) then match = . false . return end if match = string ( last - nsub + 1 : last ) == substring end function ends_with_char_char !> Check whether a string ends with substring or not elemental function ends_with_string_char ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), substring ) end function ends_with_string_char !> Check whether a string ends with substring or not elemental function ends_with_char_string ( string , substring ) result ( match ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( string , char ( substring )) end function ends_with_char_string !> Check whether a string ends with substring or not elemental function ends_with_string_string ( string , substring ) result ( match ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: substring logical :: match match = ends_with ( char ( string ), char ( substring )) end function ends_with_string_string !> Extract the characters from the region between 'first' and 'last' index (both inclusive) !> of the input 'string' by taking strides of length 'stride' !> Returns a new string elemental function slice_string ( string , first , last , stride ) result ( sliced_string ) type ( string_type ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride type ( string_type ) :: sliced_string sliced_string = string_type ( slice ( char ( string ), first , last , stride )) end function slice_string !> Extract the characters from the region between 'first' and 'last' index (both inclusive) !> of the input 'string' by taking strides of length 'stride' !> Returns a new string pure function slice_char ( string , first , last , stride ) result ( sliced_string ) character ( len =* ), intent ( in ) :: string integer , intent ( in ), optional :: first , last , stride integer :: first_index , last_index , stride_vector , strides_taken , length_string , i , j character ( len = :), allocatable :: sliced_string length_string = len ( string ) first_index = 0 ! first_index = -infinity last_index = length_string + 1 ! last_index = +infinity stride_vector = 1 if ( present ( stride )) then if ( stride /= 0 ) then if ( stride < 0 ) then first_index = length_string + 1 ! first_index = +infinity last_index = 0 ! last_index = -infinity end if stride_vector = stride end if else if ( present ( first ) . and . present ( last )) then if ( last < first ) then stride_vector = - 1 end if end if end if if ( present ( first )) then first_index = first end if if ( present ( last )) then last_index = last end if if ( stride_vector > 0 ) then first_index = max ( first_index , 1 ) last_index = min ( last_index , length_string ) else first_index = min ( first_index , length_string ) last_index = max ( last_index , 1 ) end if strides_taken = floor ( real ( last_index - first_index ) / real ( stride_vector )) allocate ( character ( len = max ( 0 , strides_taken + 1 )) :: sliced_string ) j = 1 do i = first_index , last_index , stride_vector sliced_string ( j : j ) = string ( i : i ) j = j + 1 end do end function slice_char !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_string_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), char ( pattern ), occurrence , consider_overlapping ) end function find_string_string !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_string_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( char ( string ), pattern , occurrence , consider_overlapping ) end function find_string_char !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_char_string ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: res res = find ( string , char ( pattern ), occurrence , consider_overlapping ) end function find_char_string !> Returns the starting index of the 'occurrence'th occurrence of substring 'pattern' !> in input 'string' !> Returns an integer elemental function find_char_char ( string , pattern , occurrence , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern integer , intent ( in ), optional :: occurrence logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern , occurrence_ occurrence_ = pic_optional ( occurrence , 1 ) res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string & & . and . occurrence_ > 0 ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then occurrence_ = occurrence_ - 1 if ( occurrence_ == 0 ) then res = s_i - length_pattern + 1 exit else if ( pic_optional ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function find_char_char !> Computes longest prefix suffix for each index of the input 'string' !> !> Returns an array of integers pure function compute_lps ( string ) result ( lps_array ) character ( len =* ), intent ( in ) :: string integer :: lps_array ( len ( string )) integer :: i , j , length_string length_string = len ( string ) if ( length_string > 0 ) then lps_array ( 1 ) = 0 i = 2 j = 1 do while ( i <= length_string ) if ( string ( j : j ) == string ( i : i )) then lps_array ( i ) = j i = i + 1 j = j + 1 else if ( j > 1 ) then j = lps_array ( j - 1 ) + 1 else lps_array ( i ) = 0 i = i + 1 end if end do end if end function compute_lps !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_string_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), & & char ( pattern ), char ( replacement ))) end function replace_all_string_string_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_string_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), char ( pattern ), replacement )) end function replace_all_string_string_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_char_string ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , char ( replacement ))) end function replace_all_string_char_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_string_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), char ( replacement )) end function replace_all_char_string_string !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_string_char_char ( string , pattern , replacement ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement type ( string_type ) :: res res = string_type ( replace_all ( char ( string ), pattern , replacement )) end function replace_all_string_char_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_string_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , char ( pattern ), replacement ) end function replace_all_char_string_char !> Replaces all occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_char_string ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern type ( string_type ), intent ( in ) :: replacement character ( len = :), allocatable :: res res = replace_all ( string , pattern , char ( replacement )) end function replace_all_char_char_string !> Replaces all the occurrences of substring 'pattern' in the input 'string' !> with the replacement 'replacement' !> Returns a new string pure function replace_all_char_char_char ( string , pattern , replacement ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern character ( len =* ), intent ( in ) :: replacement character ( len = :), allocatable :: res integer :: lps_array ( len ( pattern )) integer :: s_i , p_i , last , length_string , length_pattern res = \"\" length_string = len ( string ) length_pattern = len ( pattern ) last = 1 if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res // & & string ( last : s_i - length_pattern ) // & & replacement last = s_i + 1 p_i = 0 end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if res = res // string ( last : length_string ) end function replace_all_char_char_char !> Left pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padl_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , \" \" )) end function padl_string_default !> Left pad the input string with the 'pad_with' character !> !> Returns a new string pure function padl_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , pad_with )) end function padl_string_pad_with !> Left pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padl_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = padl ( string , output_length , \" \" ) end function padl_char_default !> Left pad the input string with the 'pad_with' character !> !> Returns a new string pure function padl_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) if ( string_length < output_length ) then res = repeat ( pad_with , output_length - string_length ) res ( output_length - string_length + 1 : output_length ) = string else res = string end if end function padl_char_pad_with !> Right pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padr_string_default ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( slen ( string ), output_length )) :: char_output type ( string_type ) :: res ! We're taking advantage of `char_output` being longer than `string` and ! initialized with whitespaces. By casting `string` to a `character` ! type and back to `string_type`, we're effectively right-padding ! `string` with spaces, so we don't need to pad explicitly. char_output = char ( string ) res = string_type ( char_output ) end function padr_string_default !> Right pad the input string with the 'pad_with' character !> !> Returns a new string pure function padr_string_pad_with ( string , output_length , pad_with ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with type ( string_type ) :: res res = string_type ( padr ( char ( string ), output_length , pad_with )) end function padr_string_pad_with !> Right pad the input string with \" \" (1 whitespace) !> !> Returns a new string pure function padr_char_default ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = string end function padr_char_default !> Right pad the input string with the 'pad_with' character !> !> Returns a new string pure function padr_char_pad_with ( string , output_length , pad_with ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = 1 ), intent ( in ) :: pad_with character ( len = max ( len ( string ), output_length )) :: res integer :: string_length string_length = len ( string ) res = string if ( string_length < output_length ) then res ( string_length + 1 : output_length ) = & repeat ( pad_with , output_length - string_length ) end if end function padr_char_pad_with !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_string_string ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), char ( pattern ), consider_overlapping ) end function count_string_string !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_string_char ( string , pattern , consider_overlapping ) result ( res ) type ( string_type ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( char ( string ), pattern , consider_overlapping ) end function count_string_char !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_char_string ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string type ( string_type ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: res res = count ( string , char ( pattern ), consider_overlapping ) end function count_char_string !> Returns the number of times substring 'pattern' has appeared in the !> input string 'string' !> Returns an integer elemental function count_char_char ( string , pattern , consider_overlapping ) result ( res ) character ( len =* ), intent ( in ) :: string character ( len =* ), intent ( in ) :: pattern logical , intent ( in ), optional :: consider_overlapping integer :: lps_array ( len ( pattern )) integer :: res , s_i , p_i , length_string , length_pattern res = 0 length_string = len ( string ) length_pattern = len ( pattern ) if ( length_pattern > 0 . and . length_pattern <= length_string ) then lps_array = compute_lps ( pattern ) s_i = 1 p_i = 1 do while ( s_i <= length_string ) if ( string ( s_i : s_i ) == pattern ( p_i : p_i )) then if ( p_i == length_pattern ) then res = res + 1 if ( pic_optional ( consider_overlapping , . true .)) then p_i = lps_array ( p_i ) else p_i = 0 end if end if s_i = s_i + 1 p_i = p_i + 1 else if ( p_i > 1 ) then p_i = lps_array ( p_i - 1 ) + 1 else s_i = s_i + 1 end if end do end if end function count_char_char !> Left pad the input string with zeros !> !> Returns a new string pure function zfill_string ( string , output_length ) result ( res ) type ( string_type ), intent ( in ) :: string integer , intent ( in ) :: output_length type ( string_type ) :: res res = string_type ( padl ( char ( string ), output_length , \"0\" )) end function zfill_string !> Left pad the input string with zeros !> !> Returns a new string pure function zfill_char ( string , output_length ) result ( res ) character ( len =* ), intent ( in ) :: string integer , intent ( in ) :: output_length character ( len = max ( len ( string ), output_length )) :: res res = padl ( string , output_length , \"0\" ) end function zfill_char !> Convert a Fortran character string to a C character array !> !> Version: experimental pure function to_c_char_from_char ( value ) result ( cstr ) character ( len =* ), intent ( in ) :: value character ( kind = c_char ) :: cstr ( len ( value ) + 1 ) integer :: i , lv lv = len ( value ) do concurrent ( i = 1 : lv ) cstr ( i ) = value ( i : i ) end do cstr ( lv + 1 ) = c_null_char end function to_c_char_from_char !> Convert a Fortran string type to a C character array !> !> Version: experimental pure function to_c_char_from_string ( value ) result ( cstr ) type ( string_type ), intent ( in ) :: value character ( kind = c_char ) :: cstr ( slen ( value ) + 1 ) integer :: i , lv lv = slen ( value ) do concurrent ( i = 1 : lv ) cstr ( i ) = char ( value , pos = i ) end do cstr ( lv + 1 ) = c_null_char end function to_c_char_from_string !> Joins a list of strings with a separator (default: space). !> Returns a new string pure type ( string_type ) function join_string ( strings , separator ) type ( string_type ), intent ( in ) :: strings (:) character ( len =* ), intent ( in ), optional :: separator integer :: ltot , i , lt , pos character ( len = :), allocatable :: sep , joined ! Determine separator: use user-provided separator or default space if ( present ( separator )) then sep = separator else sep = ' ' end if ! Calculate the total length required, including separators ltot = sum ( len_trim ( strings )) + ( size ( strings ) - 1 ) * len ( sep ) allocate ( character ( len = ltot ) :: joined ) ! Concatenate strings with separator pos = 0 do i = 1 , size ( strings ) lt = len_trim ( strings ( i )) joined ( pos + 1 : pos + lt ) = char ( strings ( i ), 1 , lt ) pos = pos + lt if ( i < size ( strings )) then joined ( pos + 1 : pos + len ( sep )) = sep pos = pos + len ( sep ) end if end do call move ( from = joined , to = join_string ) end function join_string !> Joins a list of strings with a separator (default: space). !> Returns a new string pure function join_char ( strings , separator ) result ( joined ) character ( * ), intent ( in ) :: strings (:) character ( len =* ), intent ( in ), optional :: separator character ( len = :), allocatable :: joined integer :: ltot , i , lt , pos character ( len = :), allocatable :: sep ! Determine separator: use user-provided separator or default space if ( present ( separator )) then sep = separator else sep = ' ' end if ! Calculate the total length required, including separators ltot = sum ( len_trim ( strings )) + ( size ( strings ) - 1 ) * len ( sep ) allocate ( character ( len = ltot ) :: joined ) joined = repeat ( ' ' , ltot ) ! Concatenate strings with separator pos = 0 do i = 1 , size ( strings ) lt = len_trim ( strings ( i )) joined ( pos + 1 : pos + lt ) = strings ( i ) ( 1 : lt ) pos = pos + lt if ( i < size ( strings )) then joined ( pos + 1 : pos + len ( sep )) = sep pos = pos + len ( sep ) end if end do end function join_char end module pic_strings","tags":"","url":"sourcefile/pic_strings.f90.html"},{"title":"pic_sorting_ord_sort.f90 – PIC","text":"This file is subjec† both to the Fortran Standard Library license, and\nto additional licensing requirements as it contains translations of\nother software. The Fortran Standard Library, including this file, is distributed under\nthe MIT license that should be included with the library’s distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n  copy of this software and associated documentation files (the\n  “Software”),  to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sellcopies of the Software, and to permit\n  persons to whom the Software is furnished to do so, subject to the\n  following conditions: The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, ORD_SORT , is substantially a translation to\nFortran 2008 of the \"Rust\" sort sorting routines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n  file at the top-level directory of this distribution and at\n  http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n  option. This file may not be copied, modified, or distributed\n  except according to those terms. so the license for the original slice.rs code is compatible with the use\nof modified versions of the code in the Fortran Standard Library under\nthe MIT license. This file depends on sourcefile~~pic_sorting_ord_sort.f90~~EfferentGraph sourcefile~pic_sorting_ord_sort.f90 pic_sorting_ord_sort.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_sorting_ord_sort.f90~~AfferentGraph sourcefile~pic_sorting_ord_sort.f90 pic_sorting_ord_sort.f90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_ord_sort.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Licensing: !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `ORD_SORT`, is substantially a translation to !! Fortran 2008 of the `\"Rust\" sort` sorting routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. !submodule(pic_sorting) pic_sorting_ord_sort module pic_sorting_ord_sort use pic_types , only : int32 , int64 , sp , dp , int_index use pic_optional_value , only : pic_optional implicit none public :: ord_sort !! The generic subroutine implementing the `ORD_SORT` algorithm to return !! an input array with its elements sorted in order of (non-)decreasing !! value. Its use has the syntax: !! !!     call ord_sort( array[, work, reverse] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`, !!   `type(bitset_64)`, `type(bitset_large)`. If both the !!   type of `array` is real and at least one of the elements is a !!   `NaN`, then the ordering of the result is undefined. Otherwise it !!   is defined to be the original elements in non-decreasing order. !! !! * work (optional): shall be a rank 1 array of the same type as !!   `array`, and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `array` will be sorted in order of non-increasing values in stable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in stable order. !! !!#### Example !! !!```fortran !!    ... !!    ! Read arrays from sorted files !!    call read_sorted_file( 'dummy_file1', array1 ) !!    call read_sorted_file( 'dummy_file2', array2 ) !!    ! Concatenate the arrays !!    allocate( array( size(array1) + size(array2) ) ) !!    array( 1:size(array1) ) = array1(:) !!    array( size(array1)+1:size(array1)+size(array2) ) = array2(:) !!    ! Sort the resulting array !!    call ord_sort( array, work ) !!    ! Process the sorted array !!    call array_search( array, values ) !!    ... !!``` private integer , parameter :: & ! The maximum number of entries in a run stack, good for an array of ! 2**64 elements see ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt max_merge_stack = int ( ceiling ( log ( 2._dp ** 64 ) / & log ( 1.6180339887_dp ))) type run_type !! Used to pass state around in a stack among helper functions for the !! `ORD_SORT` and `SORT_INDEX` algorithms integer ( int_index ) :: base = 0 integer ( int_index ) :: len = 0 end type run_type interface ord_sort !! The generic subroutine interface implementing the `ORD_SORT` algorithm, !! a translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in !! `slice.rs` !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 !! `ORD_SORT` is a hybrid stable comparison algorithm combining `merge sort`, !! and `insertion sort`. !! !! It is always at worst O(N Ln(N)) in sorting random !! data, having a performance about 25% slower than `SORT` on such !! data, but has much better performance than `SORT` on partially !! sorted data, having O(N) performance on uniformly non-increasing or !! non-decreasing data. module subroutine int32_ord_sort ( array , work , reverse ) implicit none !! `int32_ord_sort( array )` sorts the input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_ord_sort module subroutine int64_ord_sort ( array , work , reverse ) implicit none !! `int64_ord_sort( array )` sorts the input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_ord_sort module subroutine sp_ord_sort ( array , work , reverse ) implicit none !! `sp_ord_sort( array )` sorts the input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_ord_sort module subroutine dp_ord_sort ( array , work , reverse ) implicit none !! `dp_ord_sort( array )` sorts the input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_ord_sort module subroutine char_ord_sort ( array , work , reverse ) implicit none !! `char_ord_sort( array )` sorts the input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_ord_sort end interface ord_sort contains module subroutine int32_ord_sort ( array , work , reverse ) integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call int32_decrease_ord_sort ( array , work ) else call int32_increase_ord_sort ( array , work ) end if end subroutine int32_ord_sort module subroutine int64_ord_sort ( array , work , reverse ) integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call int64_decrease_ord_sort ( array , work ) else call int64_increase_ord_sort ( array , work ) end if end subroutine int64_ord_sort module subroutine sp_ord_sort ( array , work , reverse ) real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call sp_decrease_ord_sort ( array , work ) else call sp_increase_ord_sort ( array , work ) end if end subroutine sp_ord_sort module subroutine dp_ord_sort ( array , work , reverse ) real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call dp_decrease_ord_sort ( array , work ) else call dp_increase_ord_sort ( array , work ) end if end subroutine dp_ord_sort module subroutine char_ord_sort ( array , work , reverse ) character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) logical , intent ( in ), optional :: reverse if ( pic_optional ( reverse , . false .)) then call char_decrease_ord_sort ( array , work ) else call char_increase_ord_sort ( array , work ) end if end subroutine char_ord_sort subroutine int32_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int32 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int32_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int32_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_increase_ord_sort subroutine int64_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int64 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int64_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int64_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_increase_ord_sort subroutine sp_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) real ( sp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"sp_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"sp_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_increase_ord_sort subroutine dp_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) real ( dp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"dp_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"dp_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_increase_ord_sort subroutine char_increase_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"char_increase_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else block character ( len = :), allocatable :: buf (:) ! Allocate a buffer to use as scratch memory. allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"char_increase_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end block end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_increase_ord_sort subroutine int32_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int32 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int32_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int32_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_decrease_ord_sort subroutine int64_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int64 ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"int64_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"int64_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_decrease_ord_sort subroutine sp_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) real ( sp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"sp_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"sp_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( sp ), intent ( inout ) :: array ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_decrease_ord_sort subroutine dp_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) real ( dp ), allocatable :: buf (:) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"dp_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else ! Allocate a buffer to use as scratch memory. allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"dp_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. real ( dp ), intent ( inout ) :: array ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_decrease_ord_sort subroutine char_decrease_ord_sort ( array , work ) ! A translation to Fortran 2008, of the `\"Rust\" sort` algorithm found in ! `slice.rs` ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and an optional `work` array to be used as ! scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ) :: array_size integer :: stat array_size = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"char_decrease_ord_sort: work array is too small.\" end if ! Use the work array as scratch memory call merge_sort ( array , work ) else block character ( len = :), allocatable :: buf (:) ! Allocate a buffer to use as scratch memory. allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) if ( stat /= 0 ) error stop \"char_decrease_ord_sort: Allocation of buffer failed.\" call merge_sort ( array , buf ) end block end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array ) ! Sorts `ARRAY` using an insertion sort. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: i , j character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) >= key ) exit array ( i + 1 ) = array ( i ) i = i - 1 end do array ( i + 1 ) = key end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i tmp = array ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) <= tmp ) exit find_hole array ( i - 1 ) = array ( i ) end do find_hole array ( i - 1 ) = tmp end subroutine insert_head subroutine merge_sort ( array , buf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. character ( len =* ), intent ( inout ) :: array ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least ! min_run elements. Slices of up to this length are sorted using insertion ! sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) > array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) <= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) > array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) >= array ( j )) then array ( k ) = buf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter ! check that it is stable buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) <= array ( i )) then array ( k ) = buf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_decrease_ord_sort !end submodule pic_sorting_ord_sort end module pic_sorting_ord_sort","tags":"","url":"sourcefile/pic_sorting_ord_sort.f90.html"},{"title":"pic_global_definitions.f90 – PIC","text":"this is an experimental file that contains definitions\nthat will be uses across the program, for example input/output units\nthat PIC will use across things. This file depends on sourcefile~~pic_global_definitions.f90~~EfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_global_definitions.f90~~AfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_logger.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this is an experimental file that contains definitions !! that will be uses across the program, for example input/output units !! that PIC will use across things. module pic_global_definitions !! Global definitions for input output use pic_types , only : default_int , sp , dp implicit none private public :: stdout , logfile_unit public :: tol_sp , tol_dp integer ( default_int ), parameter :: stdout = 6 !! assign output unit 6 for stdout integer ( default_int ), parameter :: logfile_unit = 99 !! assign output unit 99 for the logfile real ( dp ), parameter :: tol_dp = 1.0e-12_dp real ( sp ), parameter :: tol_sp = 1.0e-6_sp end module pic_global_definitions","tags":"","url":"sourcefile/pic_global_definitions.f90.html"},{"title":"pic_constants.f90 – PIC","text":"all things constants, physical, chemical, etc This file depends on sourcefile~~pic_constants.f90~~EfferentGraph sourcefile~pic_constants.f90 pic_constants.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_constants.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! all things constants, physical, chemical, etc module pic_constants !! this will be the physical constants module use pic_types , only : dp implicit none private real ( dp ), parameter , public :: gravity = 9.81_dp end module pic_constants","tags":"","url":"sourcefile/pic_constants.f90.html"},{"title":"pic_sorting.f90 – PIC","text":"This file is subject both to the Fortran Standard Library license, and\nto additional licensing requirements as it contains translations of\nother software. The Fortran Standard Library, including this file, is distributed under\nthe MIT license that should be included with the library’s distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n  copy of this software and associated documentation files (the\n  “Software”),  to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sellcopies of the Software, and to permit\n  persons to whom the Software is furnished to do so, subject to the\n  following conditions: The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Two of the generic subroutines, ORD_SORT and SORT_INDEX , are\nsubstantially translations to Fortran 2008 of the \"Rust\" sort sorting\nroutines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n  file at the top-level directory of this distribution and at\n  http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n  option. This file may not be copied, modified, or distributed\n  except according to those terms. so the license for the original slice.rs code is compatible with the use\nof modified versions of the code in the Fortran Standard Library under\nthe MIT license. One of the generic subroutines, SORT , is substantially a\ntranslation to Fortran 2008, of the introsort of David Musser.\nDavid Musser has given permission to include a variant of introsort in the Fortran Standard Library under the MIT license provided\nwe cite: Musser, D.R., “Introspective Sorting and Selection Algorithms,”\n  Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). as the official source of the algorithm. This file depends on sourcefile~~pic_sorting.f90~~EfferentGraph sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_sorting.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_ord_sort.f90 pic_sorting_ord_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_ord_sort.f90 sourcefile~pic_sorting_radix_sort.f90 pic_sorting_radix_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_radix_sort.f90 sourcefile~pic_sorting_sort.f90 pic_sorting_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort.f90 sourcefile~pic_sorting_sort_index.f90 pic_sorting_sort_index.F90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort_index.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_sorting.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Licensing: !! !! This file is subject both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! Two of the generic subroutines, `ORD_SORT` and `SORT_INDEX`, are !! substantially translations to Fortran 2008 of the `\"Rust\" sort` sorting !! routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. !! !! One of the generic subroutines, `SORT`, is substantially a !! translation to Fortran 2008, of the `introsort` of David Musser. !! David Musser has given permission to include a variant of `introsort` !! in the Fortran Standard Library under the MIT license provided !! we cite: !! !!   Musser, D.R., “Introspective Sorting and Selection Algorithms,” !!   Software—Practice and Experience, Vol. 27(8), 983–993 (August 1997). !! !! as the official source of the algorithm. ! taken from the Fortran stdlib project since the stdlib does not build with the nvidia compilers ! and I need portability module pic_sorting !! This module implements overloaded sorting subroutines named `ORD_SORT`, !! `SORT_INDEX`, and `SORT`, that each can be used to sort two kinds !! of `INTEGER` arrays, two kinds of `REAL` arrays, `character(len=*)` arrays !! !! By default sorting is in order of !! increasing value, but there is an option to sort in decreasing order. !! All the subroutines have worst case run time performance of `O(N Ln(N))`, !! but on largely sorted data `ORD_SORT` and `SORT_INDEX` can have a run time !! performance of `O(N)`. !! !! `ORD_SORT` is a translation of the `\"Rust\" sort` sorting algorithm in !! `slice.rs`: !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs !! which in turn is inspired by the `timsort` algorithm of Tim Peters, !! http://svn.python.org/projects/python/trunk/Objects/listsort.txt. !! `ORD_SORT` is a hybrid stable comparison algorithm combining `merge sort`, !! and `insertion sort`. It is always at worst O(N Ln(N)) in sorting random !! data, having a performance about 25% slower than `SORT` on such !! data, but has much better performance than `SORT` on partially !! sorted data, having O(N) performance on uniformly non-increasing or !! non-decreasing data. !! !! `SORT_INDEX` is a modification of `ORD_SORT` so that in addition to !! sorting the input array, it returns the indices that map to a !! stable sort of the original array. These indices are !! intended to be used to sort data that is correlated with the input !! array, e.g., different arrays in a database, different columns of a !! rank 2 array, different elements of a derived type. It is less !! efficient than `ORD_SORT` at sorting a simple array. !! !! `SORT` uses the `INTROSORT` sorting algorithm of David Musser, !! http://www.cs.rpi.edu/~musser/gp/introsort.ps. `introsort` is a hybrid !! unstable comparison algorithm combining `quicksort`, `insertion sort`, and !! `heap sort`. While this algorithm is always O(N Ln(N)) it is relatively !! fast on randomly ordered data, but inconsistent in performance on partly !! sorted data, sometimes having `merge sort` performance, sometimes having !! better than `quicksort` performance. `UNORD_SOORT` is about 25% !! more efficient than `ORD_SORT` at sorting purely random data, but af an !! order of `Ln(N)` less efficient at sorting partially sorted data. use pic_types , only : & int32 , & int64 , & sp , & dp use pic_optional_value , only : pic_optional use pic_sorting_ord_sort , only : ord_sort use pic_sorting_radix_sort , only : radix_sort use pic_sorting_sort , only : sort use pic_sorting_sort_index , only : sort_index implicit none private public :: ord_sort , sort_index , sort , radix_sort end module pic_sorting","tags":"","url":"sourcefile/pic_sorting.f90.html"},{"title":"pic_command_line.f90 – PIC","text":"The pic_command_line.f90 file will contain all routines that will interact with the command line This file depends on sourcefile~~pic_command_line.f90~~EfferentGraph sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! The pic_command_line.f90 file will contain all routines that will interact with the command line module pic_command_line !! command line interaction module use pic_types , only : default_int implicit none private public :: get_first_arg_from_command_line contains function get_first_arg_from_command_line () result ( filename ) !! get the first argument from the command line, this is expected to be a filename !! !! Usage: filename = get_first_arg_from_command_line() !! character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line end module pic_command_line","tags":"","url":"sourcefile/pic_command_line.f90.html"},{"title":"pic_device.f90 – PIC","text":"device handling routines This file depends on sourcefile~~pic_device.f90~~EfferentGraph sourcefile~pic_device.f90 pic_device.f90 sourcefile~pic_gpu_runtime.f90 pic_gpu_runtime.F90 sourcefile~pic_device.f90->sourcefile~pic_gpu_runtime.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_device.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! device handling routines module pic_device !! contains the general routines that interface to the pic_gpu_runtime module !! there are not C interfaces in this file use iso_c_binding , only : c_int , c_size_t use pic_types , only : dp , int32 use pic_gpu_runtime , only : gpugetmeminfo , gpugetdevice , gpugetdevicecount implicit none private public :: device_type public :: to_string public :: get_gpu_information public :: get_device_id public :: get_gpu_memory_info type :: device_type !! general device container, contains the id, free, total , and used memory real ( dp ) :: free_mb = 0.0_dp real ( dp ) :: total_mb = 0.0_dp real ( dp ) :: used_mb = 0.0_dp integer ( c_int ) :: device_id = - 1_c_int contains procedure , non_overridable :: get_device_info => get_gpu_information end type device_type interface to_string !! convenient way to print the device_type using to_string(my_device) procedure :: to_string_device end interface contains subroutine get_gpu_information ( self ) !! call my_device%get_gpu_informatio() style subroutine to populate the object class ( device_type ), intent ( inout ) :: self call get_gpu_memory_info ( self ) call get_device_id ( self ) end subroutine get_gpu_information function to_string_device ( self ) result ( str ) !! cute printing routine for the pic device type, transforms the contents into a !! string of chars class ( device_type ), intent ( in ) :: self character ( len = :), allocatable :: str character ( len = 100 ) :: temp_str integer ( int32 ) :: total_len total_len = len ( \"Device ID:   \" ) + 6 + & len ( \"Free memory: \" ) + 20 + & len ( \"Total memory:\" ) + 20 + & len ( \"Used memory: \" ) + 20 + 3 * len ( new_line ( 'a' )) allocate ( character ( len = total_len ) :: str ) write ( temp_str , '(I0)' ) self % device_id str = \"Device ID:   \" // trim ( temp_str ) // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % free_mb str = str // \"Free memory: \" // trim ( adjustl ( temp_str )) // \" MB\" // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % total_mb str = str // \"Total memory: \" // trim ( adjustl ( temp_str )) // \" MB\" // new_line ( 'a' ) write ( temp_str , '(F10.2)' ) self % used_mb str = str // \"Used memory:  \" // trim ( adjustl ( temp_str )) // \" MB\" end function to_string_device subroutine get_device_id ( mem ) !! routine to get the device id for the device_type type ( device_type ), intent ( inout ) :: mem integer ( c_int ) :: ierr , device_id call gpugetdevice ( device_id , ierr ) if ( ierr == 0_c_int ) then mem % device_id = device_id else mem % device_id = - 1_c_int end if end subroutine get_device_id subroutine get_gpu_memory_info ( mem ) !! routine to get the free and total memory for the device_type object !! can be used independently with call get_gpu_memory_info(device_object) type ( device_type ), intent ( inout ) :: mem integer ( c_size_t ) :: freeMem , totalMem integer ( c_int ) :: ierr call gpugetmeminfo ( freeMem , totalMem , ierr ) if ( ierr == 0_c_int ) then mem % free_mb = real ( freeMem , kind = dp ) / 102 4.0_dp / 102 4.0_dp mem % total_mb = real ( totalMem , kind = dp ) / 102 4.0_dp / 102 4.0_dp mem % used_mb = mem % total_mb - mem % free_mb else mem = device_type () ! zero it end if end subroutine get_gpu_memory_info end module pic_device","tags":"","url":"sourcefile/pic_device.f90.html"},{"title":"pic_hash_32bit.f90 – PIC","text":"This file depends on sourcefile~~pic_hash_32bit.f90~~EfferentGraph sourcefile~pic_hash_32bit.f90 pic_hash_32bit.f90 sourcefile~pic_hash_32bit_fnv.f90 pic_hash_32bit_fnv.f90 sourcefile~pic_hash_32bit.f90->sourcefile~pic_hash_32bit_fnv.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_hash_32bit.f90->sourcefile~pic_types.f90 sourcefile~pic_hash_32bit_fnv.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module pic_hash_32bit use pic_hash_32bit_fnv , only : fnv_1_hash , fnv_1a_hash use pic_types , only : & dp , & int32 , & int64 implicit none private ! pow32_over_phi is the odd integer that most closely approximates 2**32/phi, ! where phi is the golden ratio 1.618... integer ( int32 ), parameter :: & pow32_over_phi = int ( z '9E3779B9' , int32 ) public :: & fnv_1_hash , & fnv_1a_hash end module pic_hash_32bit","tags":"","url":"sourcefile/pic_hash_32bit.f90.html"},{"title":"pic_strings_to_strings.F90 – PIC","text":"This file depends on sourcefile~~pic_strings_to_strings.f90~~EfferentGraph sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings.f90->sourcefile~pic_ascii.f90 sourcefile~pic_strings.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90->sourcefile~pic_types.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( pic_strings ) pic_strings_to_string use pic_string_type , only : string_type implicit none integer , parameter :: buffer_len = 128 character ( len =* ), parameter :: err_sym = \"[*]\" !!TODO: [*]? contains !> Format or transfer a real(sp) scalar as a string. pure module function to_string_r_sp ( value , format ) result ( string ) real ( sp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , '(' // pic_optional ( format , \"g0\" ) // ')' , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_r_sp !> Format or transfer a real(dp) scalar as a string. pure module function to_string_r_dp ( value , format ) result ( string ) real ( dp ), intent ( in ) :: value character ( len =* ), intent ( in ), optional :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , '(' // pic_optional ( format , \"g0\" ) // ')' , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_r_dp !> Represent an integer of kind int32 as character sequence. pure module function to_string_1_i_int32 ( value ) result ( string ) integer , parameter :: ik = int32 integer ( ik ), intent ( in ) :: value character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( value ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer ( ik ) :: n character ( len = 1 ), parameter :: numbers ( - 9 : 0 ) = & [ \"9\" , \"8\" , \"7\" , \"6\" , \"5\" , \"4\" , \"3\" , \"2\" , \"1\" , \"0\" ] if ( value == 0_ik ) then string = numbers ( 0 ) return end if n = sign ( value , - 1_ik ) buffer = \"\" pos = buffer_len + 1 do while ( n < 0_ik ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10_ik )) n = n / 10_ik end do if ( value < 0_ik ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function to_string_1_i_int32 pure module function to_string_2_i_int32 ( value , format ) result ( string ) integer ( int32 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = :), allocatable :: adjusted_format character ( len = buffer_len ) :: buffer integer :: stat #ifdef __NVCOMPILER_LLVM__ adjusted_format = fix_nvhpc_octal_format ( format ) #else adjusted_format = format #endif write ( buffer , \"(\" // adjusted_format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_i_int32 !> Represent an integer of kind int64 as character sequence. pure module function to_string_1_i_int64 ( value ) result ( string ) integer , parameter :: ik = int64 integer ( ik ), intent ( in ) :: value character ( len = :), allocatable :: string integer , parameter :: buffer_len = range ( value ) + 2 character ( len = buffer_len ) :: buffer integer :: pos integer ( ik ) :: n character ( len = 1 ), parameter :: numbers ( - 9 : 0 ) = & [ \"9\" , \"8\" , \"7\" , \"6\" , \"5\" , \"4\" , \"3\" , \"2\" , \"1\" , \"0\" ] if ( value == 0_ik ) then string = numbers ( 0 ) return end if n = sign ( value , - 1_ik ) buffer = \"\" pos = buffer_len + 1 do while ( n < 0_ik ) pos = pos - 1 buffer ( pos : pos ) = numbers ( mod ( n , 10_ik )) n = n / 10_ik end do if ( value < 0_ik ) then pos = pos - 1 buffer ( pos : pos ) = '-' end if string = buffer ( pos :) end function to_string_1_i_int64 pure module function to_string_2_i_int64 ( value , format ) result ( string ) integer ( int64 ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = :), allocatable :: adjusted_format character ( len = buffer_len ) :: buffer integer :: stat #ifdef __NVCOMPILER_LLVM__ adjusted_format = fix_nvhpc_octal_format ( format ) #else adjusted_format = format #endif write ( buffer , \"(\" // adjusted_format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_i_int64 pure function fix_nvhpc_octal_format ( fmt ) result ( fixed ) character ( len =* ), intent ( in ) :: fmt character ( len = :), allocatable :: fixed integer :: pos , dot_pos character ( len = 10 ) :: precision_str ! Check if format contains \"O0.\" pos = index ( fmt , 'O0.' ) if ( pos > 0 ) then ! Extract precision after the dot dot_pos = pos + 2 ! Position of '.' precision_str = fmt ( dot_pos + 1 :) ! Replace O0.w with Ow.w (where w is the precision) fixed = fmt ( 1 : pos - 1 ) // 'O' // trim ( precision_str ) // '.' // trim ( precision_str ) else fixed = fmt end if end function fix_nvhpc_octal_format !> Represent an logical of kind fbool as character sequence. pure module function to_string_1_l_fbool ( value ) result ( string ) logical ( fbool ), intent ( in ) :: value character ( len = 1 ) :: string string = merge ( \"T\" , \"F\" , value ) end function to_string_1_l_fbool pure module function to_string_2_l_fbool ( value , format ) result ( string ) logical ( fbool ), intent ( in ) :: value character ( len =* ), intent ( in ) :: format character ( len = :), allocatable :: string character ( len = buffer_len ) :: buffer integer :: stat write ( buffer , \"(\" // format // \")\" , iostat = stat ) value if ( stat == 0 ) then string = trim ( buffer ) else string = err_sym end if end function to_string_2_l_fbool end submodule pic_strings_to_string","tags":"","url":"sourcefile/pic_strings_to_strings.f90.html"},{"title":"pic_gpu_runtime.F90 – PIC","text":"General cuda/hip agnostic module to interface to GPU runtimes Files dependent on this one sourcefile~~pic_gpu_runtime.f90~~AfferentGraph sourcefile~pic_gpu_runtime.f90 pic_gpu_runtime.F90 sourcefile~pic_device.f90 pic_device.f90 sourcefile~pic_device.f90->sourcefile~pic_gpu_runtime.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! General cuda/hip agnostic module to interface to GPU runtimes module pic_gpu_runtime !! gpu runtime interfaces via iso_c use iso_c_binding , only : c_int , c_size_t implicit none private public :: gpugetmeminfo , gpugetdevicecount , gpugetdevice #ifdef HAVE_CUDA interface function cudaMemGetInfo ( freeMem , totalMem ) bind ( C , name = \"cudaMemGetInfo\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: cudaMemGetInfo integer ( c_size_t ), intent ( out ) :: freeMem , totalMem end function cudaMemGetInfo function cudaGetDevice ( device ) bind ( C , name = \"cudaGetDevice\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: cudaGetDevice integer ( c_int ), intent ( out ) :: device end function cudaGetDevice function cudaGetDeviceCount ( count ) bind ( C , name = \"cudaGetDeviceCount\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: cudaGetDeviceCount integer ( c_int ), intent ( out ) :: count end function cudaGetDeviceCount end interface #elif defined(HAVE_HIP) interface function hipMemGetInfo ( freeMem , totalMem ) bind ( C , name = \"hipMemGetInfo\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: hipMemGetInfo integer ( c_size_t ), intent ( out ) :: freeMem , totalMem end function hipMemGetInfo function hipGetDevice ( device ) bind ( C , name = \"hipGetDevice\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: hipGetDevice integer ( c_int ), intent ( out ) :: device end function hipGetDevice function hipGetDeviceCount ( count ) bind ( C , name = \"hipGetDeviceCount\" ) use iso_c_binding , only : c_int , c_size_t implicit none integer ( c_int ) :: hipGetDeviceCount integer ( c_int ), intent ( out ) :: count end function hipGetDeviceCount end interface #endif contains subroutine gpugetmeminfo ( freeMem , totalMem , ierr ) !! get free and total memory from the GPU runtime integer ( c_size_t ), intent ( out ) :: freeMem , totalMem integer ( c_int ), intent ( out ) :: ierr #ifdef HAVE_CUDA ierr = cudaMemGetInfo ( freeMem , totalMem ) #elif defined(HAVE_HIP) ierr = hipMemGetInfo ( freeMem , totalMem ) #else freeMem = 0_c_size_t totalMem = 0_c_size_t ierr = - 1 #endif end subroutine gpugetmeminfo subroutine gpugetdevice ( device_id , ierr ) !! get current device id from the GPU runtime integer ( c_int ), intent ( out ) :: device_id , ierr #ifdef HAVE_CUDA ierr = cudaGetDevice ( device_id ) #elif defined(HAVE_HIP) ierr = hipGetDevice ( device_id ) #else ierr = - 1_c_int device_id = - 1_c_int #endif end subroutine gpugetdevice subroutine gpugetdevicecount ( device_count , ierr ) !! get device count available from the GPU runtime integer ( c_int ), intent ( out ) :: device_count , ierr #ifdef HAVE_CUDA ierr = cudaGetDeviceCount ( device_count ) #elif defined(HAVE_HIP) ierr = hipGetDeviceCount ( device_count ) #else ierr = - 1_c_int device_count = 0_c_int #endif end subroutine gpugetdevicecount end module pic_gpu_runtime","tags":"","url":"sourcefile/pic_gpu_runtime.f90.html"},{"title":"pic_knowledge.f90 – PIC","text":"the gathered knowledge of the species This file depends on sourcefile~~pic_knowledge.f90~~EfferentGraph sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_logger.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_knowledge.f90->sourcefile~pic_string_type.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_knowledge.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! the gathered knowledge of the species module pic_knowledge !! a simple module that collects phrases and prints them out randomly, like fortune use pic_types , only : int32 , dp use pic_logger , only : logger => global_logger use pic_string_type , only : string_type , assignment ( = ), char implicit none private public :: get_knowledge contains subroutine get_knowledge () !! I print random knowledge type ( string_type ), allocatable :: knowledge (:) integer ( int32 ) :: n , idx real ( dp ) :: r allocate ( knowledge ( 8 )) knowledge ( 1 ) = \"The long line! (CS,2023)\" knowledge ( 2 ) = \"Maybe I have the Fortran brain-rot in Dijkstra's words (IP,2025)\" knowledge ( 3 ) = \"Mojo, yes, do I approve it, no. (IP, 2025)\" knowledge ( 4 ) = \"No, rice does not contain gluten (EG, dawn of time)\" knowledge ( 5 ) = \"Yes, potatoes are gluten free (EG, dawn of time)\" knowledge ( 6 ) = \"Stonks (MS, 2019)\" knowledge ( 7 ) = \"Praise the machine god\" knowledge ( 8 ) = \"Maybe I WILL use a more efficient language: Fortran (Jorge, to CS)\" n = size ( knowledge ) call random_number ( r ) idx = int ( r * n ) + 1 if ( idx > n ) idx = n call logger % knowledge ( trim ( char ( knowledge ( idx )))) end subroutine get_knowledge end module pic_knowledge","tags":"","url":"sourcefile/pic_knowledge.f90.html"},{"title":"pic_logger.f90 – PIC","text":"the pic_logger.f90 is the base file that defines the logger function\nthis is heavily inspired by the logger from the standard library\nbut with some key changes for my purposes.\nThe logger will be the way in which the code interacts\nwith the output to console and files This file depends on sourcefile~~pic_logger.f90~~EfferentGraph sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_logger.f90~~AfferentGraph sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_logger.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! the pic_logger.f90 is the base file that defines the logger function !! this is heavily inspired by the logger from the standard library !! but with some key changes for my purposes. !! The logger will be the way in which the code interacts !! with the output to console and files module pic_logger !! this is the logger module use pic_types , only : default_int use pic_global_definitions , only : stdout , logfile_unit implicit none private public :: global_logger , logger_type character ( * ), parameter :: name = \"pic_logger\" integer ( default_int ), parameter , public :: & debug_level = 10 , & verbose_level = 9 , & info_level = 8 , & performance_level = 7 , & warning_level = 6 , & error_level = 5 , & knowledge_level = 4 type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ), non_overridable :: configuration !! Get the current logger verbosity configuration. !! Usage: call my_logger%configuration(level) procedure , public , pass ( self ), non_overridable :: configure !! Configure the logger to be a certain verbosity level. !! Usage: call my_logger%configure(level) procedure , public , pass ( self ), non_overridable :: configure_file_output !! Configure the logger to file to be a certain verbosity level. !! Usage: call my_logger%configure_file_output(filename, level) procedure , public , pass ( self ), non_overridable :: close_log_file !! Close the log file, needs to be called at the end of the program. !! Usage: call my_logger%close_log_file() procedure , public , pass ( self ), non_overridable :: debug !! Log a message that will only be printed at the debug level of verbosity. !! Usage: call my_logger%debug(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: verbose !! Log a message that will only be printed at the verbose level of verbosity. !! Usage: call my_logger%verbose(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: info !! Log a message that will only be printed at the info level of verbosity. !! Usage: call my_logger%info(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: performance !! Log a message that will only be printed at the performance level of verbosity. !! Usage: call my_logger%performance(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: warning !! Log a message that will only be printed at the warning level of verbosity. !! Usage: call my_logger%warning(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: error !! Log a message that will only be printed at the error level of verbosity. !! Usage: call my_logger%error(\"MESSAGE\") procedure , public , pass ( self ), non_overridable :: knowledge !! Log a message that will only be printed at the knowledge level of verbosity. !! Usage: call my_logger%knowledge(\"MESSAGE\") procedure , private , pass ( self ), non_overridable :: log !! Processes the message and filters it according to the verbosity level set by the user or the default end type logger_type type ( logger_type ) :: global_logger contains pure subroutine configuration ( self , level ) !! Get the current logger verbosity configuration !! !! Usage: call my_logger%configuration(level) !! !! TODO: this should be a function class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration pure subroutine configure ( self , level ) !! Configure the logger to be a certain verbosity level !! !! Usage: call my_logger%configure(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5, & !! !! knowledge_level = 4 !! class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure subroutine configure_file_output ( self , filename , level ) !! Configure the logger to file to be a certain verbosity level !! !! Usage: call my_logger%configure_file_output(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5, & !! !! knowledge_level = 4 !! class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = \"replace\" , action = \"write\" , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) \"ERROR: Failed to open log file: \" , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output subroutine close_log_file ( self ) !! Close the log file, needs to be called at the end of the program !! !! Usage: call my_logger%close_log_file() !! !! TODO: revisit class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file subroutine debug ( self , message , module , procedure ) !! Log a message that will only be printed at the debug level of verbosity !! !! Usage: call my_logger%debug(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug subroutine verbose ( self , message , module , procedure ) !! Log a message that will only be printed at the verbose level of verbosity !! !! Usage: call my_logger%verbose(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose subroutine info ( self , message , module , procedure ) !! Log a message that will only be printed at the info level of verbosity !! !! Usage: call my_logger%info(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info subroutine warning ( self , message , module , procedure ) !! Log a message that will only be printed at the warning level of verbosity !! !! Usage: call my_logger%warning(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning subroutine performance ( self , message , module , procedure ) !! Log a message that will only be printed at the performance of verbosity !! !! Usage: call my_logger%performance(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance subroutine error ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%error(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error subroutine knowledge ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%knowledge(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"LORE\" , message , module , procedure ) end subroutine knowledge subroutine write_log_line ( unit , level , message , module , procedure ) !! Internal subroutine that will write the message to the log !! no interface to the public integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line subroutine log ( self , level , message , module , procedure ) !! internal subroutines that processes the message and filters it according to !! the verbosity level set by the user or the default !! this is a private subroutine so it is not exposed to the user class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( \"DEBUG\" ) log_level_value = debug_level case ( \"VERBOSE\" ) log_level_value = verbose_level case ( \"INFO\" ) log_level_value = info_level case ( \"WARNING\" ) log_level_value = warning_level case ( \"PERFORMANCE\" ) log_level_value = performance_level case ( \"ERROR\" ) log_level_value = error_level case ( \"LORE\" ) log_level_value = knowledge_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log end module pic_logger","tags":"","url":"sourcefile/pic_logger.f90.html"},{"title":"pic_array.f90 – PIC","text":"pic array contains L0.5 BLAS level routines, as in things that could be use in\nlieu of blas if you don’t have it but if you do, please don’t use these routines This file depends on sourcefile~~pic_array.f90~~EfferentGraph sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_array.f90->sourcefile~pic_io.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_array.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_array.f90->sourcefile~pic_types.f90 sourcefile~pic_io.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! pic array contains L0.5 BLAS level routines, as in things that could be use in !! lieu of blas if you don't have it but if you do, please don't use these routines module pic_array !! Please do not modify this file to implement new methods, please go look at tools/autogen/pic_array_cpu.fypp !! and edit the generator. use pic_types , only : sp , dp , int32 , int64 , default_int use pic_io , only : to_char , to_upper use pic_optional_value , only : pic_optional implicit none private public :: pic_fill , pic_copy public :: pic_transpose , pic_sum public :: pic_scramble_array , pic_print_array public :: is_sorted public :: set_threading_mode , get_threading_mode logical :: use_threaded_default = . false . public :: ASCENDING , DESCENDING integer ( default_int ), parameter :: ASCENDING = 1 integer ( default_int ), parameter :: DESCENDING = 2 character ( len = 5 ), parameter :: default_format = \"NUMPY\" !! supported formats: NUMPY, MATHEMATICA, and PLAIN which resembles numpy character ( len =* ), parameter :: fmt_edge = \"(A)\" character ( len =* ), parameter :: fmt_in = '(A, \", \")' interface set_threading_mode !! set_threading sets the threading mode for the array routines !! this will set the use_threaded variable to true or false depending on the input !! Usage: call set_threading_mode(.true.) or call set_threading_mode(.false.) module procedure set_threading_mode_ end interface interface get_threading_mode !! get_threading_mode returns the current threading mode for the array routines !! Usage: mode = get_threading_mode() module procedure get_threading_mode_ end interface get_threading_mode interface pic_fill !! fill provides a generic interface to assing a value !! alpha of types (int32, int64, sp, dp) as defined in pic_types.F90 !! The inteface supports filling 1d and 2d arrays of the specified !! variables !! !! Usage: call pic_fill(array, value, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to .true. !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism module procedure fill_vector_int32 module procedure fill_vector_int64 module procedure fill_vector_sp module procedure fill_vector_dp module procedure fill_matrix_int32 module procedure fill_matrix_int64 module procedure fill_matrix_sp module procedure fill_matrix_dp module procedure fill_3d_tensor_int32 module procedure fill_3d_tensor_int64 module procedure fill_3d_tensor_sp module procedure fill_3d_tensor_dp end interface interface pic_copy !! copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy !! if you built pic with BLAS use the copy interface provided there, I will not beat BLAS !! copy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types !! !! Usage: call pic_copy(destination, source, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to .true. !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism module procedure copy_vector_int32 module procedure copy_vector_int64 module procedure copy_vector_sp module procedure copy_vector_dp module procedure copy_matrix_int32 module procedure copy_matrix_int64 module procedure copy_matrix_sp module procedure copy_matrix_dp module procedure copy_3d_tensor_int32 module procedure copy_3d_tensor_int64 module procedure copy_3d_tensor_sp module procedure copy_3d_tensor_dp end interface interface pic_transpose !! pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic !! which will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices !! !! pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays !! !! Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to true !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism !! module procedure transpose_matrix_int32 module procedure transpose_matrix_int64 module procedure transpose_matrix_sp module procedure transpose_matrix_dp end interface interface pic_sum !! pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will !! be too slow for large sizes of vectors and matrices. Note that this provides the total !! sum. As opposed to the blas alternative XASUM which does the absolute sum !! !! pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays !! !! Usage: result = pic_sum(array, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to true !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism !! module procedure sum_vector_int32 module procedure sum_vector_int64 module procedure sum_vector_sp module procedure sum_vector_dp module procedure sum_matrix_int32 module procedure sum_matrix_int64 module procedure sum_matrix_sp module procedure sum_matrix_dp module procedure sum_3d_tensor_int32 module procedure sum_3d_tensor_int64 module procedure sum_3d_tensor_sp module procedure sum_3d_tensor_dp end interface interface is_sorted !! is_sorted provides a simple way to checking if a 1d array is sorted !! it is implemented for int32, int64, sp, and dp datatypes. The default !! is to check if an array is sorted in ascending fashion. !! !! Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) module procedure is_sorted_int32 module procedure is_sorted_int64 module procedure is_sorted_sp module procedure is_sorted_dp module procedure is_sorted_char end interface interface pic_print_array !! Generic interface for printing arrays of different types !! !! Usage: call pic_print_array(array, [optional] format) !! Where format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) !! !! Implemented types are: !! !! array(:)   -> int32, int64, sp, dp !! !! array(:,:) -> int32, int64, sp, dp !! !! array(:) (packed matrix) -> sp, dp !! !! array(:,:,:) -> sp, dp !! module procedure print_vector_int32 module procedure print_vector_int64 module procedure print_vector_sp module procedure print_vector_dp module procedure print_matrix_int32 module procedure print_matrix_int64 module procedure print_matrix_sp module procedure print_matrix_dp module procedure print_packed_matrix_int32 module procedure print_packed_matrix_int64 module procedure print_packed_matrix_sp module procedure print_packed_matrix_dp module procedure print_3d_tensor_int32 module procedure print_3d_tensor_int64 module procedure print_3d_tensor_sp module procedure print_3d_tensor_dp end interface interface pic_scramble_array module procedure scramble_array_int32 module procedure scramble_array_int64 module procedure scramble_array_sp module procedure scramble_array_dp module procedure scramble_array_character end interface pic_scramble_array ! potentially implement a shallow copy? nah? integer ( default_int ), parameter :: block_size = 32 !! This is the size to block over for matrices for performance purposes contains subroutine set_threading_mode_ ( threaded ) !! set the threading mode for the array routines, this will set the use_threaded variable !! to true or false depending on the input !! !! Usage: call set_threading(.true.) or call set_threading(.false.) logical , intent ( in ) :: threaded use_threaded_default = threaded end subroutine set_threading_mode_ function get_threading_mode_ () result ( mode ) !! get the current threading mode for the array routines !! Usage: mode = get_threading_mode() logical :: mode mode = use_threaded_default end function get_threading_mode_ subroutine set_brackets ( format_type , open_bracket , close_bracket ) !! Set brackets based on output format type character ( len =* ), intent ( in ) :: format_type character ( len = 1 ), intent ( out ) :: open_bracket , close_bracket select case ( trim ( to_upper ( adjustl ( format_type )))) case ( \"NUMPY\" ) open_bracket = \"[\" close_bracket = \"]\" case ( \"MATHEMATICA\" ) open_bracket = \"{\" close_bracket = \"}\" case ( \"PLAIN\" ) open_bracket = \"[\" close_bracket = \"]\" case default print * , \"Warning: Unsupported format type '\" // trim ( format_type ) // \"'. Defaulting to NumPy style.\" open_bracket = \"[\" close_bracket = \"]\" end select end subroutine set_brackets subroutine fill_vector_int32 ( vector , alpha , threaded ) integer ( int32 ), intent ( inout ) :: vector (:) integer ( int32 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int32 subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int64 subroutine fill_vector_sp ( vector , alpha , threaded ) real ( sp ), intent ( inout ) :: vector (:) real ( sp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_sp subroutine fill_vector_dp ( vector , alpha , threaded ) real ( dp ), intent ( inout ) :: vector (:) real ( dp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_dp subroutine fill_matrix_int32 ( matrix , alpha , threaded ) integer ( int32 ), intent ( inout ) :: matrix (:, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int32 subroutine fill_matrix_int64 ( matrix , alpha , threaded ) integer ( int64 ), intent ( inout ) :: matrix (:, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int64 subroutine fill_matrix_sp ( matrix , alpha , threaded ) real ( sp ), intent ( inout ) :: matrix (:, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_sp subroutine fill_matrix_dp ( matrix , alpha , threaded ) real ( dp ), intent ( inout ) :: matrix (:, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_dp subroutine fill_3d_tensor_int32 ( tensor , alpha , threaded ) integer ( int32 ), intent ( inout ) :: tensor (:, :, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_int32 subroutine fill_3d_tensor_int64 ( tensor , alpha , threaded ) integer ( int64 ), intent ( inout ) :: tensor (:, :, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_int64 subroutine fill_3d_tensor_sp ( tensor , alpha , threaded ) real ( sp ), intent ( inout ) :: tensor (:, :, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_sp subroutine fill_3d_tensor_dp ( tensor , alpha , threaded ) real ( dp ), intent ( inout ) :: tensor (:, :, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz logical , intent ( in ), optional :: threaded logical :: use_threads nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) tensor ( i , j , k ) = alpha end do end do end do end do end do end do !$omp end parallel do else tensor = alpha end if end subroutine fill_3d_tensor_dp subroutine copy_vector_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:) integer ( int32 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int32 subroutine copy_vector_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:) integer ( int64 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int64 subroutine copy_vector_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:) real ( sp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_sp subroutine copy_vector_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:) real ( dp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_dp subroutine copy_matrix_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :) integer ( int32 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int32 subroutine copy_matrix_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :) integer ( int64 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int64 subroutine copy_matrix_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :) real ( sp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_sp subroutine copy_matrix_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :) real ( dp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_dp subroutine copy_3d_tensor_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :, :) integer ( int32 ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_int32 subroutine copy_3d_tensor_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :, :) integer ( int64 ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_int64 subroutine copy_3d_tensor_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :, :) real ( sp ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_sp subroutine copy_3d_tensor_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :, :) real ( dp ), intent ( in ) :: source (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , k integer ( default_int ) :: ii , jj , kk integer ( default_int ) :: nx , ny , nz ! --- Size checks --- if ( size ( dest , 1 ) /= size ( source , 1 ) & . or . size ( dest , 2 ) /= size ( source , 2 ) & . or . size ( dest , 3 ) /= size ( source , 3 )) then error stop \"Tensor size mismatch\" end if nx = size ( source , 1 ) ny = size ( source , 2 ) nz = size ( source , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) dest ( i , j , k ) = source ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_3d_tensor_dp subroutine transpose_matrix_int32 ( A , B , threaded ) integer ( int32 ), intent ( in ) :: A (:, :) integer ( int32 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int32 subroutine transpose_matrix_int64 ( A , B , threaded ) integer ( int64 ), intent ( in ) :: A (:, :) integer ( int64 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int64 subroutine transpose_matrix_sp ( A , B , threaded ) real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_sp subroutine transpose_matrix_dp ( A , B , threaded ) real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_dp function sum_vector_int32 ( vector , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: i res = 0_int32 use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int32 function sum_vector_int64 ( vector , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: i res = 0_int64 use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int64 function sum_vector_sp ( vector , threaded ) result ( res ) real ( sp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: i res = 0_sp use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_sp function sum_vector_dp ( vector , threaded ) result ( res ) real ( dp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: i res = 0_dp use_threads = pic_optional ( threaded , use_threaded_default ) if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_dp function sum_matrix_int32 ( matrix , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int32 function sum_matrix_int64 ( matrix , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int64 function sum_matrix_sp ( matrix , threaded ) result ( res ) real ( sp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_sp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_sp function sum_matrix_dp ( matrix , threaded ) result ( res ) real ( dp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_dp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_dp function sum_3d_tensor_int32 ( tensor , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_int32 function sum_3d_tensor_int64 ( tensor , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_int64 function sum_3d_tensor_sp ( tensor , threaded ) result ( res ) real ( sp ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_sp if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_sp function sum_3d_tensor_dp ( tensor , threaded ) result ( res ) real ( dp ), intent ( in ) :: tensor (:, :, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: nx , ny , nz integer ( default_int ) :: i , j , k , ii , jj , kk nx = size ( tensor , 1 ) ny = size ( tensor , 2 ) nz = size ( tensor , 3 ) use_threads = pic_optional ( threaded , use_threaded_default ) res = 0_dp if ( use_threads ) then !$omp parallel do collapse(3) private(i,j,k,ii,jj,kk) reduction(+: res) do kk = 1 , nz , block_size do jj = 1 , ny , block_size do ii = 1 , nx , block_size do k = kk , min ( kk + block_size - 1 , nz ) do j = jj , min ( jj + block_size - 1 , ny ) do i = ii , min ( ii + block_size - 1 , nx ) res = res + tensor ( i , j , k ) end do end do end do end do end do end do !$omp end parallel do else res = sum ( tensor ) end if end function sum_3d_tensor_dp pure function is_sorted_int32 ( array , order ) result ( sorted ) integer ( int32 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int32 pure function is_sorted_int64 ( array , order ) result ( sorted ) integer ( int64 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int64 pure function is_sorted_sp ( array , order ) result ( sorted ) real ( sp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_sp pure function is_sorted_dp ( array , order ) result ( sorted ) real ( dp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_dp pure function is_sorted_char ( array , order ) result ( sorted ) character ( len =* ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = pic_optional ( order , ASCENDING ) select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_char subroutine print_vector_int32 ( vector , format_type ) !! print a vector of ${T} values integer ( int32 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int32 subroutine print_vector_int64 ( vector , format_type ) !! print a vector of ${T} values integer ( int64 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int64 subroutine print_vector_sp ( vector , format_type ) !! print a vector of ${T} values real ( sp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_sp subroutine print_vector_dp ( vector , format_type ) !! print a vector of ${T} values real ( dp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_char ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_dp subroutine print_matrix_int32 ( matrix , format_type ) !! print a matrix of ${T} values integer ( int32 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int32 subroutine print_matrix_int64 ( matrix , format_type ) !! print a matrix of ${T} values integer ( int64 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int64 subroutine print_matrix_sp ( matrix , format_type ) !! print a matrix of ${T} values real ( sp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_sp subroutine print_matrix_dp ( matrix , format_type ) !! print a matrix of ${T} values real ( dp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_char ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_char ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_dp subroutine print_packed_matrix_int32 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values integer ( int32 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int32 subroutine print_packed_matrix_int64 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values integer ( int64 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int64 subroutine print_packed_matrix_sp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values real ( sp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_sp subroutine print_packed_matrix_dp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of ${T} values real ( dp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format print_format = pic_optional ( format_type , default_format ) call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size using proper real arithmetic n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp , default_int ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_char ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_char ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_dp subroutine print_3d_tensor_int32 ( matrix , format_type ) !! Print a 3D tensor of ${T} values integer ( int32 ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_int32 subroutine print_3d_tensor_int64 ( matrix , format_type ) !! Print a 3D tensor of ${T} values integer ( int64 ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_int64 subroutine print_3d_tensor_sp ( matrix , format_type ) !! Print a 3D tensor of ${T} values real ( sp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_sp subroutine print_3d_tensor_dp ( matrix , format_type ) !! Print a 3D tensor of ${T} values real ( dp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format print_format = pic_optional ( format_type , default_format ) print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call pic_print_array ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_dp subroutine scramble_array_int32 ( array ) integer ( int32 ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n integer ( int32 ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_int32 subroutine scramble_array_int64 ( array ) integer ( int64 ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n integer ( int64 ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_int64 subroutine scramble_array_sp ( array ) real ( sp ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n real ( sp ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_sp subroutine scramble_array_dp ( array ) real ( dp ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n real ( dp ) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_dp subroutine scramble_array_character ( array ) character ( len =* ), intent ( inout ) :: array (:) integer ( int32 ) :: i , j , n character ( len = len ( array )) :: temp real ( sp ) :: rand_val n = size ( array ) do i = n , 2 , - 1 call random_number ( rand_val ) j = int ( rand_val * i ) + 1 temp = array ( i ) array ( i ) = array ( j ) array ( j ) = temp end do end subroutine scramble_array_character end module pic_array","tags":"","url":"sourcefile/pic_array.f90.html"},{"title":"pic_sorting_radix_sort.f90 – PIC","text":"This file depends on sourcefile~~pic_sorting_radix_sort.f90~~EfferentGraph sourcefile~pic_sorting_radix_sort.f90 pic_sorting_radix_sort.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_sorting_radix_sort.f90~~AfferentGraph sourcefile~pic_sorting_radix_sort.f90 pic_sorting_radix_sort.f90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_radix_sort.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !submodule(pic_sorting) pic_sorting_radix_sort module pic_sorting_radix_sort use pic_types , only : int32 , int64 , sp , dp , int_index use pic_optional_value , only : pic_optional implicit none public :: radix_sort !! The generic subroutine implementing the LSD radix sort algorithm to return !! an input array with its elements sorted in order of (non-)decreasing !! value. Its use has the syntax: !! !!     call radix_sort( array[, work, reverse] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`. !!   If both the type of `array` is real and at least one of the !!   elements is a `NaN`, then the ordering of the result is undefined. !!   Otherwise it is defined to be the original elements in !!   non-decreasing order. Especially, -0.0 is lesser than 0.0. !! !! * work (optional): shall be a rank 1 array of the same type as !!   `array`, and shall have at least `size(array)` elements. It is an !!   `intent(inout)` argument to be used as buffer. Its value on return is !!   undefined. If it is not present, `radix_sort` will allocate a !!   buffer for use, and deallocate it before return. If you do several !!   similar `radix_sort`s, reusing the `work` array is a good parctice. !!   This argument is not present for `int8_radix_sort` because it use !!   counting sort, so no buffer is needed. !! !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `array` will be sorted in order of non-increasing values in stable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in stable order. !! !!#### Example !! !!```fortran !!    ... !!    ! Read random data from a file !!    call read_file( 'dummy_file', array ) !!    ! Sort the random data !!    call radix_sort( array ) !!    ... !!``` private integer , parameter :: radix_bits = 8 integer , parameter :: radix_mask = 255 integer ( kind = int32 ), parameter :: radix_bits_i32 = 8_int32 integer ( kind = int32 ), parameter :: radix_mask_i32 = 255_int32 integer ( kind = int64 ), parameter :: radix_bits_i64 = 8_int64 integer ( kind = int64 ), parameter :: radix_mask_i64 = 255_int64 interface radix_sort !! The generic subroutine interface implementing the LSD radix sort algorithm, !! see https://en.wikipedia.org/wiki/Radix_sort for more details. !! It is always O(N) in sorting random data, but need a O(N) buffer. !! ([Specification](../page/specs/stdlib_sorting.html#radix_sort-sorts-an-input-array)) !! pure module subroutine int32_radix_sort ( array , work , reverse ) implicit none integer ( kind = int32 ), dimension (:), intent ( inout ) :: array integer ( kind = int32 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine int32_radix_sort pure module subroutine int64_radix_sort ( array , work , reverse ) implicit none integer ( kind = int64 ), dimension (:), intent ( inout ) :: array integer ( kind = int64 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine int64_radix_sort module subroutine sp_radix_sort ( array , work , reverse ) implicit none real ( kind = sp ), dimension (:), intent ( inout ), target :: array real ( kind = sp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine sp_radix_sort module subroutine dp_radix_sort ( array , work , reverse ) implicit none real ( kind = dp ), dimension (:), intent ( inout ), target :: array real ( kind = dp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse end subroutine dp_radix_sort end interface radix_sort contains pure subroutine radix_sort_u32_helper ( N , arr , buf ) integer ( kind = int_index ), intent ( in ) :: N integer ( kind = int32 ), dimension ( N ), intent ( inout ) :: arr integer ( kind = int32 ), dimension ( N ), intent ( inout ) :: buf integer ( kind = int_index ) :: i integer :: b , b0 , b1 , b2 , b3 integer ( kind = int_index ), dimension ( 0 : radix_mask ) :: c0 , c1 , c2 , c3 c0 (:) = 0 c1 (:) = 0 c2 (:) = 0 c3 (:) = 0 do i = 1 , N b0 = iand ( arr ( i ), radix_mask_i32 ) b1 = iand ( ishft ( arr ( i ), - radix_bits_i32 ), radix_mask_i32 ) b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i32 ), radix_mask_i32 ) b3 = ishft ( arr ( i ), - 3 * radix_bits_i32 ) c0 ( b0 ) = c0 ( b0 ) + 1 c1 ( b1 ) = c1 ( b1 ) + 1 c2 ( b2 ) = c2 ( b2 ) + 1 c3 ( b3 ) = c3 ( b3 ) + 1 end do do b = 1 , radix_mask c0 ( b ) = c0 ( b ) + c0 ( b - 1 ) c1 ( b ) = c1 ( b ) + c1 ( b - 1 ) c2 ( b ) = c2 ( b ) + c2 ( b - 1 ) c3 ( b ) = c3 ( b ) + c3 ( b - 1 ) end do do i = N , 1 , - 1 b0 = iand ( arr ( i ), radix_mask_i32 ) buf ( c0 ( b0 )) = arr ( i ) c0 ( b0 ) = c0 ( b0 ) - 1 end do do i = N , 1 , - 1 b1 = iand ( ishft ( buf ( i ), - radix_bits_i32 ), radix_mask_i32 ) arr ( c1 ( b1 )) = buf ( i ) c1 ( b1 ) = c1 ( b1 ) - 1 end do do i = N , 1 , - 1 b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i32 ), radix_mask_i32 ) buf ( c2 ( b2 )) = arr ( i ) c2 ( b2 ) = c2 ( b2 ) - 1 end do do i = N , 1 , - 1 b3 = ishft ( buf ( i ), - 3 * radix_bits_i32 ) arr ( c3 ( b3 )) = buf ( i ) c3 ( b3 ) = c3 ( b3 ) - 1 end do end subroutine radix_sort_u32_helper pure subroutine radix_sort_u64_helper ( N , arr , buffer ) integer ( kind = int_index ), intent ( in ) :: N integer ( kind = int64 ), dimension ( N ), intent ( inout ) :: arr integer ( kind = int64 ), dimension ( N ), intent ( inout ) :: buffer integer ( kind = int_index ) :: i integer ( kind = int64 ) :: b , b0 , b1 , b2 , b3 , b4 , b5 , b6 , b7 integer ( kind = int_index ), dimension ( 0 : radix_mask ) :: c0 , c1 , c2 , c3 , c4 , c5 , c6 , c7 c0 (:) = 0 c1 (:) = 0 c2 (:) = 0 c3 (:) = 0 c4 (:) = 0 c5 (:) = 0 c6 (:) = 0 c7 (:) = 0 do i = 1 , N b0 = iand ( arr ( i ), radix_mask_i64 ) b1 = iand ( ishft ( arr ( i ), - radix_bits_i64 ), radix_mask_i64 ) b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i64 ), radix_mask_i64 ) b3 = iand ( ishft ( arr ( i ), - 3 * radix_bits_i64 ), radix_mask_i64 ) b4 = iand ( ishft ( arr ( i ), - 4 * radix_bits_i64 ), radix_mask_i64 ) b5 = iand ( ishft ( arr ( i ), - 5 * radix_bits_i64 ), radix_mask_i64 ) b6 = iand ( ishft ( arr ( i ), - 6 * radix_bits_i64 ), radix_mask_i64 ) b7 = ishft ( arr ( i ), - 7 * radix_bits_i64 ) c0 ( b0 ) = c0 ( b0 ) + 1 c1 ( b1 ) = c1 ( b1 ) + 1 c2 ( b2 ) = c2 ( b2 ) + 1 c3 ( b3 ) = c3 ( b3 ) + 1 c4 ( b4 ) = c4 ( b4 ) + 1 c5 ( b5 ) = c5 ( b5 ) + 1 c6 ( b6 ) = c6 ( b6 ) + 1 c7 ( b7 ) = c7 ( b7 ) + 1 end do do b = 1 , radix_mask c0 ( b ) = c0 ( b ) + c0 ( b - 1 ) c1 ( b ) = c1 ( b ) + c1 ( b - 1 ) c2 ( b ) = c2 ( b ) + c2 ( b - 1 ) c3 ( b ) = c3 ( b ) + c3 ( b - 1 ) c4 ( b ) = c4 ( b ) + c4 ( b - 1 ) c5 ( b ) = c5 ( b ) + c5 ( b - 1 ) c6 ( b ) = c6 ( b ) + c6 ( b - 1 ) c7 ( b ) = c7 ( b ) + c7 ( b - 1 ) end do do i = N , 1 , - 1 b0 = iand ( arr ( i ), radix_mask_i64 ) buffer ( c0 ( b0 )) = arr ( i ) c0 ( b0 ) = c0 ( b0 ) - 1 end do do i = N , 1 , - 1 b1 = iand ( ishft ( buffer ( i ), - radix_bits_i64 ), radix_mask_i64 ) arr ( c1 ( b1 )) = buffer ( i ) c1 ( b1 ) = c1 ( b1 ) - 1 end do do i = N , 1 , - 1 b2 = iand ( ishft ( arr ( i ), - 2 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c2 ( b2 )) = arr ( i ) c2 ( b2 ) = c2 ( b2 ) - 1 end do do i = N , 1 , - 1 b3 = iand ( ishft ( buffer ( i ), - 3 * radix_bits_i64 ), radix_mask_i64 ) arr ( c3 ( b3 )) = buffer ( i ) c3 ( b3 ) = c3 ( b3 ) - 1 end do do i = N , 1 , - 1 b4 = iand ( ishft ( arr ( i ), - 4 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c4 ( b4 )) = arr ( i ) c4 ( b4 ) = c4 ( b4 ) - 1 end do do i = N , 1 , - 1 b5 = iand ( ishft ( buffer ( i ), - 5 * radix_bits_i64 ), radix_mask_i64 ) arr ( c5 ( b5 )) = buffer ( i ) c5 ( b5 ) = c5 ( b5 ) - 1 end do do i = N , 1 , - 1 b6 = iand ( ishft ( arr ( i ), - 6 * radix_bits_i64 ), radix_mask_i64 ) buffer ( c6 ( b6 )) = arr ( i ) c6 ( b6 ) = c6 ( b6 ) - 1 end do do i = N , 1 , - 1 b7 = ishft ( buffer ( i ), - 7 * radix_bits_i64 ) arr ( c7 ( b7 )) = buffer ( i ) c7 ( b7 ) = c7 ( b7 ) - 1 end do end subroutine radix_sort_u64_helper pure module subroutine int32_radix_sort ( array , work , reverse ) integer ( kind = int32 ), dimension (:), intent ( inout ) :: array integer ( kind = int32 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse integer ( kind = int_index ) :: i , N , start , middle , end integer ( kind = int32 ), dimension (:), pointer :: buffer integer ( kind = int32 ) :: item logical :: use_internal_buffer N = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < N ) then error stop \"int32_radix_sort: work array is too small.\" end if use_internal_buffer = . false . buffer => work else use_internal_buffer = . true . allocate ( buffer ( N )) end if call radix_sort_u32_helper ( N , array , buffer ) if ( array ( 1 ) >= 0 . and . array ( N ) < 0 ) then start = 1 end = N middle = ( 1 + N ) / 2 do while (. true .) if ( array ( middle ) >= 0 ) then start = middle + 1 else end = middle end if middle = ( start + end ) / 2 if ( start == end ) exit end do buffer ( 1 :( N - middle + 1 )) = array ( middle : N ) buffer ( N - middle + 2 : N ) = array ( 1 : middle - 1 ) array (:) = buffer (:) end if if ( pic_optional ( reverse , . false .)) then do i = 1 , N / 2 item = array ( i ) array ( i ) = array ( N - i + 1 ) array ( N - i + 1 ) = item end do end if if ( use_internal_buffer ) then deallocate ( buffer ) end if end subroutine int32_radix_sort module subroutine sp_radix_sort ( array , work , reverse ) use iso_c_binding , only : c_loc , c_f_pointer real ( kind = sp ), dimension (:), intent ( inout ), target :: array real ( kind = sp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse integer ( kind = int_index ) :: i , N , pos , rev_pos integer ( kind = int32 ), dimension (:), pointer :: arri32 integer ( kind = int32 ), dimension (:), pointer :: buffer real ( kind = sp ) :: item logical :: use_internal_buffer N = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < N ) then error stop \"sp_radix_sort: work array is too small.\" end if use_internal_buffer = . false . call c_f_pointer ( c_loc ( work ), buffer , [ N ]) else use_internal_buffer = . true . allocate ( buffer ( N )) end if call c_f_pointer ( c_loc ( array ), arri32 , [ N ]) call radix_sort_u32_helper ( N , arri32 , buffer ) ! After calling `radix_sort_u<width>_helper. The array is sorted as unsigned integers. ! The positive real number is sorted, guaranteed by IEEE-754 standard. ! But the negative real number is sorted in a reversed order, and also in the tail of array. ! Remark that -0.0 is the minimum nagative integer, so using radix sort, -0.0 is naturally lesser than 0.0. ! In IEEE-754 standard, the bit representation of `Inf` is greater than all positive real numbers, ! and the `-Inf` is lesser than all negative real numbers. So the order of `Inf, -Inf` is ok. ! The bit representation of `NaN` may be positive or negative integers in different machine, ! thus if the array contains `NaN`, the result is undefined. if ( arri32 ( 1 ) >= 0 . and . arri32 ( N ) < 0 ) then pos = 1 rev_pos = N do while ( arri32 ( rev_pos ) < 0 ) buffer ( pos ) = arri32 ( rev_pos ) pos = pos + 1 rev_pos = rev_pos - 1 end do buffer ( pos : N ) = arri32 ( 1 : rev_pos ) arri32 (:) = buffer (:) end if if ( pic_optional ( reverse , . false .)) then do i = 1 , N / 2 item = array ( i ) array ( i ) = array ( N - i + 1 ) array ( N - i + 1 ) = item end do end if if ( use_internal_buffer ) then deallocate ( buffer ) end if end subroutine sp_radix_sort pure module subroutine int64_radix_sort ( array , work , reverse ) integer ( kind = int64 ), dimension (:), intent ( inout ) :: array integer ( kind = int64 ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse integer ( kind = int_index ) :: i , N , start , middle , end integer ( kind = int64 ), dimension (:), pointer :: buffer integer ( kind = int64 ) :: item logical :: use_internal_buffer N = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < N ) then error stop \"int64_radix_sort: work array is too small.\" end if use_internal_buffer = . false . buffer => work else use_internal_buffer = . true . allocate ( buffer ( N )) end if call radix_sort_u64_helper ( N , array , buffer ) if ( array ( 1 ) >= 0 . and . array ( N ) < 0 ) then start = 1 end = N middle = ( 1 + N ) / 2 do while (. true .) if ( array ( middle ) >= 0 ) then start = middle + 1 else end = middle end if middle = ( start + end ) / 2 if ( start == end ) exit end do buffer ( 1 :( N - middle + 1 )) = array ( middle : N ) buffer ( N - middle + 2 : N ) = array ( 1 : middle - 1 ) array (:) = buffer (:) end if if ( pic_optional ( reverse , . false .)) then do i = 1 , N / 2 item = array ( i ) array ( i ) = array ( N - i + 1 ) array ( N - i + 1 ) = item end do end if if ( use_internal_buffer ) then deallocate ( buffer ) end if end subroutine int64_radix_sort module subroutine dp_radix_sort ( array , work , reverse ) use iso_c_binding , only : c_loc , c_f_pointer real ( kind = dp ), dimension (:), intent ( inout ), target :: array real ( kind = dp ), dimension (:), intent ( inout ), target , optional :: work logical , intent ( in ), optional :: reverse integer ( kind = int_index ) :: i , N , pos , rev_pos integer ( kind = int64 ), dimension (:), pointer :: arri64 integer ( kind = int64 ), dimension (:), pointer :: buffer real ( kind = dp ) :: item logical :: use_internal_buffer N = size ( array , kind = int_index ) if ( present ( work )) then if ( size ( work , kind = int_index ) < N ) then error stop \"sp_radix_sort: work array is too small.\" end if use_internal_buffer = . false . call c_f_pointer ( c_loc ( work ), buffer , [ N ]) else use_internal_buffer = . true . allocate ( buffer ( N )) end if call c_f_pointer ( c_loc ( array ), arri64 , [ N ]) call radix_sort_u64_helper ( N , arri64 , buffer ) if ( arri64 ( 1 ) >= 0 . and . arri64 ( N ) < 0 ) then pos = 1 rev_pos = N do while ( arri64 ( rev_pos ) < 0 ) buffer ( pos ) = arri64 ( rev_pos ) pos = pos + 1 rev_pos = rev_pos - 1 end do buffer ( pos : N ) = arri64 ( 1 : rev_pos ) arri64 (:) = buffer (:) end if if ( pic_optional ( reverse , . false .)) then do i = 1 , N / 2 item = array ( i ) array ( i ) = array ( N - i + 1 ) array ( N - i + 1 ) = item end do end if if ( use_internal_buffer ) then deallocate ( buffer ) end if end subroutine dp_radix_sort !end submodule pic_sorting_radix_sort end module pic_sorting_radix_sort","tags":"","url":"sourcefile/pic_sorting_radix_sort.f90.html"},{"title":"pic_optional.f90 – PIC","text":"Optional value handling module This file depends on sourcefile~~pic_optional.f90~~EfferentGraph sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_optional.f90~~AfferentGraph sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_array.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_ord_sort.f90 pic_sorting_ord_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_ord_sort.f90 sourcefile~pic_sorting_radix_sort.f90 pic_sorting_radix_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_radix_sort.f90 sourcefile~pic_sorting_sort.f90 pic_sorting_sort.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort.f90 sourcefile~pic_sorting_sort_index.f90 pic_sorting_sort_index.F90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort_index.f90 sourcefile~pic_sorting_ord_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_radix_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort.f90->sourcefile~pic_optional.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_optional.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_strings.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_knowledge.f90 pic_knowledge.f90 sourcefile~pic_knowledge.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_string_type.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_strings_to_strings.f90 pic_strings_to_strings.F90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings_to_strings.f90->sourcefile~pic_strings.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Optional value handling module module pic_optional_value !! This module provides functions to handle optional arguments use pic_types , only : sp , dp , int32 , int64 implicit none private public :: pic_optional interface pic_optional !! Overloaded interface for optional value retrieval, supported types are: !! - integer(int32), integer(int64), real(sp), real(dp), character(len=*), logical module procedure :: optional_int32 module procedure :: optional_int64 module procedure :: optional_sp module procedure :: optional_dp module procedure :: optional_char module procedure :: optional_logical end interface contains pure function optional_int32 ( input_value , default_value ) result ( output ) !! Handle optional integer(int32) value integer ( int32 ), intent ( in ), optional :: input_value integer ( int32 ), intent ( in ) :: default_value integer ( int32 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int32 pure function optional_int64 ( input_value , default_value ) result ( output ) !! Handle optional integer(int64) value integer ( int64 ), intent ( in ), optional :: input_value integer ( int64 ), intent ( in ) :: default_value integer ( int64 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int64 pure function optional_sp ( input_value , default_value ) result ( output ) !! Handle optional real(sp) value real ( sp ), intent ( in ), optional :: input_value real ( sp ), intent ( in ) :: default_value real ( sp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_sp pure function optional_dp ( input_value , default_value ) result ( output ) !! Handle optional real(dp) value real ( dp ), intent ( in ), optional :: input_value real ( dp ), intent ( in ) :: default_value real ( dp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_dp pure function optional_char ( input_value , default_value ) result ( output ) !! Handle optional character(len=*) value character ( len =* ), intent ( in ), optional :: input_value character ( len =* ), intent ( in ) :: default_value character ( len = :), allocatable :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_char pure function optional_logical ( input_value , default_value ) result ( output ) !! Handle optional logical value logical , intent ( in ), optional :: input_value logical , intent ( in ) :: default_value logical :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_logical end module pic_optional_value","tags":"","url":"sourcefile/pic_optional.f90.html"},{"title":"pic_mpi.F90 – PIC","text":"Source Code #ifdef PIC_HAVE_MPI !! The pic_mpi.F90 file is the main interface to the MPI implementation, it should !! be done in such a way that we can compile the library with and without MPI !! it will be a pain in general, but meh, let's see what we can do module pic_mpi !! General MPI interface module use pic_types , only : int32 use mpi_f08 , only : MPI_COMM , MPI_COMM_WORLD , MPI_Init , MPI_Finalize , & MPI_Comm_size , MPI_Comm_rank implicit none private public :: pic_comm_type type :: pic_comm_type !! custom data type that holds the MPI communicators private type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface integer ( int32 ), public :: m_rank !! MPI rank integer ( int32 ), public :: m_size !! MPI size integer ( int32 ), public :: m_ierr contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm_type type ( pic_comm_type ), public :: world_comm !! our world comm contains subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr , rank , size call MPI_Init ( ierr ) self % m_ierr = ierr self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank end subroutine pic_comm_init subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr call MPI_Finalize ( ierr ) self % m_ierr = ierr end subroutine pic_comm_finalize end module pic_mpi #endif","tags":"","url":"sourcefile/pic_mpi.f90.html"},{"title":"pic_flop_rate.f90 – PIC","text":"flop rate handler modules This file depends on sourcefile~~pic_flop_rate.f90~~EfferentGraph sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_io.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_io.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_io.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop rate handler modules module pic_flop_rate !! pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer !! it is used to measure the flop rate of a given operation, and report it use pic_types , only : dp , int64 use pic_timer , only : timer_type use pic_flop_recorder , only : flop_recorder_type use pic_io , only : to_char implicit none private public :: flop_rate_type type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( timer_type ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure , non_overridable :: start_time => flop_rate_start_time procedure , non_overridable :: stop_time => flop_rate_stop_time procedure , non_overridable :: add_flops => flop_rate_add_flops procedure , non_overridable :: get_flops => flop_rate_get_flops procedure , non_overridable :: get_time => flop_rate_get_time procedure , non_overridable :: get_flop_rate => flop_rate_get_flop_rate procedure , non_overridable :: report => flop_rate_report procedure , non_overridable :: reset => flop_rate_reset end type flop_rate_type contains subroutine flop_rate_start_time ( self ) !! Calls the start method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%start_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % start () end subroutine flop_rate_start_time subroutine flop_rate_stop_time ( self ) !! Calls the stop method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%stop_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % stop () end subroutine flop_rate_stop_time subroutine flop_rate_add_flops ( self , flops ) !! add flops to the flop rate type, this will add the flops to the flop recorder !! Usage: call my_flop_rate%add_flops(1000) !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops call self % m_flops % add ( flops ) end subroutine flop_rate_add_flops function flop_rate_get_flops ( self ) result ( flops ) !! get the number of flops recorded in the flop rate type !! !! Usage: flops = my_flop_rate%get_flops() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % m_flops % get () end function flop_rate_get_flops function flop_rate_get_time ( self ) result ( time ) !! get the elapsed time in seconds from the timer contained in the flop rate type !! !! Usage: time = my_flop_rate%get_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self real ( dp ) :: time time = self % m_timer % get_elapsed_time () end function flop_rate_get_time function flop_rate_get_flop_rate ( self ) result ( flop_rate ) !! get the flop rate in GFLOP/s, this will calculate the flop rate based on the !! number of flops and the elapsed time !! !! Usage: flop_rate = my_flop_rate%get_flop_rate() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self real ( dp ) :: flop_rate real ( dp ) :: time integer ( int64 ) :: flops flops = self % m_flops % get () time = self % m_timer % get_elapsed_time () if ( time <= 0.0_dp ) then print * , \"Warning: Time is zero or negative, setting flop rate to zero.\" self % m_flop_rate = 0.0_dp flop_rate = 0.0_dp return else self % m_flop_rate = flops / time / 1.0e9_dp flop_rate = self % m_flop_rate end if end function flop_rate_get_flop_rate subroutine flop_rate_report ( self ) !! report the flop rate, this will print the flop rate in GFLOP/s !! !! Usage: call my_flop_rate%report() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self self % m_flop_rate = self % get_flop_rate () print * , \"Flop rate is \" // to_char ( self % m_flop_rate ) // \" GFLOP/s\" end subroutine flop_rate_report subroutine flop_rate_reset ( self ) !! reset the flop rate type, this will reset the timer and the flop recorder !! !! Usage: call my_flop_rate%reset() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_flops % reset () end subroutine flop_rate_reset end module pic_flop_rate","tags":"","url":"sourcefile/pic_flop_rate.f90.html"},{"title":"pic_hash_32bit_fnv.f90 – PIC","text":"FNV_1_HASH and FNV_1A_Hash are translations to Fortran 2008 of the FNV-1 and FNV-1a hash functions of Glenn Fowler, Landon Curt Noll,\n and Phong Vo, that has been released into the public domain. Permission\n has been granted, by Landon Curt Noll, for the use of these algorithms\n in the Fortran Standard Library. A description of these functions is\n available at https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function. This file depends on sourcefile~~pic_hash_32bit_fnv.f90~~EfferentGraph sourcefile~pic_hash_32bit_fnv.f90 pic_hash_32bit_fnv.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_hash_32bit_fnv.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_hash_32bit_fnv.f90~~AfferentGraph sourcefile~pic_hash_32bit_fnv.f90 pic_hash_32bit_fnv.f90 sourcefile~pic_hash_32bit.f90 pic_hash_32bit.f90 sourcefile~pic_hash_32bit.f90->sourcefile~pic_hash_32bit_fnv.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !!------------------------------------------------------------------------------ !! `FNV_1_HASH` and  `FNV_1A_Hash` are translations to Fortran 2008 of the !! `FNV-1` and `FNV-1a` hash functions of Glenn Fowler, Landon Curt Noll, !! and Phong Vo, that has been released into the public domain. Permission !! has been granted, by Landon Curt Noll, for the use of these algorithms !! in the Fortran Standard Library. A description of these functions is !! available at https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function. !!------------------------------------------------------------------------------ !#! Integer kinds to be considered during templating module pic_hash_32bit_fnv !! An implementation of the FNV hashes 1 and 1a of Glenn Fowler, Landon Curt !! Noll, and Kiem-Phong-Vo, !! https://en.wikipedia.org/wiki/Fowler–Noll–Vo_hash_function use , intrinsic :: iso_fortran_env , only : & character_storage_size use pic_types , only : int8 , int16 , int32 , int64 , dp implicit none private public :: fnv_1_hash , fnv_1a_hash integer , parameter , public :: & int_hash = int32 integer ( int_hash ), parameter :: & offset_basis = int ( z '811C9DC5' , int_hash ), & prime = int ( z '01000193' , int_hash ) !! The number of bits in the output hash ! The number of bits used by each integer type integer , parameter :: & ! Should be 8 bits_int8 = bit_size ( 0_int8 ), & ! Should be 16 bits_int16 = bit_size ( 0_int16 ), & ! Should be 32 bits_int32 = bit_size ( 0_int32 ), & ! Should be 64 bits_int64 = bit_size ( 0_int64 ) integer , parameter :: & ! Should be 1 bytes_int8 = bits_int8 / bits_int8 , & ! Should be 2 bytes_int16 = bits_int16 / bits_int8 , & ! Should be 4 bytes_int32 = bits_int32 / bits_int8 , & ! Should be 8 bytes_int64 = bits_int64 / bits_int8 integer , parameter :: & bits_char = character_storage_size , & bytes_char = bits_char / bits_int8 ! Dealing with different endians logical , parameter , public :: & little_endian = ( 1 == transfer ([ 1_int8 , 0_int8 ], 0_int16 )) interface fnv_1_hash !! Version: experimental !! !! FNV_1 interfaces pure module function int8_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int8 implicit none integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int8_fnv_1 pure module function int16_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int16 implicit none integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int16_fnv_1 pure module function int32_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int32 implicit none integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int32_fnv_1 pure module function int64_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for rank 1 array keys of kind int64 implicit none integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code end function int64_fnv_1 elemental module function character_fnv_1 ( key ) result ( hash_code ) !! FNV_1 hash function for default character string keys implicit none character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_code end function character_fnv_1 end interface fnv_1_hash interface fnv_1a_hash !! Version: experimental !! !! FNV_1A interfaces pure module function int8_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int8 implicit none integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int8_fnv_1a pure module function int16_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int16 implicit none integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int16_fnv_1a pure module function int32_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int32 implicit none integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int32_fnv_1a pure module function int64_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for rank 1 array keys of kind int64 implicit none integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_value end function int64_fnv_1a elemental module function character_fnv_1a ( key ) result ( hash_value ) !! FNV_1A hash function for default character string keys implicit none character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_value end function character_fnv_1a end interface fnv_1a_hash contains pure module function int8_fnv_1 ( key ) result ( hash_code ) !! The original FNV-1 8-bit key algorithm. integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code integer ( int64 ) :: i hash_code = offset_basis do i = 1_int64 , size ( key , kind = int64 ) hash_code = hash_code * prime if ( little_endian ) then hash_code = ieor ( hash_code , & transfer ([ key ( i ), 0_int8 , 0_int8 , 0_int8 ], & 0_int_hash )) else hash_code = ieor ( hash_code , & transfer ([ 0_int8 , 0_int8 , 0_int8 , key ( i )], & 0_int_hash )) end if end do end function int8_fnv_1 pure module function int16_fnv_1 ( key ) result ( hash_code ) ! A int16 array key wrapper for the FNV-1 algorithm. integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1 ( transfer ( key , 0_int8 , & bytes_int16 * & size ( key , kind = int64 ))) end function int16_fnv_1 pure module function int32_fnv_1 ( key ) result ( hash_code ) ! A int32 array key wrapper for the FNV-1 algorithm. integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1 ( transfer ( key , 0_int8 , & bytes_int32 * & size ( key , kind = int64 ))) end function int32_fnv_1 pure module function int64_fnv_1 ( key ) result ( hash_code ) ! A int64 array key wrapper for the FNV-1 algorithm. integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1 ( transfer ( key , 0_int8 , & bytes_int64 * & size ( key , kind = int64 ))) end function int64_fnv_1 elemental module function character_fnv_1 ( key ) result ( hash_code ) ! A default character key wrapper for the FNV-1 algorithm. character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_code hash_code = int8_fnv_1 ( transfer ( key , & 0_int8 , & bytes_char * & len ( key , kind = int64 ))) end function character_fnv_1 pure module function int8_fnv_1a ( key ) result ( hash_code ) !! The original FNV-1a 8-bit key algorithm. integer ( int8 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code integer ( int64 ) :: i hash_code = offset_basis do i = 1_int64 , size ( key , kind = int64 ) if ( little_endian ) then hash_code = ieor ( hash_code , & transfer ([ key ( i ), 0_int8 , 0_int8 , 0_int8 ], & 0_int_hash )) else hash_code = ieor ( hash_code , & transfer ([ 0_int8 , 0_int8 , 0_int8 , key ( i )], & 0_int_hash )) end if hash_code = hash_code * prime end do end function int8_fnv_1a pure module function int16_fnv_1a ( key ) result ( hash_code ) ! A int16 array key wrapper for the FNV-1a algorithm. integer ( int16 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1a ( transfer ( key , 0_int8 , & bytes_int16 * & size ( key , kind = int64 ))) end function int16_fnv_1a pure module function int32_fnv_1a ( key ) result ( hash_code ) ! A int32 array key wrapper for the FNV-1a algorithm. integer ( int32 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1a ( transfer ( key , 0_int8 , & bytes_int32 * & size ( key , kind = int64 ))) end function int32_fnv_1a pure module function int64_fnv_1a ( key ) result ( hash_code ) ! A int64 array key wrapper for the FNV-1a algorithm. integer ( int64 ), intent ( in ) :: key (:) integer ( int_hash ) :: hash_code hash_code = int8_fnv_1a ( transfer ( key , 0_int8 , & bytes_int64 * & size ( key , kind = int64 ))) end function int64_fnv_1a elemental module function character_fnv_1a ( key ) result ( hash_code ) ! A default character key wrapper for the FNV-1 algorithm. character ( * ), intent ( in ) :: key integer ( int_hash ) :: hash_code hash_code = int8_fnv_1a ( transfer ( key , 0_int8 , & ( bits_char / bits_int8 ) * & len ( key , kind = int64 ))) end function character_fnv_1a end module pic_hash_32bit_fnv","tags":"","url":"sourcefile/pic_hash_32bit_fnv.f90.html"},{"title":"pic_io.f90 – PIC","text":"this file contains “helper” routines, for example printing\na set amount of x characters to creates tables, etc. This file depends on sourcefile~~pic_io.f90~~EfferentGraph sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_io.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_io.f90~~AfferentGraph sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_array.f90->sourcefile~pic_io.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_io.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_timer.f90->sourcefile~pic_io.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains \"helper\" routines, for example printing !! a set amount of x characters to creates tables, etc. module pic_io !! Assorted output helper routines use pic_types , only : sp , dp , int32 , int64 , default_int implicit none private public :: print_asterisk_row public :: to_char , pad , to_upper public :: set_precision , get_precision integer ( default_int ), parameter :: default_dp_precision = 12 integer ( default_int ), parameter :: default_sp_precision = 6 integer ( default_int ) :: dp_precision = default_dp_precision integer ( default_int ) :: sp_precision = default_sp_precision interface to_char !! converts a variable of type (int32, int64, sp, dp, char, logical) !! to a series of chars which is just a collecting of chars. !! !! Usage result = to_char(variable) !! !! @note the functions here are not elemental so they won't work for !! arrays. Please use pic_print_array_v2 module for this !! module procedure to_char_int32 module procedure to_char_int64 module procedure to_char_sp module procedure to_char_dp module procedure to_char_char module procedure to_char_logical module procedure to_char_vector_int32 module procedure to_char_vector_int64 module procedure to_char_vector_sp module procedure to_char_vector_dp module procedure to_char_matrix_int32 module procedure to_char_matrix_int64 module procedure to_char_matrix_sp module procedure to_char_matrix_dp end interface interface to_upper !! takes a character variable and transforms it to uppercase !! !! usage var = to_upper(\"hello\") !! module procedure to_upper end interface interface pad !! adds a number X of spaces to the left of a \"string\" whcih is just a !! collection of characters. Mostly used for nice printing !! !! Usage: var = pad(\"hello\", n_spaces) !! module procedure pad end interface interface set_precision !! This routine overrides the default dp precision used for !! printing strings in the to_char function, the default !! is : integer(default_int), parameter :: default_dp_precision = 12 !! !! Usage: call set_precision(variable) where variable is default_int !! module procedure set_precision_internal end interface interface get_precision !! Obtain the current precision being used to print variables to strings !! !! Usage: precision = get_precision() !! !! returns a default_int result module procedure get_precision end interface contains subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row function to_upper ( str ) result ( upper_str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: upper_str integer ( default_int ) :: i character :: ch do i = 1 , len ( str ) ch = str ( i : i ) if ( ch >= 'a' . and . ch <= 'z' ) then upper_str ( i : i ) = char ( iachar ( ch ) - 32 ) else upper_str ( i : i ) = ch end if end do end function to_upper function pad ( s , width ) result ( padded ) !! function to pad a string with a certain number of characters for nice printing character ( len =* ), intent ( in ) :: s integer ( default_int ), intent ( in ) :: width character ( len = :), allocatable :: padded integer ( default_int ) :: len_s len_s = len_trim ( s ) if ( len_s >= width ) then padded = s ( 1 : width ) else padded = repeat ( \" \" , width - len_s ) // s end if end function pad subroutine set_precision_internal ( precision ) !! Set the precision for real numbers integer ( default_int ), intent ( in ) :: precision if ( precision > 0 ) then dp_precision = precision else print * , \"Warning: Precision must be positive. Using default.\" dp_precision = default_dp_precision end if end subroutine set_precision_internal function get_precision () result ( precision ) !! Get the current precision for real numbers integer ( default_int ) :: precision precision = dp_precision end function get_precision function to_char_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_char_int32 function to_char_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_char_int64 function to_char_sp ( r ) result ( trimmed_str ) !! transform a real(sp) to a string real ( kind = sp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_char_sp function to_char_dp ( r ) result ( trimmed_str ) !! transform a real(dp) to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_char_dp function to_char_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_char_char function to_char_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = \"TRUE\" else str = \"FALSE\" end if trimmed_str = trim ( str ) end function to_char_logical function to_char_vector_dp ( array ) result ( trimmed_str ) real ( kind = dp ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , total_len ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_dp ! Vector to_char functions function to_char_vector_int32 ( array ) result ( trimmed_str ) integer ( int32 ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , total_len ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_int32 function to_char_vector_int64 ( array ) result ( trimmed_str ) integer ( int64 ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , total_len ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , '(I0)' ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_int64 function to_char_vector_sp ( array ) result ( trimmed_str ) real ( kind = sp ), intent ( in ) :: array (:) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , total_len ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , sp_precision , ')' ! Estimate total length needed total_len = 2 ! for brackets do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , size ( array ) write ( temp_str , style ) array ( i ) if ( i < size ( array )) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_vector_sp function to_char_matrix_dp ( array ) result ( trimmed_str ) real ( kind = dp ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' ! Estimate total length needed (rough estimate) total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , style ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , style ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_dp function to_char_matrix_int32 ( array ) result ( trimmed_str ) integer ( int32 ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Estimate total length needed total_len = 10 ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string trimmed_str = \"[\" do i = 1 , nrows if ( i > 1 ) trimmed_str = trimmed_str // \", \" trimmed_str = trimmed_str // \"[\" do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do trimmed_str = trimmed_str // \"]\" end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_int32 function to_char_matrix_int64 ( array ) result ( trimmed_str ) integer ( int64 ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Estimate total length needed total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , '(I0)' ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_int64 function to_char_matrix_sp ( array ) result ( trimmed_str ) real ( kind = sp ), intent ( in ) :: array (:, :) character ( len = :), allocatable :: trimmed_str character ( len = 50 ) :: temp_str character ( len = 32 ) :: style integer :: i , j , total_len , nrows , ncols nrows = size ( array , 1 ) ncols = size ( array , 2 ) ! Set up format write ( style , '(A,I0,A)' ) '(F0.' , sp_precision , ')' ! Estimate total length needed total_len = 10 + nrows ! for outer brackets and newlines do i = 1 , nrows total_len = total_len + 3 ! for row brackets and comma do j = 1 , ncols write ( temp_str , style ) array ( i , j ) total_len = total_len + len_trim ( temp_str ) + 2 ! +2 for \", \" end do end do ! Allocate result string allocate ( character ( len = total_len ) :: trimmed_str ) ! Build the string with newlines trimmed_str = \"[\" // new_line ( 'a' ) do i = 1 , nrows trimmed_str = trimmed_str // \" [\" do j = 1 , ncols write ( temp_str , style ) array ( i , j ) if ( j < ncols ) then trimmed_str = trimmed_str // trim ( temp_str ) // \", \" else trimmed_str = trimmed_str // trim ( temp_str ) end if end do if ( i < nrows ) then trimmed_str = trimmed_str // \"],\" // new_line ( 'a' ) else trimmed_str = trimmed_str // \"]\" // new_line ( 'a' ) end if end do trimmed_str = trimmed_str // \"]\" end function to_char_matrix_sp end module pic_io","tags":"","url":"sourcefile/pic_io.f90.html"},{"title":"pic_sorting_sort_index.F90 – PIC","text":"This file is subjec† both to the Fortran Standard Library license, and\nto additional licensing requirements as it contains translations of\nother software. The Fortran Standard Library, including this file, is distributed under\nthe MIT license that should be included with the library’s distribution. Copyright (c) 2021 Fortran stdlib developers Permission is hereby granted, free of charge, to any person obtaining a\n  copy of this software and associated documentation files (the\n  “Software”),  to deal in the Software without restriction, including\n  without limitation the rights to use, copy, modify, merge, publish,\n  distribute, sublicense, and/or sellcopies of the Software, and to permit\n  persons to whom the Software is furnished to do so, subject to the\n  following conditions: The above copyright notice and this permission notice shall be included\n  in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND, EXPRESS\n  OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. The generic subroutine, SORT_INDEX , is substantially a translation to\nFortran 2008 of the \"Rust\" sort sorting routines in slice.rs The rust sort implementation is distributed with the header: Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n  file at the top-level directory of this distribution and at\n  http://rust-lang.org/COPYRIGHT. Licensed under the Apache License, Version 2.0 or the MIT license , at your\n  option. This file may not be copied, modified, or distributed\n  except according to those terms. so the license for the original slice.rs code is compatible with the use\nof modified versions of the code in the Fortran Standard Library under\nthe MIT license. This file depends on sourcefile~~pic_sorting_sort_index.f90~~EfferentGraph sourcefile~pic_sorting_sort_index.f90 pic_sorting_sort_index.F90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_sorting_sort_index.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_sorting_sort_index.f90~~AfferentGraph sourcefile~pic_sorting_sort_index.f90 pic_sorting_sort_index.F90 sourcefile~pic_sorting.f90 pic_sorting.f90 sourcefile~pic_sorting.f90->sourcefile~pic_sorting_sort_index.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! !! This file is subjec† both to the Fortran Standard Library license, and !! to additional licensing requirements as it contains translations of !! other software. !! !! The Fortran Standard Library, including this file, is distributed under !! the MIT license that should be included with the library's distribution. !! !!   Copyright (c) 2021 Fortran stdlib developers !! !!   Permission is hereby granted, free of charge, to any person obtaining a !!   copy of this software and associated documentation files (the !!   \"Software\"),  to deal in the Software without restriction, including !!   without limitation the rights to use, copy, modify, merge, publish, !!   distribute, sublicense, and/or sellcopies of the Software, and to permit !!   persons to whom the Software is furnished to do so, subject to the !!   following conditions: !! !!   The above copyright notice and this permission notice shall be included !!   in all copies or substantial portions of the Software. !! !!   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS !!   OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF !!   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. !!   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY !!   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, !!   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE !!   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. !! !! The generic subroutine, `SORT_INDEX`, is substantially a translation to !! Fortran 2008 of the `\"Rust\" sort` sorting routines in !! [`slice.rs`](https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs) !! The `rust sort` implementation is distributed with the header: !! !!   Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT !!   file at the top-level directory of this distribution and at !!   http://rust-lang.org/COPYRIGHT. !! !!   Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or !!   http://www.apache.org/licenses/LICENSE-2.0> or the MIT license !!   <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your !!   option. This file may not be copied, modified, or distributed !!   except according to those terms. !! !! so the license for the original`slice.rs` code is compatible with the use !! of modified versions of the code in the Fortran Standard Library under !! the MIT license. !submodule(pic_sorting) pic_sorting_sort_index module pic_sorting_sort_index use pic_types , only : int32 , int64 , int_index , sp , dp , int_index_low use pic_optional_value , only : pic_optional implicit none public :: sort_index !! The generic subroutine implementing the `SORT_INDEX` algorithm to !! return an index array whose elements would sort the input array in the !! desired direction. It is primarily intended to be used to sort a !! derived type array based on the values of a component of the array. !! Its use has the syntax: !! !!     call sort_index( array, index[, work, iwork, reverse ] ) !! !! with the arguments: !! !! * array: the rank 1 array to be sorted. It is an `intent(inout)` !!   argument of any of the types `integer(int8)`, `integer(int16)`, !!   `integer(int32)`, `integer(int64)`, `real(real32)`, `real(real64)`, !!   `real(real128)`, `character(*)`, `type(string_type)`, !!   `type(bitset_64)`, `type(bitset_large)`. If both the !!   type of `array` is real and at least one of the elements is a `NaN`, !!   then the ordering of the `array` and `index` results is undefined. !!   Otherwise it is defined to be as specified by reverse. !! !! * index: a rank 1 array of sorting indices. It is an `intent(out)` !!   argument of the type `integer(int_index)`. Its size shall be the !!   same as `array`. On return, if defined, its elements would !!   sort the input `array` in the direction specified by `reverse`. !! !! * work (optional): shall be a rank 1 array of the same type as !!   `array`, and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * iwork (optional): shall be a rank 1 integer array of kind `int_index`, !!   and shall have at least `size(array)/2` elements. It is an !!   `intent(out)` argument to be used as \"scratch\" memory !!   for internal record keeping. If associated with an array in static !!   storage, its use can significantly reduce the stack memory requirements !!   for the code. Its value on return is undefined. !! !! * `reverse` (optional): shall be a scalar of type default logical. It !!   is an `intent(in)` argument. If present with a value of `.true.` then !!   `index` will sort `array` in order of non-increasing values in stable !!   order. Otherwise index will sort `array` in order of non-decreasing !!   values in stable order. !! !!#### Examples !! !! Sorting a related rank one array: !! !!```Fortran !!    subroutine sort_related_data( a, b, work, index, iwork ) !!        ! Sort `b` in terms or its related array `a` !!        integer, intent(inout)         :: a(:) !!        integer(int32), intent(inout)  :: b(:) ! The same size as a !!        integer(int32), intent(out)    :: work(:) !!        integer(int_index), intent(out) :: index(:) !!        integer(int_index), intent(out) :: iwork(:) !!    ! Find the indices to sort a !!        call sort_index(a, index(1:size(a)),& !!            work(1:size(a)/2), iwork(1:size(a)/2)) !!    ! Sort b based on the sorting of a !!        b(:) = b( index(1:size(a)) ) !!    end subroutine sort_related_data !!``` !! !! Sorting a rank 2 array based on the data in a column !! !!```Fortran !!    subroutine sort_related_data( array, column, work, index, iwork ) !!    ! Sort `a_data` in terms or its component `a` !!        integer, intent(inout)         :: a(:,:) !!        integer(int32), intent(in)     :: column !!        integer(int32), intent(out)    :: work(:) !!        integer(int_index), intent(out) :: index(:) !!        integer(int_index), intent(out) :: iwork(:) !!        integer, allocatable           :: dummy(:) !!        integer :: i !!        allocate(dummy(size(a, dim=1))) !!    ! Extract a component of `a_data` !!        dummy(:) = a(:, column) !!    ! Find the indices to sort the column !!        call sort_index(dummy, index(1:size(dummy)),& !!                        work(1:size(dummy)/2), iwork(1:size(dummy)/2)) !!    ! Sort a based on the sorting of its column !!        do i=1, size(a, dim=2) !!            a(:, i) = a(index(1:size(a, dim=1)), i) !!        end do !!    end subroutine sort_related_data !!``` !! !! Sorting an array of a derived type based on the dsta in one component !!```fortran !!    subroutine sort_a_data( a_data, a, work, index, iwork ) !!    ! Sort `a_data` in terms or its component `a` !!        type(a_type), intent(inout)    :: a_data(:) !!        integer(int32), intent(inout)  :: a(:) !!        integer(int32), intent(out)    :: work(:) !!        integer(int_index), intent(out) :: index(:) !!        integer(int_index), intent(out) :: iwork(:) !!    ! Extract a component of `a_data` !!        a(1:size(a_data)) = a_data(:) % a !!    ! Find the indices to sort the component !!        call sort_index(a(1:size(a_data)), index(1:size(a_data)),& !!                        work(1:size(a_data)/2), iwork(1:size(a_data)/2)) !!    ! Sort a_data based on the sorting of that component !!        a_data(:) = a_data( index(1:size(a_data)) ) !!    end subroutine sort_a_data !!``` private integer , parameter :: & ! The maximum number of entries in a run stack, good for an array of ! 2**64 elements see ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt max_merge_stack = int ( ceiling ( log ( 2._dp ** 64 ) / & log ( 1.6180339887_dp ))) type run_type !! Used to pass state around in a stack among helper functions for the !! `ORD_SORT` and `SORT_INDEX` algorithms integer ( int_index ) :: base = 0 integer ( int_index ) :: len = 0 end type run_type interface sort_index !! The generic subroutine interface implementing the `SORT_INDEX` algorithm, !! based on the `\"Rust\" sort` algorithm found in `slice.rs` !! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 !! but modified to return an array of indices that would provide a stable !! sort of the rank one `ARRAY` input. !! !! The indices by default correspond to a !! non-decreasing sort, but if the optional argument `REVERSE` is present !! with a value of `.TRUE.` the indices correspond to a non-increasing sort. module subroutine int32_sort_index_default ( array , index , work , iwork , & reverse ) !! `int32_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort_index_default module subroutine int64_sort_index_default ( array , index , work , iwork , & reverse ) !! `int64_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort_index_default module subroutine sp_sort_index_default ( array , index , work , iwork , & reverse ) !! `sp_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort_index_default module subroutine dp_sort_index_default ( array , index , work , iwork , & reverse ) !! `dp_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort_index_default module subroutine char_sort_index_default ( array , index , work , iwork , & reverse ) !! `char_sort_index_default( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort_index_default module subroutine int32_sort_index_low ( array , index , work , iwork , & reverse ) !! `int32_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int32)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int32_sort_index_low module subroutine int64_sort_index_low ( array , index , work , iwork , & reverse ) !! `int64_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `integer(int64)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine int64_sort_index_low module subroutine sp_sort_index_low ( array , index , work , iwork , & reverse ) !! `sp_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(sp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine sp_sort_index_low module subroutine dp_sort_index_low ( array , index , work , iwork , & reverse ) !! `dp_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `real(dp)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine dp_sort_index_low module subroutine char_sort_index_low ( array , index , work , iwork , & reverse ) !! `char_sort_index_low( array, index[, work, iwork, reverse] )` sorts !! an input `ARRAY` of type `character(len=*)` !! using a hybrid sort based on the `\"Rust\" sort` algorithm found in `slice.rs` !! and returns the sorted `ARRAY` and an array `INDEX` of indices in the !! order that would sort the input `ARRAY` in the desired direction. implicit none character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse end subroutine char_sort_index_low end interface sort_index contains module subroutine int32_sort_index_default ( array , index , work , iwork , reverse ) ! A modification of `int32_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int32 ), allocatable :: buf (:) integer ( int_index ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat stat = 0 array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index ) :: key_index integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i integer ( int_index ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: itemp integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_sort_index_default module subroutine int64_sort_index_default ( array , index , work , iwork , reverse ) ! A modification of `int64_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int64 ), allocatable :: buf (:) integer ( int_index ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index ) :: key_index integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i integer ( int_index ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: itemp integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_sort_index_default module subroutine sp_sort_index_default ( array , index , work , iwork , reverse ) ! A modification of `sp_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse real ( sp ), allocatable :: buf (:) integer ( int_index ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index ) :: key_index real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i integer ( int_index ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: itemp integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_sort_index_default module subroutine dp_sort_index_default ( array , index , work , iwork , reverse ) ! A modification of `dp_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse real ( dp ), allocatable :: buf (:) integer ( int_index ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index ) :: key_index real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i integer ( int_index ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: itemp integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_sort_index_default module subroutine char_sort_index_default ( array , index , work , iwork , reverse ) ! A modification of `char_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int_index ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat stat = 0_int_index array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else block character ( len = :), allocatable :: buf (:) allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) #ifdef __NVCOMPILER_LLVM__ #else if ( stat /= 0 ) then error stop \"Allocation of array failed\" end if #endif if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end block end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index ) :: key_index character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i integer ( int_index ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: itemp integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_sort_index_default module subroutine int32_sort_index_low ( array , index , work , iwork , reverse ) ! A modification of `int32_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int32 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int32 ), allocatable :: buf (:) integer ( int_index_low ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index_low ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index_low ) :: key_index integer ( int32 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int32 ) :: tmp integer ( int_index ) :: i integer ( int_index_low ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int32 ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place integer ( int32 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ) :: itemp integer ( int_index ) :: lo , hi integer ( int32 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int32_sort_index_low module subroutine int64_sort_index_low ( array , index , work , iwork , reverse ) ! A modification of `int64_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) integer ( int64 ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int64 ), allocatable :: buf (:) integer ( int_index_low ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index_low ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index_low ) :: key_index integer ( int64 ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int64 ) :: tmp integer ( int_index ) :: i integer ( int_index_low ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid integer ( int64 ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place integer ( int64 ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ) :: itemp integer ( int_index ) :: lo , hi integer ( int64 ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine int64_sort_index_low module subroutine sp_sort_index_low ( array , index , work , iwork , reverse ) ! A modification of `sp_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( sp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse real ( sp ), allocatable :: buf (:) integer ( int_index_low ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index_low ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index_low ) :: key_index real ( sp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) real ( sp ) :: tmp integer ( int_index ) :: i integer ( int_index_low ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( sp ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place real ( sp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ) :: itemp integer ( int_index ) :: lo , hi real ( sp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine sp_sort_index_low module subroutine dp_sort_index_low ( array , index , work , iwork , reverse ) ! A modification of `dp_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) real ( dp ), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse real ( dp ), allocatable :: buf (:) integer ( int_index_low ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index_low ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else allocate ( buf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of array buffer failed.\" if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index_low ) :: key_index real ( dp ) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) real ( dp ) :: tmp integer ( int_index ) :: i integer ( int_index_low ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid real ( dp ), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place real ( dp ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ) :: itemp integer ( int_index ) :: lo , hi real ( dp ) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine dp_sort_index_low module subroutine char_sort_index_low ( array , index , work , iwork , reverse ) ! A modification of `char_ord_sort` to return an array of indices that ! would perform a stable sort of the `ARRAY` as input, and also sort `ARRAY` ! as desired. The indices by default ! correspond to a non-decreasing sort, but if the optional argument ! `REVERSE` is present with a value of `.TRUE.` the indices correspond to ! a non-increasing sort. The logic of the determination of indexing largely ! follows the `\"Rust\" sort` found in `slice.rs`: ! https://github.com/rust-lang/rust/blob/90eb44a5897c39e3dff9c7e48e3973671dcd9496/src/liballoc/slice.rs#L2159 ! The Rust version in turn is a simplification of the Timsort algorithm ! described in ! https://svn.python.org/projects/python/trunk/Objects/listsort.txt, as ! it drops both the use of 'galloping' to identify bounds of regions to be ! sorted and the estimation of the optimal `run size`. However it remains ! a hybrid sorting algorithm combining an iterative Merge sort controlled ! by a stack of `RUNS` identified by regions of uniformly decreasing or ! non-decreasing sequences that may be expanded to a minimum run size and ! initially processed by an insertion sort. ! ! Note the Fortran implementation simplifies the logic as it only has to ! deal with Fortran arrays of intrinsic types and not the full generality ! of Rust's arrays and lists for arbitrary types. It also adds the ! estimation of the optimal `run size` as suggested in Tim Peters' ! original `listsort.txt`, and the optional `work` and `iwork` arrays to be ! used as scratch memory. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( out ) :: index ( 0 :) character ( len = len ( array )), intent ( out ), optional :: work ( 0 :) integer ( int_index_low ), intent ( out ), optional :: iwork ( 0 :) logical , intent ( in ), optional :: reverse integer ( int_index_low ), allocatable :: ibuf (:) integer ( int_index ) :: array_size , i , stat stat = 0_int_index array_size = size ( array , kind = int_index ) if ( array_size > huge ( index )) then error stop \"Too many entries for the kind of index.\" end if if ( array_size > size ( index , kind = int_index )) then error stop \"Too many entries for the size of index.\" end if do i = 0 , array_size - 1 index ( i ) = int ( i + 1 , kind = int_index_low ) end do if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if ! If necessary allocate buffers to serve as scratch memory. if ( present ( work )) then if ( size ( work , kind = int_index ) < array_size / 2 ) then error stop \"work array is too small.\" end if if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , work , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , work , ibuf ) end if else block character ( len = :), allocatable :: buf (:) allocate ( character ( len = len ( array )) :: buf ( 0 : array_size / 2 - 1 ), & stat = stat ) #ifdef __NVCOMPILER_LLVM__ #else if ( stat /= 0 ) then error stop \"Allocation of array failed\" end if #endif if ( present ( iwork )) then if ( size ( iwork , kind = int_index ) < array_size / 2 ) then error stop \"iwork array is too small.\" end if call merge_sort ( array , index , buf , iwork ) else allocate ( ibuf ( 0 : array_size / 2 - 1 ), stat = stat ) if ( stat /= 0 ) error stop \"Allocation of index buffer failed.\" call merge_sort ( array , index , buf , ibuf ) end if end block end if if ( pic_optional ( reverse , . false .)) then call reverse_segment ( array , index ) end if contains pure function calc_min_run ( n ) result ( min_run ) !! Returns the minimum length of a run from 32-63 so that N/MIN_RUN is !! less than or equal to a power of two. See !! https://svn.python.org/projects/python/trunk/Objects/listsort.txt integer ( int_index ) :: min_run integer ( int_index ), intent ( in ) :: n integer ( int_index ) :: num , r num = n r = 0_int_index do while ( num >= 64 ) r = ior ( r , iand ( num , 1_int_index )) num = ishft ( num , - 1_int_index ) end do min_run = num + r end function calc_min_run pure subroutine insertion_sort ( array , index ) ! Sorts `ARRAY` using an insertion sort, while maintaining consistency in ! location of the indices in `INDEX` to the elements of `ARRAY`. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index ) :: i , j integer ( int_index_low ) :: key_index character ( len = len ( array )) :: key do j = 1 , size ( array , kind = int_index ) - 1 key = array ( j ) key_index = index ( j ) i = j - 1 do while ( i >= 0 ) if ( array ( i ) <= key ) exit array ( i + 1 ) = array ( i ) index ( i + 1 ) = index ( i ) i = i - 1 end do array ( i + 1 ) = key index ( i + 1 ) = key_index end do end subroutine insertion_sort pure function collapse ( runs ) result ( r ) ! Examine the stack of runs waiting to be merged, identifying adjacent runs ! to be merged until the stack invariants are restablished: ! ! 1. len(-3) > len(-2) + len(-1) ! 2. len(-2) > len(-1) integer ( int_index ) :: r type ( run_type ), intent ( in ), target :: runs ( 0 :) integer ( int_index ) :: n logical :: test n = size ( runs , kind = int_index ) test = . false . if ( n >= 2 ) then if ( runs ( n - 1 )% base == 0 . or . & runs ( n - 2 )% len <= runs ( n - 1 )% len ) then test = . true . else if ( n >= 3 ) then ! X exists if ( runs ( n - 3 )% len <= & runs ( n - 2 )% len + runs ( n - 1 )% len ) then test = . true . !               |X| <= |Y| + |Z| => will need to merge due to rho1 or rho2 else if ( n >= 4 ) then if ( runs ( n - 4 )% len <= & runs ( n - 3 )% len + runs ( n - 2 )% len ) then test = . true . !               |W| <= |X| + |Y| => will need to merge due to rho1 or rho3 end if end if end if end if if ( test ) then ! By default merge Y & Z, rho2 or rho3 if ( n >= 3 ) then if ( runs ( n - 3 )% len < runs ( n - 1 )% len ) then r = n - 3 ! |X| < |Z| => merge X & Y, rho1 return end if end if r = n - 2 ! |Y| <= |Z| => merge Y & Z, rho4 return else r = - 1 end if end function collapse pure subroutine insert_head ( array , index ) ! Inserts `array(0)` into the pre-sorted sequence `array(1:)` so that the ! whole `array(0:)` becomes sorted, copying the first element into ! a temporary variable, iterating until the right place for it is found. ! copying every traversed element into the slot preceding it, and finally, ! copying data from the temporary variable into the resulting hole. ! Consistency of the indices in `index` with the elements of `array` ! are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )) :: tmp integer ( int_index ) :: i integer ( int_index_low ) :: tmp_index tmp = array ( 0 ) tmp_index = index ( 0 ) find_hole : do i = 1 , size ( array , kind = int_index ) - 1 if ( array ( i ) >= tmp ) exit find_hole array ( i - 1 ) = array ( i ) index ( i - 1 ) = index ( i ) end do find_hole array ( i - 1 ) = tmp index ( i - 1 ) = tmp_index end subroutine insert_head subroutine merge_sort ( array , index , buf , ibuf ) ! The Rust merge sort borrows some (but not all) of the ideas from TimSort, ! which is described in detail at ! (http://svn.python.org/projects/python/trunk/Objects/listsort.txt). ! ! The algorithm identifies strictly descending and non-descending ! subsequences, which are called natural runs. Where these runs are less ! than a minimum run size they are padded by adding additional samples ! using an insertion sort. The merge process is driven by a stack of ! pending unmerged runs. Each newly found run is pushed onto the stack, ! and then pairs of adjacentd runs are merged until these two invariants ! are satisfied: ! ! 1. for every `i` in `1..size(runs)-1`: `runs(i - 1)%len > runs(i)%len` ! 2. for every `i` in `2..size(runs)-1`: `runs(i - 2)%len > !    runs(i - 1)%len + runs(i)%len` ! ! The invariants ensure that the total running time is `O(n log n)` ! worst-case. Consistency of the indices in `index` with the elements of ! `array` are maintained. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_size , finish , min_run , r , r_count , & start type ( run_type ) :: runs ( 0 : max_merge_stack - 1 ), left , right array_size = size ( array , kind = int_index ) ! Very short runs are extended using insertion sort to span at least this ! many elements. Slices of up to this length are sorted using insertion sort. min_run = calc_min_run ( array_size ) if ( array_size <= min_run ) then if ( array_size >= 2 ) call insertion_sort ( array , index ) return end if ! Following Rust sort, natural runs in `array` are identified by traversing ! it backwards. By traversing it backward, merges more often go in the ! opposite direction (forwards). According to developers of Rust sort, ! merging forwards is slightly faster than merging backwards. Therefore ! identifying runs by traversing backwards should improve performance. r_count = 0 finish = array_size - 1 do while ( finish >= 0 ) ! Find the next natural run, and reverse it if it's strictly descending. start = finish if ( start > 0 ) then start = start - 1 if ( array ( start + 1 ) < array ( start )) then Descending : do while ( start > 0 ) if ( array ( start ) >= array ( start - 1 )) & exit Descending start = start - 1 end do Descending call reverse_segment ( array ( start : finish ), & index ( start : finish )) else Ascending : do while ( start > 0 ) if ( array ( start ) < array ( start - 1 )) exit Ascending start = start - 1 end do Ascending end if end if ! If the run is too short insert some more elements using an insertion sort. Insert : do while ( start > 0 ) if ( finish - start >= min_run - 1 ) exit Insert start = start - 1 call insert_head ( array ( start : finish ), index ( start : finish )) end do Insert if ( start == 0 . and . finish == array_size - 1 ) return runs ( r_count ) = run_type ( base = start , & len = finish - start + 1 ) finish = start - 1 r_count = r_count + 1 ! Determine whether pairs of adjacent runs need to be merged to satisfy ! the invariants, and, if so, merge them. Merge_loop : do r = collapse ( runs ( 0 : r_count - 1 )) if ( r < 0 . or . r_count <= 1 ) exit Merge_loop left = runs ( r + 1 ) right = runs ( r ) call merge ( array ( left % base : & right % base + right % len - 1 ), & left % len , buf , & index ( left % base : & right % base + right % len - 1 ), ibuf ) runs ( r ) = run_type ( base = left % base , & len = left % len + right % len ) if ( r == r_count - 3 ) runs ( r + 1 ) = runs ( r + 2 ) r_count = r_count - 1 end do Merge_loop end do if ( r_count /= 1 ) & error stop \"MERGE_SORT completed without RUN COUNT == 1.\" end subroutine merge_sort pure subroutine merge ( array , mid , buf , index , ibuf ) ! Merges the two non-decreasing runs `ARRAY(0:MID-1)` and `ARRAY(MID:)` ! using `BUF` as temporary storage, and stores the merged runs into ! `ARRAY(0:)`. `MID` must be > 0, and < `SIZE(ARRAY)-1`. Buffer `BUF` ! must be long enough to hold the shorter of the two runs. character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index ), intent ( in ) :: mid character ( len = len ( array )), intent ( inout ) :: buf ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ), intent ( inout ) :: ibuf ( 0 :) integer ( int_index ) :: array_len , i , j , k array_len = size ( array , kind = int_index ) ! Merge first copies the shorter run into `buf`. Then, depending on which ! run was shorter, it traces the copied run and the longer run forwards ! (or backwards), comparing their next unprocessed elements and then ! copying the lesser (or greater) one into `array`. if ( mid <= array_len - mid ) then ! The left run is shorter. buf ( 0 : mid - 1 ) = array ( 0 : mid - 1 ) ibuf ( 0 : mid - 1 ) = index ( 0 : mid - 1 ) i = 0 j = mid merge_lower : do k = 0 , array_len - 1 if ( buf ( i ) <= array ( j )) then array ( k ) = buf ( i ) index ( k ) = ibuf ( i ) i = i + 1 if ( i >= mid ) exit merge_lower else array ( k ) = array ( j ) index ( k ) = index ( j ) j = j + 1 if ( j >= array_len ) then array ( k + 1 :) = buf ( i : mid - 1 ) index ( k + 1 :) = ibuf ( i : mid - 1 ) exit merge_lower end if end if end do merge_lower else ! The right run is shorter buf ( 0 : array_len - mid - 1 ) = array ( mid : array_len - 1 ) ibuf ( 0 : array_len - mid - 1 ) = index ( mid : array_len - 1 ) i = mid - 1 j = array_len - mid - 1 merge_upper : do k = array_len - 1 , 0 , - 1 if ( buf ( j ) >= array ( i )) then array ( k ) = buf ( j ) index ( k ) = ibuf ( j ) j = j - 1 if ( j < 0 ) exit merge_upper else array ( k ) = array ( i ) index ( k ) = index ( i ) i = i - 1 if ( i < 0 ) then array ( 0 : k - 1 ) = buf ( 0 : j ) index ( 0 : k - 1 ) = ibuf ( 0 : j ) exit merge_upper end if end if end do merge_upper end if end subroutine merge pure subroutine reverse_segment ( array , index ) ! Reverse a segment of an array in place character ( len =* ), intent ( inout ) :: array ( 0 :) integer ( int_index_low ), intent ( inout ) :: index ( 0 :) integer ( int_index_low ) :: itemp integer ( int_index ) :: lo , hi character ( len = len ( array )) :: temp lo = 0 hi = size ( array , kind = int_index ) - 1 do while ( lo < hi ) temp = array ( lo ) array ( lo ) = array ( hi ) array ( hi ) = temp itemp = index ( lo ) index ( lo ) = index ( hi ) index ( hi ) = itemp lo = lo + 1 hi = hi - 1 end do end subroutine reverse_segment end subroutine char_sort_index_low !end submodule pic_sorting_sort_index end module pic_sorting_sort_index","tags":"","url":"sourcefile/pic_sorting_sort_index.f90.html"},{"title":"pic_string_type_constructor.f90 – PIC","text":"This file depends on sourcefile~~pic_string_type_constructor.f90~~EfferentGraph sourcefile~pic_string_type_constructor.f90 pic_string_type_constructor.f90 sourcefile~pic_string_type.f90 pic_string_type.F90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings.f90 pic_strings.f90 sourcefile~pic_string_type_constructor.f90->sourcefile~pic_strings.f90 sourcefile~pic_ascii.f90 pic_ascii.f90 sourcefile~pic_string_type.f90->sourcefile~pic_ascii.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_string_type.f90->sourcefile~pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_string_type.f90->sourcefile~pic_types.f90 sourcefile~pic_strings.f90->sourcefile~pic_string_type.f90 sourcefile~pic_strings.f90->sourcefile~pic_ascii.f90 sourcefile~pic_strings.f90->sourcefile~pic_optional.f90 sourcefile~pic_strings.f90->sourcefile~pic_types.f90 sourcefile~pic_ascii.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code submodule ( pic_string_type ) pic_string_type_constructor use pic_strings , only : to_string implicit none contains !> Constructor for new string instances from a scalar character value. elemental module function new_string ( string ) result ( new ) character ( len =* ), intent ( in ), optional :: string type ( string_type ) :: new if ( present ( string )) then new % raw = string end if end function new_string !> Constructor for new string instances from an integer of kind int32. elemental module function new_string_from_integer_int32 ( val ) result ( new ) integer ( int32 ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_integer_int32 !> Constructor for new string instances from an integer of kind int64. elemental module function new_string_from_integer_int64 ( val ) result ( new ) integer ( int64 ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_integer_int64 !> Constructor for new string instances from a logical of kind fbool. elemental module function new_string_from_logical_fbool ( val ) result ( new ) logical ( fbool ), intent ( in ) :: val type ( string_type ) :: new new % raw = to_string ( val ) end function new_string_from_logical_fbool end submodule pic_string_type_constructor","tags":"","url":"sourcefile/pic_string_type_constructor.f90.html"},{"title":"pic.f90 – PIC","text":"the main pic module interface: versions, banners, random quotes etc will go here Source Code !! the main pic module interface: versions, banners, random quotes etc will go here module pic !! simple interface module that prints banner and other information about the library !! mostly here to verify installs, etc. !use, intrinsic :: iso_fortran_env, only: compiler_version !use, intrinsic :: iso_fortran_env, only : compiler_options implicit none private public :: pic_print_banner contains subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" !print '(4a)', & !   '   PIC compiled with ', & !   compiler_version() !print '(4a)', ' using the options ',        & !  compiler_options() end subroutine pic_print_banner end module pic","tags":"","url":"sourcefile/pic.f90.html"},{"title":"pic_timer.F90 – PIC","text":"timing routines in general This file depends on sourcefile~~pic_timer.f90~~EfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_io.f90 pic_io.f90 sourcefile~pic_timer.f90->sourcefile~pic_io.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_io.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_timer.f90~~AfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! timing routines in general module pic_timer !! contains a simple timer module to measure and record time use pic_types , only : dp , default_int use pic_io , only : to_char #ifdef _OPENMP use omp_lib , only : omp_get_wtime #endif implicit none private public :: timer_type type :: timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp. If PIC is compiled with OpenMP the default !! timer will be the omp time. This is mostly to minimize problems with threading !! and system clock private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure , non_overridable :: start => timer_start procedure , non_overridable :: stop => timer_stop procedure , non_overridable :: print_time => timer_print_time procedure , non_overridable :: get_elapsed_time => timer_get_elapsed_time end type timer_type contains subroutine timer_start ( self ) !! starts the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%start() !! !! Usage assumes a declaration of type(timer_type) :: my_timer class ( timer_type ), intent ( inout ) :: self self % is_running = . true . #ifdef _OPENMP self % start_time = omp_get_wtime () #else call system_clock ( self % start_count , self % count_rate ) #endif end subroutine timer_start subroutine timer_stop ( self ) !! stop the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%stop() !! !! Usage assumes a declaration of type(timer_type) :: my_timer !! will fail if a timer has not been started! class ( timer_type ), intent ( inout ) :: self if (. not . self % is_running ) then error stop \"Cannot stop a timer that has not been started!\" end if #ifdef _OPENMP self % stop_time = omp_get_wtime () #else call system_clock ( self % stop_count ) #endif ! if someone stops the timer, we stop ! self % is_running = . false . end subroutine timer_stop subroutine timer_print_time ( self ) !! Prints the elapsed time at the time of calling !! !! Usage: call my_timer%print_time() !! !! Needs my_timer to be declared previously as type(timer_type) :: my_timer !! !! This function does not stop the timer, it will get the current time elapsed stopped or not class ( timer_type ), intent ( in ) :: self real ( dp ) :: elapsed elapsed = self % get_elapsed_time () if ( self % is_running ) then print * , \"Currently elapsed time: \" // to_char ( elapsed ) // \" seconds\" else print * , \"Elapsed time: \" // to_char ( elapsed ) // \" seconds\" end if end subroutine timer_print_time function timer_get_elapsed_time ( self ) result ( elapsed ) !! Returns the elapsed time as a real(dp) variable !! !! Usage: var = my_timer%get_elapsed_time() !! !! Needs my_timer to be declared previously as type(timer_type) :: my_timer !! class ( timer_type ), intent ( in ) :: self real ( dp ) :: elapsed integer ( default_int ) :: current_count elapsed = 0.0_dp #ifdef _OPENMP if ( self % is_running ) then elapsed = omp_get_wtime () - self % start_time else elapsed = self % stop_time - self % start_time end if #else if ( self % is_running ) then call system_clock ( count = current_count ) elapsed = real ( current_count - self % start_count , dp ) / real ( self % count_rate , dp ) else elapsed = real ( self % stop_count - self % start_count , dp ) / real ( self % count_rate , dp ) end if #endif end function timer_get_elapsed_time end module pic_timer","tags":"","url":"sourcefile/pic_timer.f90.html"},{"title":"About PIC – PIC","text":"Reasoning behind PIC In my relatively short career as a programmer I have used multiple languages: C, C++, Python, Julia, Bash, and of course, Fortran. During this time I have explored multiple avenues within each of the languages and have written quite a bit of code in most of them. Probably\nthe one I’ve written the most code in is C++, since I was one of the main contributors the GAMESS-ECP project that saw the\ncreation of GMS-HPC and the initial lines of code of what would become EXESS. While I was a postdoc at the Barca group I had the joy of meeting some of the best computer scientists I’ve ever met. I quickly realized\nthat I was John Snow, I didn’t know anything. It was the first time that I had the opportunity to colaborate closely with people that were trained in computer science and software engineering. Before that I lived in the academic programming world, which is mostly a “WRITE CODE, PUBLISH PAPER, GET GRANT” type of mindset. If a code\nworks, nice, you go ahead and publish a paper on it. Is the code good? Most of the times the answer to this is: no. I was fortunate enough to be a part of the rewriting of the EXESS codebase. Lead by, hopefully soon to be, Dr. Ryan Stocks we rewrote\nthe entire thing using some very cool features of the C++ language and tightly coupled it with MPI, CUDA/HIP, and ran some of the largest and and most performant simulations ever done. We even won a Gordon Bell prize in 2024 because of this ! In the end this was a gigantic team effort which wouldn’t have been possible without the contributions done by the entire team and the money provided by Dr Barca’s company QDX. Without this it would have been impossible to rewrite the entire code the way we did. After leaving my position as a postdoc at the Barca group I joined the National Computational Infrastructure (NCI) in Canberra where\nI could put to use all of my HPC and software engineering knowledge to test in other domains outside of computational quanutm chemistry. In my last year or so of my postdoc I took up a big interest in the Fortran programming language . I had used it before during my undergrad and early PhD but the ECP project had pushed me to full C++ and CUDA for GPU support. I discovered the beautiful community that is the Fortran Discourse and the associated projects people associated to it have undertaken. Examples are the Fortran Package Manager , the Fortran Standard Library and the LFortran compiler. I found a community of people that I hadn’t found in the C/C++ world and this drove me to start exploring the language a bit more. Why Fortran Fortran is an old language and with age comes lots of baggage. A lot of Fortran’s perceived baggage is due to legacy codes that use\nold language constructs that are no longer in the standard or just simply bad academic code. I somehow dislike the idea of the existence of Modern Fortran, but since there is also Modern C++ I wonder if my dislike is not reasonble. Modern Fortran or from now on just “Fortran” is whatever the language became since the release of Fortran 90 and beyond. People usually associate Fortran with code that looks like: PROGRAM MAIN IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) REAL * 8 HTY , FTY , HUY , RUY CALL MTRBR ( ABC , BAC , CDF , EFG , DFGE , ASY ) IF ( VAR . EQ . TRUE ) THEN GOTO 500 ENDIF ... 500 PRINT * , \"YOU FOOL!\" END PROGRAM MAIN The ugly all caps; undescriptive, short variable names; the use of GOTO statements, and of course, the code starting in the 7 column. There is a lot of code that looks like this yes, however, new Fortran does not look like this at all. This is the famed transition\nfrom fixed to free format Fortran which lets one write code in whichever column you want to write. New Fortran looks quite differnt and I’d dare even say similar to other language, like Julia maybe. For example, this snippet of code from PIC itself: subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int64 There is nothing “ugly” to look at here. Everything is nice lower caps with nice spacing. Variable names mean something\nto anyone that can speak english and I even showcase the use of OMP parallelism. One thing that you might comment on here “Oh, ew, you have to declare everything at the start like in C89”. And yeah,\nI see that comment a lot. HOWEVER. This is not the case anymore. I just did it like this here because the subroutine is rather small. Fortran has introduced the concept of blocks which are used to determine scope in a program, very similar to the {} in C/C++. For example, the above code could be rewritten as: subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then loop : block integer ( default_int ) :: i !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do end block loop else vector = alpha end if end subroutine fill_vector_int64 And now we’ve limited the scope of the i variable in the program. Blocks can be named or also omitted. I.e. you could ommit the name loop: and you’d still be fine. You can nest blocks in blocks, they just delimit the scope of variables. Now you might wonder, why do I need to say what size of int ? why am I using a default_int size for my integer. Well, this is one of\nthe things in PIC that had to be done in order for the code to be interfaceable with legacy Fortran applications. You see, in the old days, codes that wanted to use int64 or double precision , i.e. fp64 , had to use something similar to real(8) :: my_var this meant the number of bits used to represent the variable. People back then were lazy and the computers\ndid not help for this. You could tell the compiler to make all integer or real variables a default of int64 and double precision . This way all of your integers and reals would always be the precision you wanted them to be. This is unsurprisingly a very bad design decision. This makes it such that if any code wants to interface with your code the sizes of integers and reals need to match. This becomes\nextraordinarily painful if interfacing with C/C++ codes. Therefore, to avoid using this compiler flags I’ve set up PIC so that the default integer size can be toggled at compile time from within the program itself - not via the compiler. But I am getting distracted now. Why Fortran? Well one: out of spite. The C++ people seem to believe that you cannot achieve the same level and portability as a C++ code can. I\ndon’t believe this but I cannot just say it, I need to show it. I believe that Fortran can provide an easy entrance and avenue to High Performance Scientific Computing without having to be bogged\ndown by all of the program design choices that need to be taken if a code is written in C++. In the end, it is all code. Certain things are easier in Fortran, certain things are easier in C++. I’d argue that it is easier for\nscientists, who have little time to think about “How to write good code”, to write decent code in Fortran than in C++. C++ is an extremely powerful language, beyond my comprehension; however, the language is vast, a never ending horizon without mountains in sight. There is simply too much and for newcomers this is overwhelming. I experienced it and continue to do so, even after 8 years of programming in C++. Fortran is also extremely powerful - but also, not so vast as C++. This is due to the lack of standard library that is distributed with every compiler. Fortran is making a Standard Library but it is in its early stages. This is also a pain point in Fortran. There are many things in the standard library that are just good and make many tasks simple. The idea of the #include <iostream> and you get extremely powerful I/O capabilities. Also std::vector , #include <algorithm> etc. they provide a developer with very well built implementations of very simple (mundane tasks). For example, in Fortran there is no sort function that provides similar functionality to the ones in C++. The Fortran standard library is aiming to fix this, and they are working on it right now. However, there are many other functionalities that need to be covered and implemented for all types of programs. This is what drove me\nto create PIC. PIC is intended to be a set of functions and subroutines that facilitate developing code aimed for High Performance Computing for Scientific Applications. For example, weather simulations, finite element methods, computational quanutm chemistry, molecular dynamics, etc. The idea of PIC is to provide seamless interfaces to MPI, BLAS to allow people to think about their science instead of the code. The aim is to maybe “look pythonic in nature”, but probably closer to Julia. For example, being able to do call pic_gemm(A,B,C) and have PIC decide the bounds of the arrays and if the operations happens on the CPU or the GPU. PIC aims to provide a stable development platform for people that want to write high performance code for modern hardware architectures. However, the main goal of PIC is to provide portable code. Since, we all know the pain of imperfect Fortran compilers, PIC aims to compile and pass all tests across many compilers found in the literature. This is what drove me to implement my own versions of the sort functions from the standard library - they did not work with the NVIDIA or Cray compilers.","tags":"","url":"page/index.html"},{"title":"Contributing – PIC","text":"Contributing to PIC All contributions to PIC are welcome! If you have an idea for a new feature, a bug fix, or an improvement, please open an issue or submit a pull request. PIC is an open source project licensed under the MIT License, so you can use it in your own projects without any restrictions. If you use PIC in your project and your wrote a paper with it, please consider citing it by including a link to the repository in your paper. All code that you contribute to PIC will be licensed under the MIT license, so please make sure that you are comfortable with this before submitting your changes. How to contribute The following guidelines will help you contribute effectively: Fork the repository : Create your own fork of the PIC repository on GitHub. Create a new branch : Always create a new branch for your changes. This keeps your work organized and makes it easier to manage pull requests. I don’t really care about the branch name, but I suggest you abide by [type]/[description] format; where type is one of feat , fix , docs , chore , and experiment . Write tests : If you are adding new features or fixing bugs, please include tests to ensure that your changes work as expected. Follow the coding style : Please adhere to the coding style used in the project. This includes naming conventions, indentation, and commenting. Document your changes : Update the documentation to reflect any changes you make. This includes updating the README, comments in the code, and any relevant documentation files. Run tests : Before submitting your changes, make sure to run the tests to ensure that everything works as expected. The CI should catch any compiler issues. Submit a pull request : Once you have made your changes and tested them, submit a pull request to the main repository. Provide a clear description of your changes and why they are needed. The most important thing in the code is that we are aiming to support int32 and int64 as the default integer types. This is why\nwe use the default_int parameter in the pic_types.F90 module. When you are writing new code, please ensure that it is compatible with both integer types by always using integer(default_int) instead of integer or integer(kind=4) or integer(kind=8) . On the use of LLMs, AI thingies, etc. I do not care. As long as your code is tested, works, and is well documented I could not care less if you used an AI to write it. Can I copy paste code from PIC into ChatGPT, Claude, or whatever AI I use? Yes, you can. I don’t care. I do not consider this plagiarism, since the code is open source and you are free to use it as you wish. Documenting your code We use Ford to generate the documentation. The idea is to have coverage of almost every function in the code, except those that\ncan be self explanatory or if they are module procedure inside an interface block. For example: interface fill !! fill provides a generic interface to assing a value !! alpha of types ( int32 , int64 , sp , dp ) as defined in pic_types . F90 !! The inteface supports filling 1 d and 2 d arrays of the specified !! variables !! !! Usage : call fill ( array , value , [ optional ] threaded ) !! !! This subroutine is threaded for performance purposes if threaded is set to . true . !! module procedure fill_vector_int32 module procedure fill_vector_int64 module procedure fill_vector_sp module procedure fill_vector_dp module procedure fill_matrix_int32 module procedure fill_matrix_int64 module procedure fill_matrix_sp module procedure fill_matrix_dp end interface There’s really no need to go document each fill_vector_* or fill_matrix_* procedure, since the interface already provides\neverything we need to know about the procedures within the fill interface. Documenting each of these would mean to just\nwrite fills a vector of type int32 with the value alpha, uses threads if enabled which is redundant and not really useful. Code style We mostly follow the best practices outlined in the Fortran Best Practices guide. We have a pre-commit hook that will run fprettify to format the code before committing, this will ensure that the formatting is consistent across the codebase. To install pre-commit do: python3 -m pip install pre-commit\npre-commit install You can also run pre-commit run --all-files to format all the files in the repository. Module naming convention All our of modules are named using the pic_ prefix, followed by the name of the module. For example, the module that provides the basic types is called pic_types , and the module that provides the BLAS functionality is called pic_blas_interfaces . MOst of the time the module name matches the name of the file, if you find an instance where this is not the case, please open an issue or submit a pull request to fix it. Based on the file = module_name convention, there should only be one module per file. We follow the convention that the end module statement should contain the name of the module. Derived type naming convention All derived types should be named using the pic_ prefix, followed by the name of the type. For example, the type that represents a vector is called pic_vector_type , and the type that represents a matrix is called pic_matrix_type . Function and subroutine naming convention I really don’t care about naming conventions for functions or subroutines, I only suggest that you make the name descriptive and meaningful. Also,\nusing interfaces to hide the name of the subroutine inside the module is a good practice, since it allows you to change the implementation without affecting the users of the module. For example, in pic_timer.F90 we have the following interface: type :: pic_timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time end type pic_timer_type You can see that the start procedure is mapped to timer_start , this way it is more intuitive for people to use my_timer%start() instead of my_timer%timer_start() . This is a good practice to follow, since it makes the code more readable and easier to use. We follow the same convention for functions and subroutines, as we do for modules. This is, the end function or end subroutine statement should contain the name of the function or subroutine. Code reviews Code reviews are an essential part of the contribution process. When you submit a pull request, it will be reviewed by the maintainers of the project. They will provide feedback on your code, suggest improvements, and ensure that it meets the project’s standards. Please be open to feedback and willing to make changes to your code based on the review. The goal is to improve the quality of the code and ensure that it is maintainable in the long run. If you are new to contributing to open source projects, don’t be discouraged by the review process. It is a learning experience, and the maintainers are here to help you improve your code and understand the project better. If you feel connected to the project and want to help out with reviews, please let me know. I would be happy to invite as many people as possible to the main repository.","tags":"","url":"page/contributing.html"},{"title":"Design – PIC","text":"Design philosophy The idea of this library was inspired a bit by a very cool talk Chris Lattner gave\nat some conference. In his talk, he mentions how the LLVM project just grew in\nmany directions thanks to how the design of the project was done. I.e. the fact\nthat most of the components of the LLVM are in the lib subdirectory. If you’ve never compiled the LLVM I suggest you do it, you’ll see that you can\nenable different compoenents depending on your needs. Rarely does one need to build everything in it. The same idea will be applied to PIC. I want to provide a set of components\nthat can be used independently of each other. There will be of course, a core library\nthat will provide the most basic functionality. For example, everything at the very bottom depends\non the pic_types.F90 module, so you cannot really use PIC without it. So following this concept, PIC will create a series of libraries that are based\nupon the core library, i.e. the very basic functionality that will always be built\nno matter what project you select on top. This idea is more important if you’re using the CMake build system, since this\nwill need to be configured when building from source. Otherwise, if you are using\nthe Fortrn package manager and using pic as a dependency in your project, the FPM\nwill only builds the modules/components that you actually include in your project. I find this very neat. At this point, the core library is everything, I haven’t refactored the code to be\nbuilt into separate libraries, however I already have the modularity to not build\ncertain bits, like BLAS, or MPI. I envision the following structure libpic_core\nlibpic_blas\nlibpic_mpi\nlibpic_gpu And PIC will be able to build all of these with default_int set to either int32 or int64 , depending on the needs of the user.\nNaturally, the MPI module will only use int32 as the default integer type, since MPI ( mpi_f08 ) does not support int64 in its API. Design goals I hope that this library will be useful for many people, mostly as a fast and efficient way to\nwrite parallel code in Fortran. I also hope that it will be a good example of how\nto write (modern) Fortran code that is modular, extensible, and easy to use. This is also my attempt into showcasing that Fortran is not a boring old language that only has\na relevance in legacy code. I want to show that Fortran can be used to write modern, high-performance code that is easy to read and maintain.","tags":"","url":"page/design.html"}]}