var tipuesearch = {"pages":[{"title":" PIC ","text":"PIC PIC is named after the Huastec word PIC which means otter. A work in progress on writing a cool backend for Fortan applications focused on Quantum Chemistry software. Building and dependencies There’s two build systems included in the present version, CMake and the Fortran Package Manager . The dependencies of the project are, as of now, CMake (if using cmake), MPI, OpenMP, and a BLAS/LAPACK library. Documentation The code itself is documented using FORD and the documentation is available here . Comments in the code that are prefixed with !! are considered documentation comments and will be processed by FORD. Comments without that prefix are considered regular comments and will not be processed by FORD. So, please do not use !! for your comments unless you want them to be included in the documentation. CMake CMake offers a very modular build of PIC, the following options are available and can be triggered by -DPIC_ENABLE_XYZ=ON/OFF Option Name Default Description PIC_DEFAULT_INT8 OFF Use 8-byte integers as default PIC_ENABLE_MPI OFF Enable the use of MPI in PIC PIC_ENABLE_OMP OFF Enable the use of OpenMP in PIC PIC_ENABLE_BLAS OFF Enable BLAS/LAPACK libraries in PIC PIC_ENABLE_TESTING ON Enable testing for PIC PIC_ENABLE_JONQUIL OFF Enable Jonquil for JSON/TOML handling Advanced options: Option Name Default Description PIC_USE_VAPAA OFF Use vapaa for binding to MPI Information on vapaa see here which is my\npersonal fork which is pulled from here, and Jeff’s project . Will update to use the orignal project at a later date. Building: mkdir build\ncd build\ncmake ../\nmake -j\nctest FPM Install the FPM following the instructions and then simply: fpm build Contributing Please see the contributing guidelines for information on how to contribute to the project. Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"logger_type – PIC ","text":"type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info logical, private :: log_file_open = .false. integer(kind=default_int), private :: log_file_unit = -1 Type-Bound Procedures procedure, public, pass(self) :: close_log_file Close the log file, needs to be called at the end of the program.\nUsage: call my_logger%close_log_file() private  subroutine close_log_file (self) Close the log file, needs to be called at the end of the program Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self procedure, public, pass(self) :: configuration Get the current logger verbosity configuration.\nUsage: call my_logger%configuration(level) private pure subroutine configuration (self, level) Get the current logger verbosity configuration Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level procedure, public, pass(self) :: configure Configure the logger to be a certain verbosity level.\nUsage: call my_logger%configure(level) private pure subroutine configure (self, level) Configure the logger to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: configure_file_output Configure the logger to file to be a certain verbosity level.\nUsage: call my_logger%configure_file_output(filename, level) private  subroutine configure_file_output (self, filename, level) Configure the logger to file to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: debug Log a message that will only be printed at the debug level of verbosity.\nUsage: call my_logger%debug(“MESSAGE”) private  subroutine debug (self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: error Log a message that will only be printed at the error level of verbosity.\nUsage: call my_logger%error(“MESSAGE”) private  subroutine error (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: info Log a message that will only be printed at the info level of verbosity.\nUsage: call my_logger%info(“MESSAGE”) private  subroutine info (self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: performance Log a message that will only be printed at the performance level of verbosity.\nUsage: call my_logger%performance(“MESSAGE”) private  subroutine performance (self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: verbose Log a message that will only be printed at the verbose level of verbosity.\nUsage: call my_logger%verbose(“MESSAGE”) private  subroutine verbose (self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: warning Log a message that will only be printed at the warning level of verbosity.\nUsage: call my_logger%warning(“MESSAGE”) private  subroutine warning (self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, private, pass(self) :: log Processes the message and filters it according to the verbosity level set by the user or the default private  subroutine log (self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration !! Get the current logger verbosity configuration. !! Usage: call my_logger%configuration(level) procedure , public , pass ( self ) :: configure !! Configure the logger to be a certain verbosity level. !! Usage: call my_logger%configure(level) procedure , public , pass ( self ) :: configure_file_output !! Configure the logger to file to be a certain verbosity level. !! Usage: call my_logger%configure_file_output(filename, level) procedure , public , pass ( self ) :: close_log_file !! Close the log file, needs to be called at the end of the program. !! Usage: call my_logger%close_log_file() procedure , public , pass ( self ) :: debug !! Log a message that will only be printed at the debug level of verbosity. !! Usage: call my_logger%debug(\"MESSAGE\") procedure , public , pass ( self ) :: verbose !! Log a message that will only be printed at the verbose level of verbosity. !! Usage: call my_logger%verbose(\"MESSAGE\") procedure , public , pass ( self ) :: info !! Log a message that will only be printed at the info level of verbosity. !! Usage: call my_logger%info(\"MESSAGE\") procedure , public , pass ( self ) :: performance !! Log a message that will only be printed at the performance level of verbosity. !! Usage: call my_logger%performance(\"MESSAGE\") procedure , public , pass ( self ) :: warning !! Log a message that will only be printed at the warning level of verbosity. !! Usage: call my_logger%warning(\"MESSAGE\") procedure , public , pass ( self ) :: error !! Log a message that will only be printed at the error level of verbosity. !! Usage: call my_logger%error(\"MESSAGE\") procedure , private , pass ( self ) :: log !! Processes the message and filters it according to the verbosity level set by the user or the default end type logger_type","tags":"","url":"type/logger_type.html"},{"title":"flop_rate_type – PIC ","text":"type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Inherits type~~flop_rate_type~~InheritsGraph type~flop_rate_type flop_rate_type type~flop_recorder_type flop_recorder_type type~flop_rate_type->type~flop_recorder_type m_flops type~pic_timer_type pic_timer_type type~flop_rate_type->type~pic_timer_type m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial real(kind=dp), private :: m_flop_rate private by default so that people use the accessor functions type( flop_recorder_type ), private :: m_flops type( pic_timer_type ), private :: m_timer Type-Bound Procedures procedure, public :: add_flops => flop_rate_add_flops private  subroutine flop_rate_add_flops (self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public :: get_flop_rate => flop_rate_get_flop_rate private  function flop_rate_get_flop_rate (self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) procedure, public :: get_flops => flop_rate_get_flops private  function flop_rate_get_flops (self) result(flops) get the number of flops recorded in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public :: get_time => flop_rate_get_time private  function flop_rate_get_time (self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) procedure, public :: report => flop_rate_report private  subroutine flop_rate_report (self) report the flop rate, this will print the flop rate in GFLOP/s Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: reset => flop_rate_reset private  subroutine flop_rate_reset (self) reset the flop rate type, this will reset the timer and the flop recorder Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: start_time => flop_rate_start_time private  subroutine flop_rate_start_time (self) Calls the start method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: stop_time => flop_rate_stop_time private  subroutine flop_rate_stop_time (self) Calls the stop method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Source Code type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( pic_timer_type ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure :: start_time => flop_rate_start_time procedure :: stop_time => flop_rate_stop_time procedure :: add_flops => flop_rate_add_flops procedure :: get_flops => flop_rate_get_flops procedure :: get_time => flop_rate_get_time procedure :: get_flop_rate => flop_rate_get_flop_rate procedure :: report => flop_rate_report procedure :: reset => flop_rate_reset end type flop_rate_type","tags":"","url":"type/flop_rate_type.html"},{"title":"flop_recorder_type – PIC ","text":"type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Inherited by type~~flop_recorder_type~~InheritedByGraph type~flop_recorder_type flop_recorder_type type~flop_rate_type flop_rate_type type~flop_rate_type->type~flop_recorder_type m_flops Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=int64), private :: flop_count = 0_int64 Type-Bound Procedures procedure, public :: add => add_flops private  subroutine add_flops (self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public :: get => get_flops private  function get_flops (self) result(flops) Get the int64 number of FLOPs we currently have in the counter Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public :: reset => reset_flop_counter private  subroutine reset_flop_counter (self) Resets the flop counter to 0_int64 Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self Source Code type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure :: add => add_flops procedure :: get => get_flops procedure :: reset => reset_flop_counter end type flop_recorder_type","tags":"","url":"type/flop_recorder_type.html"},{"title":"pic_comm_type – PIC ","text":"type, public :: pic_comm_type custom data type that holds the MPI communicators Inherits type~~pic_comm_type~~InheritsGraph type~pic_comm_type pic_comm_type MPI_COMM MPI_COMM type~pic_comm_type->MPI_COMM comm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial type(MPI_COMM), public :: comm use the MPI_COMM from the mpi_f08 module interface integer(kind=int32), public :: m_ierr integer(kind=int32), public :: m_rank MPI rank integer(kind=int32), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize private  subroutine pic_comm_finalize (self) finalize the MPI library Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self procedure, public :: init => pic_comm_init private  subroutine pic_comm_init (self) initilalize the MPI library and get the size and rank variables Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self Source Code type :: pic_comm_type !! custom data type that holds the MPI communicators private type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface integer ( int32 ), public :: m_rank !! MPI rank integer ( int32 ), public :: m_size !! MPI size integer ( int32 ), public :: m_ierr contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm_type","tags":"","url":"type/pic_comm_type.html"},{"title":"pic_timer_type – PIC ","text":"type, public :: pic_timer_type derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp. If PIC is compiled with OpenMP the default\ntimer will be the omp time. This is mostly to minimize problems with threading\nand system clock Inherited by type~~pic_timer_type~~InheritedByGraph type~pic_timer_type pic_timer_type type~flop_rate_type flop_rate_type type~flop_rate_type->type~pic_timer_type m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Components Type Visibility Attributes Name Initial integer(kind=default_int), private :: count_rate = 1_default_int logical, private :: is_running = .false. integer(kind=default_int), private :: start_count = 0_default_int real(kind=dp), private :: start_time = 0.0_dp integer(kind=default_int), private :: stop_count = 0_default_int real(kind=dp), private :: stop_time = 0.0_dp real(kind=dp), private :: walltime Type-Bound Procedures procedure, public :: get_elapsed_time => timer_get_elapsed_time private  function timer_get_elapsed_time (self) result(elapsed) Returns the elapsed time as a real(dp) variable Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self Return Value real(kind=dp) procedure, public :: print_time => timer_print_time private  subroutine timer_print_time (self) Prints the elapsed time at the time of calling Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self procedure, public :: start => timer_start private  subroutine timer_start (self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self procedure, public :: stop => timer_stop private  subroutine timer_stop (self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self Source Code type :: pic_timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp. If PIC is compiled with OpenMP the default !! timer will be the omp time. This is mostly to minimize problems with threading !! and system clock private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time end type pic_timer_type","tags":"","url":"type/pic_timer_type.html"},{"title":"print_matrix – PIC","text":"private  subroutine print_matrix(mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix~~CallsGraph proc~print_matrix print_matrix proc~print_matrix_in_format print_matrix_in_format proc~print_matrix->proc~print_matrix_in_format proc~print_plain_matrix print_plain_matrix proc~print_matrix->proc~print_plain_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix~~CalledByGraph proc~print_matrix print_matrix interface~print_array print_array interface~print_array->proc~print_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: format_selected Source Code subroutine print_matrix ( mat , format_type ) !! print a matrix in a given format real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat ) else call print_matrix_in_format ( mat , format_selected ) end if end subroutine print_matrix","tags":"","url":"proc/print_matrix.html"},{"title":"print_matrix_in_format – PIC","text":"private  subroutine print_matrix_in_format(mat, format_type, n_cols, n_rows) private subroutine to print a matrix in format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows Called by proc~~print_matrix_in_format~~CalledByGraph proc~print_matrix_in_format print_matrix_in_format proc~print_matrix print_matrix proc~print_matrix->proc~print_matrix_in_format proc~print_matrix_m_n print_matrix_m_n proc~print_matrix_m_n->proc~print_matrix_in_format interface~print_array print_array interface~print_array->proc~print_matrix interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_matrix_m_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: j integer(kind=default_int), private :: loop_bound_i integer(kind=default_int), private :: loop_bound_j character(len=1), private :: open_bracket Source Code subroutine print_matrix_in_format ( mat , format_type , n_cols , n_rows ) !! private subroutine to print a matrix in format real ( kind = dp ), intent ( in ) :: mat (:, :) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the matrix in the selected format print * , \"Matrix (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i write ( * , \"(A)\" , advance = \"no\" ) open_bracket ! Start of a row do j = 1 , loop_bound_j if ( j == loop_bound_j ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) mat ( i , j ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) end if end do if ( i == loop_bound_i ) then print * , close_bracket ! Close bracket without a comma for the last row else print * , close_bracket , \",\" ! Close bracket with a comma for all other rows end if end do print * , close_bracket end subroutine print_matrix_in_format","tags":"","url":"proc/print_matrix_in_format.html"},{"title":"print_matrix_m_n – PIC","text":"private  subroutine print_matrix_m_n(mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_m_n~~CallsGraph proc~print_matrix_m_n print_matrix_m_n proc~print_matrix_in_format print_matrix_in_format proc~print_matrix_m_n->proc~print_matrix_in_format proc~print_plain_matrix print_plain_matrix proc~print_matrix_m_n->proc~print_plain_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_m_n~~CalledByGraph proc~print_matrix_m_n print_matrix_m_n interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_matrix_m_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: format_selected Source Code subroutine print_matrix_m_n ( mat , n_cols , n_rows , format_type ) !! Print a matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array integer ( kind = default_int ), intent ( in ) :: n_cols , n_rows character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat , n_cols , n_rows ) else call print_matrix_in_format ( mat , format_selected , n_cols , n_rows ) end if end subroutine print_matrix_m_n","tags":"","url":"proc/print_matrix_m_n.html"},{"title":"print_plain_matrix – PIC","text":"private  subroutine print_plain_matrix(mat, n_cols, n_rows) private subroutine that prints a plain matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows Called by proc~~print_plain_matrix~~CalledByGraph proc~print_plain_matrix print_plain_matrix proc~print_matrix print_matrix proc~print_matrix->proc~print_plain_matrix proc~print_matrix_m_n print_matrix_m_n proc~print_matrix_m_n->proc~print_plain_matrix interface~print_array print_array interface~print_array->proc~print_matrix interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_matrix_m_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: j integer(kind=default_int), private :: loop_bound_i integer(kind=default_int), private :: loop_bound_j Source Code subroutine print_plain_matrix ( mat , n_cols , n_rows ) !! private subroutine that prints a plain matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if print * , \"Matrix (Plain format):\" do i = 1 , loop_bound_i do j = 1 , loop_bound_j if ( j == loop_bound_j ) then write ( * , fmt_edge , advance = \"yes\" ) mat ( i , j ) ! Last element in the row, new line else write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) ! In-between elements end if end do end do end subroutine print_plain_matrix","tags":"","url":"proc/print_plain_matrix.html"},{"title":"print_plain_vector – PIC","text":"private  subroutine print_plain_vector(vec, n_elements) private subroutine that prints a vector of n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in), optional :: n_elements Called by proc~~print_plain_vector~~CalledByGraph proc~print_plain_vector print_plain_vector proc~print_vector print_vector proc~print_vector->proc~print_plain_vector proc~print_vector_n print_vector_n proc~print_vector_n->proc~print_plain_vector interface~print_array print_array interface~print_array->proc~print_vector interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_vector_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: loop_bound Source Code subroutine print_plain_vector ( vec , n_elements ) !! private subroutine that prints a vector of n_elements real ( kind = dp ), intent ( in ) :: vec (:) integer ( kind = default_int ), intent ( in ), optional :: n_elements integer ( kind = default_int ) :: i , loop_bound if ( present ( n_elements )) then loop_bound = n_elements else loop_bound = size ( vec ) end if print * , \"Vector (Plain format):\" do i = 1 , loop_bound write ( * , fmt_edge ) vec ( i ) end do end subroutine print_plain_vector","tags":"","url":"proc/print_plain_vector.html"},{"title":"print_vector – PIC","text":"private  subroutine print_vector(vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector~~CallsGraph proc~print_vector print_vector proc~print_plain_vector print_plain_vector proc~print_vector->proc~print_plain_vector proc~print_vector_in_format print_vector_in_format proc~print_vector->proc~print_vector_in_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector~~CalledByGraph proc~print_vector print_vector interface~print_array print_array interface~print_array->proc~print_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: format_selected Source Code subroutine print_vector ( vec , format_type ) !! print a vector real ( kind = dp ), intent ( in ) :: vec (:) ! 1D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec ) else call print_vector_in_format ( vec , format_selected ) end if end subroutine print_vector","tags":"","url":"proc/print_vector.html"},{"title":"print_vector_in_format – PIC","text":"private  subroutine print_vector_in_format(vec, format_type, n_elements) private subroutine that prints a vector in a format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_elements Called by proc~~print_vector_in_format~~CalledByGraph proc~print_vector_in_format print_vector_in_format proc~print_vector print_vector proc~print_vector->proc~print_vector_in_format proc~print_vector_n print_vector_n proc~print_vector_n->proc~print_vector_in_format interface~print_array print_array interface~print_array->proc~print_vector interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_vector_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: loop_bound_i character(len=1), private :: open_bracket Source Code subroutine print_vector_in_format ( vec , format_type , n_elements ) !! private subroutine that prints a vector in a format real ( kind = dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy integer ( kind = default_int ), intent ( in ), optional :: n_elements character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ) :: i , loop_bound_i if ( present ( n_elements )) then loop_bound_i = n_elements else loop_bound_i = size ( vec ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the vector in the selected format print * , \"Vector (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) vec ( i ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) vec ( i ) end if end do print * , close_bracket end subroutine print_vector_in_format","tags":"","url":"proc/print_vector_in_format.html"},{"title":"print_vector_n – PIC","text":"private  subroutine print_vector_n(vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_n~~CallsGraph proc~print_vector_n print_vector_n proc~print_plain_vector print_plain_vector proc~print_vector_n->proc~print_plain_vector proc~print_vector_in_format print_vector_in_format proc~print_vector_n->proc~print_vector_in_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_n~~CalledByGraph proc~print_vector_n print_vector_n interface~print_array_with_bounds print_array_with_bounds interface~print_array_with_bounds->proc~print_vector_n Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: format_selected Source Code subroutine print_vector_n ( vec , n_elements , format_type ) !! print a vector from start up to n_elements real ( dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected integer ( kind = default_int ), intent ( in ) :: n_elements ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec , n_elements ) else call print_vector_in_format ( vec , format_selected , n_elements ) end if end subroutine print_vector_n","tags":"","url":"proc/print_vector_n.html"},{"title":"print_array – PIC","text":"public interface print_array general interface for printing a one or two dimensional array\nwill be deprecated Calls interface~~print_array~~CallsGraph interface~print_array print_array proc~print_matrix print_matrix interface~print_array->proc~print_matrix proc~print_vector print_vector interface~print_array->proc~print_vector proc~print_matrix_in_format print_matrix_in_format proc~print_matrix->proc~print_matrix_in_format proc~print_plain_matrix print_plain_matrix proc~print_matrix->proc~print_plain_matrix proc~print_plain_vector print_plain_vector proc~print_vector->proc~print_plain_vector proc~print_vector_in_format print_vector_in_format proc~print_vector->proc~print_vector_in_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array.html"},{"title":"print_array_with_bounds – PIC","text":"public interface print_array_with_bounds general interface to print an array within certain bounds Calls interface~~print_array_with_bounds~~CallsGraph interface~print_array_with_bounds print_array_with_bounds proc~print_matrix_m_n print_matrix_m_n interface~print_array_with_bounds->proc~print_matrix_m_n proc~print_vector_n print_vector_n interface~print_array_with_bounds->proc~print_vector_n proc~print_matrix_in_format print_matrix_in_format proc~print_matrix_m_n->proc~print_matrix_in_format proc~print_plain_matrix print_plain_matrix proc~print_matrix_m_n->proc~print_plain_matrix proc~print_plain_vector print_plain_vector proc~print_vector_n->proc~print_plain_vector proc~print_vector_in_format print_vector_in_format proc~print_vector_n->proc~print_vector_in_format Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array_with_bounds.html"},{"title":"optional_char – PIC","text":"private pure function optional_char(input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable Called by proc~~optional_char~~CalledByGraph proc~optional_char optional_char interface~pic_optional pic_optional interface~pic_optional->proc~optional_char Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_char ( input_value , default_value ) result ( output ) character ( len =* ), intent ( in ), optional :: input_value character ( len =* ), intent ( in ) :: default_value character ( len = :), allocatable :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_char","tags":"","url":"proc/optional_char.html"},{"title":"optional_dp – PIC","text":"private pure function optional_dp(input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) Called by proc~~optional_dp~~CalledByGraph proc~optional_dp optional_dp interface~pic_optional pic_optional interface~pic_optional->proc~optional_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_dp ( input_value , default_value ) result ( output ) real ( dp ), intent ( in ), optional :: input_value real ( dp ), intent ( in ) :: default_value real ( dp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_dp","tags":"","url":"proc/optional_dp.html"},{"title":"optional_int32 – PIC","text":"private pure function optional_int32(input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) Called by proc~~optional_int32~~CalledByGraph proc~optional_int32 optional_int32 interface~pic_optional pic_optional interface~pic_optional->proc~optional_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_int32 ( input_value , default_value ) result ( output ) integer ( int32 ), intent ( in ), optional :: input_value integer ( int32 ), intent ( in ) :: default_value integer ( int32 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int32","tags":"","url":"proc/optional_int32.html"},{"title":"optional_int64 – PIC","text":"private pure function optional_int64(input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) Called by proc~~optional_int64~~CalledByGraph proc~optional_int64 optional_int64 interface~pic_optional pic_optional interface~pic_optional->proc~optional_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_int64 ( input_value , default_value ) result ( output ) integer ( int64 ), intent ( in ), optional :: input_value integer ( int64 ), intent ( in ) :: default_value integer ( int64 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int64","tags":"","url":"proc/optional_int64.html"},{"title":"optional_sp – PIC","text":"private pure function optional_sp(input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) Called by proc~~optional_sp~~CalledByGraph proc~optional_sp optional_sp interface~pic_optional pic_optional interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function optional_sp ( input_value , default_value ) result ( output ) real ( sp ), intent ( in ), optional :: input_value real ( sp ), intent ( in ) :: default_value real ( sp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_sp","tags":"","url":"proc/optional_sp.html"},{"title":"pic_optional – PIC","text":"public interface pic_optional Calls interface~~pic_optional~~CallsGraph interface~pic_optional pic_optional proc~optional_char optional_char interface~pic_optional->proc~optional_char proc~optional_dp optional_dp interface~pic_optional->proc~optional_dp proc~optional_int32 optional_int32 interface~pic_optional->proc~optional_int32 proc~optional_int64 optional_int64 interface~pic_optional->proc~optional_int64 proc~optional_sp optional_sp interface~pic_optional->proc~optional_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function optional_int32 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_sp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) private pure function optional_dp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_char (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable","tags":"","url":"interface/pic_optional.html"},{"title":"close_log_file – PIC","text":"private  subroutine close_log_file(self) Close the log file, needs to be called at the end of the program Usage: call my_logger%close_log_file() TODO: revisit Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self Called by proc~~close_log_file~~CalledByGraph proc~close_log_file logger_type%close_log_file proc~configure_file_output logger_type%configure_file_output proc~configure_file_output->proc~close_log_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine close_log_file ( self ) !! Close the log file, needs to be called at the end of the program !! !! Usage: call my_logger%close_log_file() !! !! TODO: revisit class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file","tags":"","url":"proc/close_log_file.html"},{"title":"configuration – PIC","text":"private pure subroutine configuration(self, level) Get the current logger verbosity configuration Usage: call my_logger%configuration(level) TODO: this should be a function Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level Source Code pure subroutine configuration ( self , level ) !! Get the current logger verbosity configuration !! !! Usage: call my_logger%configuration(level) !! !! TODO: this should be a function class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration","tags":"","url":"proc/configuration.html"},{"title":"configure – PIC","text":"private pure subroutine configure(self, level) Configure the logger to be a certain verbosity level Usage: call my_logger%configure(level) Where level can be a number according to the level struct\nor can be loaded from the level struct to be debug_level = 10, & verbose_level = 9, & info_level = 8, & performance_level = 7, & warning_level = 6, & error_level = 5 Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level Source Code pure subroutine configure ( self , level ) !! Configure the logger to be a certain verbosity level !! !! Usage: call my_logger%configure(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5 !! class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure","tags":"","url":"proc/configure.html"},{"title":"configure_file_output – PIC","text":"private  subroutine configure_file_output(self, filename, level) Configure the logger to file to be a certain verbosity level Usage: call my_logger%configure_file_output(level) Where level can be a number according to the level struct\nor can be loaded from the level struct to be debug_level = 10, & verbose_level = 9, & info_level = 8, & performance_level = 7, & warning_level = 6, & error_level = 5 Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level Calls proc~~configure_file_output~~CallsGraph proc~configure_file_output logger_type%configure_file_output proc~close_log_file logger_type%close_log_file proc~configure_file_output->proc~close_log_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: ios Source Code subroutine configure_file_output ( self , filename , level ) !! Configure the logger to file to be a certain verbosity level !! !! Usage: call my_logger%configure_file_output(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5 !! class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = \"replace\" , action = \"write\" , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) \"ERROR: Failed to open log file: \" , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output","tags":"","url":"proc/configure_file_output.html"},{"title":"debug – PIC","text":"private  subroutine debug(self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Usage: call my_logger%debug(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine debug ( self , message , module , procedure ) !! Log a message that will only be printed at the debug level of verbosity !! !! Usage: call my_logger%debug(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug","tags":"","url":"proc/debug.html"},{"title":"error – PIC","text":"private  subroutine error(self, message, module, procedure) Log a message that will only be printed at the error of verbosity Usage: call my_logger%error(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine error ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%error(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error","tags":"","url":"proc/error.html"},{"title":"info – PIC","text":"private  subroutine info(self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Usage: call my_logger%info(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine info ( self , message , module , procedure ) !! Log a message that will only be printed at the info level of verbosity !! !! Usage: call my_logger%info(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info","tags":"","url":"proc/info.html"},{"title":"log – PIC","text":"private  subroutine log(self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Calls proc~~log~~CallsGraph proc~log logger_type%log proc~write_log_line write_log_line proc~log->proc~write_log_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: log_level_value Source Code subroutine log ( self , level , message , module , procedure ) !! internal subroutines that processes the message and filters it according to !! the verbosity level set by the user or the default !! this is a private subroutine so it is not exposed to the user class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( \"DEBUG\" ) log_level_value = debug_level case ( \"VERBOSE\" ) log_level_value = verbose_level case ( \"INFO\" ) log_level_value = info_level case ( \"WARNING\" ) log_level_value = warning_level case ( \"PERFORMANCE\" ) log_level_value = performance_level case ( \"ERROR\" ) log_level_value = error_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log","tags":"","url":"proc/log.html"},{"title":"performance – PIC","text":"private  subroutine performance(self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Usage: call my_logger%performance(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine performance ( self , message , module , procedure ) !! Log a message that will only be printed at the performance of verbosity !! !! Usage: call my_logger%performance(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance","tags":"","url":"proc/performance.html"},{"title":"verbose – PIC","text":"private  subroutine verbose(self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Usage: call my_logger%verbose(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine verbose ( self , message , module , procedure ) !! Log a message that will only be printed at the verbose level of verbosity !! !! Usage: call my_logger%verbose(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose","tags":"","url":"proc/verbose.html"},{"title":"warning – PIC","text":"private  subroutine warning(self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Usage: call my_logger%warning(“MESSAGE”) Type Bound logger_type Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code subroutine warning ( self , message , module , procedure ) !! Log a message that will only be printed at the warning level of verbosity !! !! Usage: call my_logger%warning(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning","tags":"","url":"proc/warning.html"},{"title":"write_log_line – PIC","text":"private  subroutine write_log_line(unit, level, message, module, procedure) Internal subroutine that will write the message to the log\nno interface to the public Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: unit character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Called by proc~~write_log_line~~CalledByGraph proc~write_log_line write_log_line proc~log logger_type%log proc~log->proc~write_log_line Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine write_log_line ( unit , level , message , module , procedure ) !! Internal subroutine that will write the message to the log !! no interface to the public integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line","tags":"","url":"proc/write_log_line.html"},{"title":"flop_rate_get_flop_rate – PIC","text":"private  function flop_rate_get_flop_rate(self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Usage: flop_rate = my_flop_rate%get_flop_rate() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) Calls proc~~flop_rate_get_flop_rate~~CallsGraph proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate->proc~get_flops proc~timer_get_elapsed_time pic_timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~flop_rate_get_flop_rate~~CalledByGraph proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int64), private :: flops real(kind=dp), private :: time Source Code function flop_rate_get_flop_rate ( self ) result ( flop_rate ) !! get the flop rate in GFLOP/s, this will calculate the flop rate based on the !! number of flops and the elapsed time !! !! Usage: flop_rate = my_flop_rate%get_flop_rate() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self real ( dp ) :: flop_rate real ( dp ) :: time integer ( int64 ) :: flops flops = self % m_flops % get () time = self % m_timer % get_elapsed_time () if ( time <= 0.0_dp ) then print * , \"Warning: Time is zero or negative, setting flop rate to zero.\" self % m_flop_rate = 0.0_dp flop_rate = 0.0_dp return else self % m_flop_rate = flops / time / 1.0e9_dp flop_rate = self % m_flop_rate end if end function flop_rate_get_flop_rate","tags":"","url":"proc/flop_rate_get_flop_rate.html"},{"title":"flop_rate_get_flops – PIC","text":"private  function flop_rate_get_flops(self) result(flops) get the number of flops recorded in the flop rate type Usage: flops = my_flop_rate%get_flops() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) Calls proc~~flop_rate_get_flops~~CallsGraph proc~flop_rate_get_flops flop_rate_type%flop_rate_get_flops proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flops->proc~get_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function flop_rate_get_flops ( self ) result ( flops ) !! get the number of flops recorded in the flop rate type !! !! Usage: flops = my_flop_rate%get_flops() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % m_flops % get () end function flop_rate_get_flops","tags":"","url":"proc/flop_rate_get_flops.html"},{"title":"flop_rate_get_time – PIC","text":"private  function flop_rate_get_time(self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Usage: time = my_flop_rate%get_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) Calls proc~~flop_rate_get_time~~CallsGraph proc~flop_rate_get_time flop_rate_type%flop_rate_get_time proc~timer_get_elapsed_time pic_timer_type%timer_get_elapsed_time proc~flop_rate_get_time->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function flop_rate_get_time ( self ) result ( time ) !! get the elapsed time in seconds from the timer contained in the flop rate type !! !! Usage: time = my_flop_rate%get_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self real ( dp ) :: time time = self % m_timer % get_elapsed_time () end function flop_rate_get_time","tags":"","url":"proc/flop_rate_get_time.html"},{"title":"flop_rate_add_flops – PIC","text":"private  subroutine flop_rate_add_flops(self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops Calls proc~~flop_rate_add_flops~~CallsGraph proc~flop_rate_add_flops flop_rate_type%flop_rate_add_flops proc~add_flops flop_recorder_type%add_flops proc~flop_rate_add_flops->proc~add_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_add_flops ( self , flops ) !! add flops to the flop rate type, this will add the flops to the flop recorder !! Usage: call my_flop_rate%add_flops(1000) !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops call self % m_flops % add ( flops ) end subroutine flop_rate_add_flops","tags":"","url":"proc/flop_rate_add_flops.html"},{"title":"flop_rate_report – PIC","text":"private  subroutine flop_rate_report(self) report the flop rate, this will print the flop rate in GFLOP/s Usage: call my_flop_rate%report() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_report~~CallsGraph proc~flop_rate_report flop_rate_type%flop_rate_report interface~to_string to_string proc~flop_rate_report->interface~to_string proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_report->proc~flop_rate_get_flop_rate proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate->proc~get_flops proc~timer_get_elapsed_time pic_timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_report ( self ) !! report the flop rate, this will print the flop rate in GFLOP/s !! !! Usage: call my_flop_rate%report() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self self % m_flop_rate = self % get_flop_rate () print * , \"Flop rate is \" // to_string ( self % m_flop_rate ) // \" GFLOP/s\" end subroutine flop_rate_report","tags":"","url":"proc/flop_rate_report.html"},{"title":"flop_rate_reset – PIC","text":"private  subroutine flop_rate_reset(self) reset the flop rate type, this will reset the timer and the flop recorder Usage: call my_flop_rate%reset() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_reset~~CallsGraph proc~flop_rate_reset flop_rate_type%flop_rate_reset proc~reset_flop_counter flop_recorder_type%reset_flop_counter proc~flop_rate_reset->proc~reset_flop_counter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_reset ( self ) !! reset the flop rate type, this will reset the timer and the flop recorder !! !! Usage: call my_flop_rate%reset() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_flops % reset () end subroutine flop_rate_reset","tags":"","url":"proc/flop_rate_reset.html"},{"title":"flop_rate_start_time – PIC","text":"private  subroutine flop_rate_start_time(self) Calls the start method for the timer contained in the flop rate type Usage: call my_flop_rate%start_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Calls proc~~flop_rate_start_time~~CallsGraph proc~flop_rate_start_time flop_rate_type%flop_rate_start_time proc~timer_start pic_timer_type%timer_start proc~flop_rate_start_time->proc~timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine flop_rate_start_time ( self ) !! Calls the start method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%start_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % start () end subroutine flop_rate_start_time","tags":"","url":"proc/flop_rate_start_time.html"},{"title":"flop_rate_stop_time – PIC","text":"private  subroutine flop_rate_stop_time(self) Calls the stop method for the timer contained in the flop rate type Usage: call my_flop_rate%stop_time() where my_flop_rate is an instance of flop_rate_type Type Bound flop_rate_type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Source Code subroutine flop_rate_stop_time ( self ) !! Calls the stop method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%stop_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % stop () end subroutine flop_rate_stop_time","tags":"","url":"proc/flop_rate_stop_time.html"},{"title":"pic_cdotc – PIC","text":"private  function pic_cdotc(x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) Calls proc~~pic_cdotc~~CallsGraph proc~pic_cdotc pic_cdotc interface~blas_dot blas_dot proc~pic_cdotc->interface~blas_dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_cdotc~~CalledByGraph proc~pic_cdotc pic_cdotc interface~pic_dot pic_dot interface~pic_dot->proc~pic_cdotc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code function pic_cdotc ( x , y ) result ( res ) !! interface for single precision complex dot product complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( in ) :: y (:) complex ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_cdotc","tags":"","url":"proc/pic_cdotc.html"},{"title":"pic_dasum – PIC","text":"private  function pic_dasum(x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) Calls proc~~pic_dasum~~CallsGraph proc~pic_dasum pic_dasum interface~blas_asum blas_asum proc~pic_dasum->interface~blas_asum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dasum~~CalledByGraph proc~pic_dasum pic_dasum interface~pic_asum pic_asum interface~pic_asum->proc~pic_dasum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_dasum ( x ) result ( res ) !! interface for double precision absolute sum real ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dasum","tags":"","url":"proc/pic_dasum.html"},{"title":"pic_ddot – PIC","text":"private  function pic_ddot(x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) Calls proc~~pic_ddot~~CallsGraph proc~pic_ddot pic_ddot interface~blas_dot blas_dot proc~pic_ddot->interface~blas_dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_ddot~~CalledByGraph proc~pic_ddot pic_ddot interface~pic_dot pic_dot interface~pic_dot->proc~pic_ddot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code function pic_ddot ( x , y ) result ( res ) !! interface for double precision dot product real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( in ) :: y (:) real ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_ddot","tags":"","url":"proc/pic_ddot.html"},{"title":"pic_dzasum – PIC","text":"private  function pic_dzasum(x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) Calls proc~~pic_dzasum~~CallsGraph proc~pic_dzasum pic_dzasum interface~blas_asum blas_asum proc~pic_dzasum->interface~blas_asum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dzasum~~CalledByGraph proc~pic_dzasum pic_dzasum interface~pic_asum pic_asum interface~pic_asum->proc~pic_dzasum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_dzasum ( x ) result ( res ) !! interface for double precision complex absolute sum complex ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dzasum","tags":"","url":"proc/pic_dzasum.html"},{"title":"pic_icamax – PIC","text":"private  function pic_icamax(x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) Calls proc~~pic_icamax~~CallsGraph proc~pic_icamax pic_icamax interface~blas_iamax blas_iamax proc~pic_icamax->interface~blas_iamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_icamax~~CalledByGraph proc~pic_icamax pic_icamax interface~pic_iamax pic_iamax interface~pic_iamax->proc~pic_icamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_icamax ( x ) result ( idx ) !! interface for single precision complex index of maximum absolute value complex ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_icamax","tags":"","url":"proc/pic_icamax.html"},{"title":"pic_idamax – PIC","text":"private  function pic_idamax(x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) Calls proc~~pic_idamax~~CallsGraph proc~pic_idamax pic_idamax interface~blas_iamax blas_iamax proc~pic_idamax->interface~blas_iamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_idamax~~CalledByGraph proc~pic_idamax pic_idamax interface~pic_iamax pic_iamax interface~pic_iamax->proc~pic_idamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_idamax ( x ) result ( idx ) !! interface for double precision index of maximum absolute value real ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_idamax","tags":"","url":"proc/pic_idamax.html"},{"title":"pic_isamax – PIC","text":"private  function pic_isamax(x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) Calls proc~~pic_isamax~~CallsGraph proc~pic_isamax pic_isamax interface~blas_iamax blas_iamax proc~pic_isamax->interface~blas_iamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_isamax~~CalledByGraph proc~pic_isamax pic_isamax interface~pic_iamax pic_iamax interface~pic_iamax->proc~pic_isamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_isamax ( x ) result ( idx ) !! interface for single precision index of maximum absolute value real ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_isamax","tags":"","url":"proc/pic_isamax.html"},{"title":"pic_izamax – PIC","text":"private  function pic_izamax(x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) Calls proc~~pic_izamax~~CallsGraph proc~pic_izamax pic_izamax interface~blas_iamax blas_iamax proc~pic_izamax->interface~blas_iamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_izamax~~CalledByGraph proc~pic_izamax pic_izamax interface~pic_iamax pic_iamax interface~pic_iamax->proc~pic_izamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_izamax ( x ) result ( idx ) !! interface for double precision complex index of maximum absolute value complex ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_izamax","tags":"","url":"proc/pic_izamax.html"},{"title":"pic_sasum – PIC","text":"private  function pic_sasum(x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) Calls proc~~pic_sasum~~CallsGraph proc~pic_sasum pic_sasum interface~blas_asum blas_asum proc~pic_sasum->interface~blas_asum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_sasum~~CalledByGraph proc~pic_sasum pic_sasum interface~pic_asum pic_asum interface~pic_asum->proc~pic_sasum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_sasum ( x ) result ( res ) !! interface for single precision absolute sum real ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_sasum","tags":"","url":"proc/pic_sasum.html"},{"title":"pic_scasum – PIC","text":"private  function pic_scasum(x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) Calls proc~~pic_scasum~~CallsGraph proc~pic_scasum pic_scasum interface~blas_asum blas_asum proc~pic_scasum->interface~blas_asum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_scasum~~CalledByGraph proc~pic_scasum pic_scasum interface~pic_asum pic_asum interface~pic_asum->proc~pic_scasum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: n Source Code function pic_scasum ( x ) result ( res ) !! interface for single precision complex absolute sum complex ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_scasum","tags":"","url":"proc/pic_scasum.html"},{"title":"pic_sdot – PIC","text":"private  function pic_sdot(x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) Calls proc~~pic_sdot~~CallsGraph proc~pic_sdot pic_sdot interface~blas_dot blas_dot proc~pic_sdot->interface~blas_dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_sdot~~CalledByGraph proc~pic_sdot pic_sdot interface~pic_dot pic_dot interface~pic_dot->proc~pic_sdot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code function pic_sdot ( x , y ) result ( res ) !! interface for single precision dot product real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( in ) :: y (:) real ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_sdot","tags":"","url":"proc/pic_sdot.html"},{"title":"pic_zdotc – PIC","text":"private  function pic_zdotc(x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp) Calls proc~~pic_zdotc~~CallsGraph proc~pic_zdotc pic_zdotc interface~blas_dot blas_dot proc~pic_zdotc->interface~blas_dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_zdotc~~CalledByGraph proc~pic_zdotc pic_zdotc interface~pic_dot pic_dot interface~pic_dot->proc~pic_zdotc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code function pic_zdotc ( x , y ) result ( res ) !! interface for double precision complex dot product complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( in ) :: y (:) complex ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_zdotc","tags":"","url":"proc/pic_zdotc.html"},{"title":"pic_caxpy – PIC","text":"private  subroutine pic_caxpy(x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha Calls proc~~pic_caxpy~~CallsGraph proc~pic_caxpy pic_caxpy interface~blas_axpy blas_axpy proc~pic_caxpy->interface~blas_axpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_caxpy~~CalledByGraph proc~pic_caxpy pic_caxpy interface~pic_axpy pic_axpy interface~pic_axpy->proc~pic_caxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy complex(kind=sp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_caxpy ( x , y , alpha ) !! interface for single precision complex AXPY complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_caxpy","tags":"","url":"proc/pic_caxpy.html"},{"title":"pic_ccopy – PIC","text":"private  subroutine pic_ccopy(x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) Calls proc~~pic_ccopy~~CallsGraph proc~pic_ccopy pic_ccopy interface~blas_copy blas_copy proc~pic_ccopy->interface~blas_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_ccopy~~CalledByGraph proc~pic_ccopy pic_ccopy interface~pic_copy pic_copy interface~pic_copy->proc~pic_ccopy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code subroutine pic_ccopy ( x , y ) !! interface for single precision complex copy complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_ccopy","tags":"","url":"proc/pic_ccopy.html"},{"title":"pic_cscal – PIC","text":"private  subroutine pic_cscal(x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha Calls proc~~pic_cscal~~CallsGraph proc~pic_cscal pic_cscal interface~blas_scal blas_scal proc~pic_cscal->interface~blas_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_cscal~~CalledByGraph proc~pic_cscal pic_cscal interface~pic_scal pic_scal interface~pic_scal->proc~pic_cscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx complex(kind=sp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_cscal ( x , alpha ) !! interface for single precision complex scaling complex ( sp ), intent ( inout ) :: x (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_cscal","tags":"","url":"proc/pic_cscal.html"},{"title":"pic_daxpy – PIC","text":"private  subroutine pic_daxpy(x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha Calls proc~~pic_daxpy~~CallsGraph proc~pic_daxpy pic_daxpy interface~blas_axpy blas_axpy proc~pic_daxpy->interface~blas_axpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_daxpy~~CalledByGraph proc~pic_daxpy pic_daxpy interface~pic_axpy pic_axpy interface~pic_axpy->proc~pic_daxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy real(kind=dp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_daxpy ( x , y , alpha ) !! interface for double precision AXPY real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_daxpy","tags":"","url":"proc/pic_daxpy.html"},{"title":"pic_dcopy – PIC","text":"private  subroutine pic_dcopy(x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) Calls proc~~pic_dcopy~~CallsGraph proc~pic_dcopy pic_dcopy interface~blas_copy blas_copy proc~pic_dcopy->interface~blas_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dcopy~~CalledByGraph proc~pic_dcopy pic_dcopy interface~pic_copy pic_copy interface~pic_copy->proc~pic_dcopy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code subroutine pic_dcopy ( x , y ) !! interface for double precision copy real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_dcopy","tags":"","url":"proc/pic_dcopy.html"},{"title":"pic_dgemm – PIC","text":"private pure subroutine pic_dgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta Calls proc~~pic_dgemm~~CallsGraph proc~pic_dgemm pic_dgemm interface~blas_gemm blas_gemm proc~pic_dgemm->interface~blas_gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dgemm~~CalledByGraph proc~pic_dgemm pic_dgemm interface~pic_gemm pic_gemm interface~pic_gemm->proc~pic_dgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: OP_A character(len=1), private :: OP_B integer(kind=default_int), private :: k real(kind=dp), private :: l_alpha real(kind=dp), private :: l_beta integer(kind=default_int), private :: lda integer(kind=default_int), private :: ldb integer(kind=default_int), private :: ldc integer(kind=default_int), private :: m integer(kind=default_int), private :: n Source Code pure subroutine pic_dgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: B (:, :) real ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_dgemm","tags":"","url":"proc/pic_dgemm.html"},{"title":"pic_dgemv – PIC","text":"private pure subroutine pic_dgemv(A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta Calls proc~~pic_dgemv~~CallsGraph proc~pic_dgemv pic_dgemv interface~blas_gemv blas_gemv proc~pic_dgemv->interface~blas_gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dgemv~~CalledByGraph proc~pic_dgemv pic_dgemv interface~pic_gemv pic_gemv interface~pic_gemv->proc~pic_dgemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy real(kind=dp), private :: l_alpha real(kind=dp), private :: l_beta character(len=1), private :: l_trans_a integer(kind=default_int), private :: lda integer(kind=default_int), private :: m integer(kind=default_int), private :: n Source Code pure subroutine pic_dgemv ( A , x , y , trans_a , alpha , beta ) !! interface for double precision matrix-vector multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta real ( dp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_dgemv","tags":"","url":"proc/pic_dgemv.html"},{"title":"pic_dscal – PIC","text":"private  subroutine pic_dscal(x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha Calls proc~~pic_dscal~~CallsGraph proc~pic_dscal pic_dscal interface~blas_scal blas_scal proc~pic_dscal->interface~blas_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_dscal~~CalledByGraph proc~pic_dscal pic_dscal interface~pic_scal pic_scal interface~pic_scal->proc~pic_dscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx real(kind=dp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_dscal ( x , alpha ) !! interface for double precision scaling real ( dp ), intent ( inout ) :: x (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_dscal","tags":"","url":"proc/pic_dscal.html"},{"title":"pic_saxpy – PIC","text":"private  subroutine pic_saxpy(x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha Calls proc~~pic_saxpy~~CallsGraph proc~pic_saxpy pic_saxpy interface~blas_axpy blas_axpy proc~pic_saxpy->interface~blas_axpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_saxpy~~CalledByGraph proc~pic_saxpy pic_saxpy interface~pic_axpy pic_axpy interface~pic_axpy->proc~pic_saxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy real(kind=sp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_saxpy ( x , y , alpha ) !! interface for single precision AXPY real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_saxpy","tags":"","url":"proc/pic_saxpy.html"},{"title":"pic_scopy – PIC","text":"private  subroutine pic_scopy(x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) Calls proc~~pic_scopy~~CallsGraph proc~pic_scopy pic_scopy interface~blas_copy blas_copy proc~pic_scopy->interface~blas_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_scopy~~CalledByGraph proc~pic_scopy pic_scopy interface~pic_copy pic_copy interface~pic_copy->proc~pic_scopy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code subroutine pic_scopy ( x , y ) !! interface for single precision copy real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_scopy","tags":"","url":"proc/pic_scopy.html"},{"title":"pic_sgemm – PIC","text":"private pure subroutine pic_sgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta Calls proc~~pic_sgemm~~CallsGraph proc~pic_sgemm pic_sgemm interface~blas_gemm blas_gemm proc~pic_sgemm->interface~blas_gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_sgemm~~CalledByGraph proc~pic_sgemm pic_sgemm interface~pic_gemm pic_gemm interface~pic_gemm->proc~pic_sgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: OP_A character(len=1), private :: OP_B integer(kind=default_int), private :: k real(kind=sp), private :: l_alpha real(kind=sp), private :: l_beta integer(kind=default_int), private :: lda integer(kind=default_int), private :: ldb integer(kind=default_int), private :: ldc integer(kind=default_int), private :: m integer(kind=default_int), private :: n Source Code pure subroutine pic_sgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: B (:, :) real ( sp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( sp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_sgemm","tags":"","url":"proc/pic_sgemm.html"},{"title":"pic_sgemv – PIC","text":"private pure subroutine pic_sgemv(A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta Calls proc~~pic_sgemv~~CallsGraph proc~pic_sgemv pic_sgemv interface~blas_gemv blas_gemv proc~pic_sgemv->interface~blas_gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_sgemv~~CalledByGraph proc~pic_sgemv pic_sgemv interface~pic_gemv pic_gemv interface~pic_gemv->proc~pic_sgemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy real(kind=sp), private :: l_alpha real(kind=sp), private :: l_beta character(len=1), private :: l_trans_a integer(kind=default_int), private :: lda integer(kind=default_int), private :: m integer(kind=default_int), private :: n Source Code pure subroutine pic_sgemv ( A , x , y , trans_a , alpha , beta ) !! interface for single precision matrix-vector multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta real ( sp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_sgemv","tags":"","url":"proc/pic_sgemv.html"},{"title":"pic_sscal – PIC","text":"private  subroutine pic_sscal(x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha Calls proc~~pic_sscal~~CallsGraph proc~pic_sscal pic_sscal interface~blas_scal blas_scal proc~pic_sscal->interface~blas_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_sscal~~CalledByGraph proc~pic_sscal pic_sscal interface~pic_scal pic_scal interface~pic_scal->proc~pic_sscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx real(kind=sp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_sscal ( x , alpha ) !! interface for single precision scaling real ( sp ), intent ( inout ) :: x (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_sscal","tags":"","url":"proc/pic_sscal.html"},{"title":"pic_zaxpy – PIC","text":"private  subroutine pic_zaxpy(x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha Calls proc~~pic_zaxpy~~CallsGraph proc~pic_zaxpy pic_zaxpy interface~blas_axpy blas_axpy proc~pic_zaxpy->interface~blas_axpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_zaxpy~~CalledByGraph proc~pic_zaxpy pic_zaxpy interface~pic_axpy pic_axpy interface~pic_axpy->proc~pic_zaxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy complex(kind=dp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_zaxpy ( x , y , alpha ) !! interface for double precision complex AXPY complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_zaxpy","tags":"","url":"proc/pic_zaxpy.html"},{"title":"pic_zcopy – PIC","text":"private  subroutine pic_zcopy(x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) Calls proc~~pic_zcopy~~CallsGraph proc~pic_zcopy pic_zcopy interface~blas_copy blas_copy proc~pic_zcopy->interface~blas_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_zcopy~~CalledByGraph proc~pic_zcopy pic_zcopy interface~pic_copy pic_copy interface~pic_copy->proc~pic_zcopy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx integer(kind=default_int), private :: incy integer(kind=default_int), private :: n Source Code subroutine pic_zcopy ( x , y ) !! interface for double precision complex copy complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_zcopy","tags":"","url":"proc/pic_zcopy.html"},{"title":"pic_zgemm – PIC","text":"private pure subroutine pic_zgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta Calls proc~~pic_zgemm~~CallsGraph proc~pic_zgemm pic_zgemm interface~blas_gemm blas_gemm proc~pic_zgemm->interface~blas_gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_zgemm~~CalledByGraph proc~pic_zgemm pic_zgemm interface~pic_gemm pic_gemm interface~pic_gemm->proc~pic_zgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: OP_A character(len=1), private :: OP_B integer(kind=default_int), private :: k complex(kind=dp), private :: l_alpha complex(kind=dp), private :: l_beta integer(kind=default_int), private :: lda integer(kind=default_int), private :: ldb integer(kind=default_int), private :: ldc integer(kind=default_int), private :: m integer(kind=default_int), private :: n Source Code pure subroutine pic_zgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication complex ( dp ), intent ( in ) :: A (:, :) complex ( dp ), intent ( in ) :: B (:, :) complex ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb complex ( dp ), intent ( in ), optional :: alpha complex ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B complex ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_zgemm","tags":"","url":"proc/pic_zgemm.html"},{"title":"pic_zscal – PIC","text":"private  subroutine pic_zscal(x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha Calls proc~~pic_zscal~~CallsGraph proc~pic_zscal pic_zscal interface~blas_scal blas_scal proc~pic_zscal->interface~blas_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~pic_zscal~~CalledByGraph proc~pic_zscal pic_zscal interface~pic_scal pic_scal interface~pic_scal->proc~pic_zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: incx complex(kind=dp), private :: l_alpha integer(kind=default_int), private :: n Source Code subroutine pic_zscal ( x , alpha ) !! interface for double precision complex scaling complex ( dp ), intent ( inout ) :: x (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_zscal","tags":"","url":"proc/pic_zscal.html"},{"title":"pic_asum – PIC","text":"public interface pic_asum general interface of the BLAS ASUM routines, will call SASUM, DASUM, SCASUM, DZASUM Usage: result = pic_asum(x, incx) where x is a vector and incx is the increment, this will return the sum of the absolute values\nof the elements of x. The vector x must be an allocatable array, we deduce the shape from it.\nThe increment incx is 1 by default. Calls interface~~pic_asum~~CallsGraph interface~pic_asum pic_asum proc~pic_dasum pic_dasum interface~pic_asum->proc~pic_dasum proc~pic_dzasum pic_dzasum interface~pic_asum->proc~pic_dzasum proc~pic_sasum pic_sasum interface~pic_asum->proc~pic_sasum proc~pic_scasum pic_scasum interface~pic_asum->proc~pic_scasum interface~blas_asum blas_asum proc~pic_dasum->interface~blas_asum proc~pic_dzasum->interface~blas_asum proc~pic_sasum->interface~blas_asum proc~pic_scasum->interface~blas_asum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function pic_sasum (x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dasum (x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_scasum (x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dzasum (x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp)","tags":"","url":"interface/pic_asum.html"},{"title":"pic_axpy – PIC","text":"public interface pic_axpy general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY Usage: call pic_axpy(n, alpha, x, incx, y, incy) where n is the number of elements, alpha is the scaling factor,\nx is the input vector, incx is the increment for x, y is the output vector,\nand incy is the increment for y. The vectors x and y must be allocatable arrays, we deduce the shapes from them.\nThe increments incx and incy are 1 by default. Calls interface~~pic_axpy~~CallsGraph interface~pic_axpy pic_axpy proc~pic_caxpy pic_caxpy interface~pic_axpy->proc~pic_caxpy proc~pic_daxpy pic_daxpy interface~pic_axpy->proc~pic_daxpy proc~pic_saxpy pic_saxpy interface~pic_axpy->proc~pic_saxpy proc~pic_zaxpy pic_zaxpy interface~pic_axpy->proc~pic_zaxpy interface~blas_axpy blas_axpy proc~pic_caxpy->interface~blas_axpy proc~pic_daxpy->interface~blas_axpy proc~pic_saxpy->interface~blas_axpy proc~pic_zaxpy->interface~blas_axpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine pic_saxpy (x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_daxpy (x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_caxpy (x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zaxpy (x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"interface/pic_axpy.html"},{"title":"pic_copy – PIC","text":"public interface pic_copy general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY Usage: call pic_copy(x, y) where x is the input vector, y is the output vector.\nThe vectors x and y must be allocatable arrays, we deduce the shapes from them. Calls interface~~pic_copy~~CallsGraph interface~pic_copy pic_copy proc~pic_ccopy pic_ccopy interface~pic_copy->proc~pic_ccopy proc~pic_dcopy pic_dcopy interface~pic_copy->proc~pic_dcopy proc~pic_scopy pic_scopy interface~pic_copy->proc~pic_scopy proc~pic_zcopy pic_zcopy interface~pic_copy->proc~pic_zcopy interface~blas_copy blas_copy proc~pic_ccopy->interface~blas_copy proc~pic_dcopy->interface~blas_copy proc~pic_scopy->interface~blas_copy proc~pic_zcopy->interface~blas_copy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine pic_scopy (x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) private  subroutine pic_dcopy (x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) private  subroutine pic_ccopy (x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) private  subroutine pic_zcopy (x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:)","tags":"","url":"interface/pic_copy.html"},{"title":"pic_dot – PIC","text":"public interface pic_dot general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC Usage: result = pic_dot(x, y) where x is the input vector, y is the output vector.\nThe vectors x and y must be allocatable arrays, we deduce the shapes from them. Calls interface~~pic_dot~~CallsGraph interface~pic_dot pic_dot proc~pic_cdotc pic_cdotc interface~pic_dot->proc~pic_cdotc proc~pic_ddot pic_ddot interface~pic_dot->proc~pic_ddot proc~pic_sdot pic_sdot interface~pic_dot->proc~pic_sdot proc~pic_zdotc pic_zdotc interface~pic_dot->proc~pic_zdotc interface~blas_dot blas_dot proc~pic_cdotc->interface~blas_dot proc~pic_ddot->interface~blas_dot proc~pic_sdot->interface~blas_dot proc~pic_zdotc->interface~blas_dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function pic_sdot (x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) private  function pic_ddot (x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) private  function pic_cdotc (x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) private  function pic_zdotc (x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp)","tags":"","url":"interface/pic_dot.html"},{"title":"pic_gemm – PIC","text":"public interface pic_gemm general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, CGEMM, ZGEMM Usage: call pic_gemm(A, B, C, [optional] transa, [optional] transb, [optional] alpha, [optional] beta) where A, B, C are matrices, transa and transb are optional transpose options,\nalpha and beta are optional scaling factors By default, if not specified transA and transB are “N” (no transpose),\nand alpha and beta are 1.0 and 0.0 respectively. The matrices A, B, C must be allocatable arrays, we deduce the shapes from them. Calls interface~~pic_gemm~~CallsGraph interface~pic_gemm pic_gemm proc~pic_dgemm pic_dgemm interface~pic_gemm->proc~pic_dgemm proc~pic_sgemm pic_sgemm interface~pic_gemm->proc~pic_sgemm proc~pic_zgemm pic_zgemm interface~pic_gemm->proc~pic_zgemm interface~blas_gemm blas_gemm proc~pic_dgemm->interface~blas_gemm proc~pic_sgemm->interface~blas_gemm proc~pic_zgemm->interface~blas_gemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine pic_sgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private pure subroutine pic_zgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta","tags":"","url":"interface/pic_gemm.html"},{"title":"pic_gemv – PIC","text":"public interface pic_gemv general interface of the BLAS GEMV routines, will call SGEMV, DGEMV, CGEMV, ZGEMV Usage: call pic_gemv(A, x, y, [optional] transa, [optional] alpha, [optional] beta) where A is a matrix, x and y are vectors, transa is an optional transpose option,\nalpha and beta are optional scaling factors. The matrix A must be an allocatable array, we deduce the shapes from it.\nTransA is “N” (no transpose) by default. And alpha and beta are 1.0 and 0.0 respectively. Calls interface~~pic_gemv~~CallsGraph interface~pic_gemv pic_gemv proc~pic_dgemv pic_dgemv interface~pic_gemv->proc~pic_dgemv proc~pic_sgemv pic_sgemv interface~pic_gemv->proc~pic_sgemv interface~blas_gemv blas_gemv proc~pic_dgemv->interface~blas_gemv proc~pic_sgemv->interface~blas_gemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure subroutine pic_sgemv (A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemv (A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta","tags":"","url":"interface/pic_gemv.html"},{"title":"pic_iamax – PIC","text":"public interface pic_iamax general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX Usage: idx = pic_iamax(x, incx) where x is the input vector, incx is the increment.\nThe vector x must be an allocatable array, we deduce the shape from it.\nThe increment incx is 1 by default. Calls interface~~pic_iamax~~CallsGraph interface~pic_iamax pic_iamax proc~pic_icamax pic_icamax interface~pic_iamax->proc~pic_icamax proc~pic_idamax pic_idamax interface~pic_iamax->proc~pic_idamax proc~pic_isamax pic_isamax interface~pic_iamax->proc~pic_isamax proc~pic_izamax pic_izamax interface~pic_iamax->proc~pic_izamax interface~blas_iamax blas_iamax proc~pic_icamax->interface~blas_iamax proc~pic_idamax->interface~blas_iamax proc~pic_isamax->interface~blas_iamax proc~pic_izamax->interface~blas_iamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function pic_isamax (x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_idamax (x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_icamax (x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_izamax (x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int)","tags":"","url":"interface/pic_iamax.html"},{"title":"pic_scal – PIC","text":"public interface pic_scal general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL Usage: call pic_scal(x, [optional] alpha) where x is the input vector, alpha is the scaling factor.\nThe vector x must be an allocatable array, we deduce the shape from it.\nThe scaling factor alpha is 1.0 by default. Calls interface~~pic_scal~~CallsGraph interface~pic_scal pic_scal proc~pic_cscal pic_cscal interface~pic_scal->proc~pic_cscal proc~pic_dscal pic_dscal interface~pic_scal->proc~pic_dscal proc~pic_sscal pic_sscal interface~pic_scal->proc~pic_sscal proc~pic_zscal pic_zscal interface~pic_scal->proc~pic_zscal interface~blas_scal blas_scal proc~pic_cscal->interface~blas_scal proc~pic_dscal->interface~blas_scal proc~pic_sscal->interface~blas_scal proc~pic_zscal->interface~blas_scal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine pic_sscal (x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_dscal (x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_cscal (x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zscal (x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"interface/pic_scal.html"},{"title":"blas_asum – PIC","text":"private interface blas_asum this is the interface for the BLAS ASUM routines, it will call SASUM, DASUM, SCASUM, DZASUM\nUsage: result = blas_asum(x, incx)\nwhere x is the input vector, incx is the increment. This is not a public interface, it is used internally by pic_asum Called by interface~~blas_asum~~CalledByGraph interface~blas_asum blas_asum proc~pic_dasum pic_dasum proc~pic_dasum->interface~blas_asum proc~pic_dzasum pic_dzasum proc~pic_dzasum->interface~blas_asum proc~pic_sasum pic_sasum proc~pic_sasum->interface~blas_asum proc~pic_scasum pic_scasum proc~pic_scasum->interface~blas_asum interface~pic_asum pic_asum interface~pic_asum->proc~pic_dasum interface~pic_asum->proc~pic_dzasum interface~pic_asum->proc~pic_sasum interface~pic_asum->proc~pic_scasum Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function dasum(n, x, incx) result(res_dasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function dzasum(n, x, incx) result(res_dzasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function sasum(n, x, incx) result(res_sasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) private pure function scasum(n, x, incx) result(res_scasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp)","tags":"","url":"interface/blas_asum.html"},{"title":"blas_axpy – PIC","text":"private interface blas_axpy explicit interface for BLAS AXPY routines Usage: call blas_axpy(n, alpha, x, incx, y, incy) This is not a public interface, it is used internally by pic_axpy Called by interface~~blas_axpy~~CalledByGraph interface~blas_axpy blas_axpy proc~pic_caxpy pic_caxpy proc~pic_caxpy->interface~blas_axpy proc~pic_daxpy pic_daxpy proc~pic_daxpy->interface~blas_axpy proc~pic_saxpy pic_saxpy proc~pic_saxpy->interface~blas_axpy proc~pic_zaxpy pic_zaxpy proc~pic_zaxpy->interface~blas_axpy interface~pic_axpy pic_axpy interface~pic_axpy->proc~pic_caxpy interface~pic_axpy->proc~pic_daxpy interface~pic_axpy->proc~pic_saxpy interface~pic_axpy->proc~pic_zaxpy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine caxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine daxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine saxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zaxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_axpy.html"},{"title":"blas_copy – PIC","text":"private interface blas_copy explicit interface for BLAS COPY routines Usage: call blas_copy(x, y) This is not a public interface, it is used internally by pic_copy Called by interface~~blas_copy~~CalledByGraph interface~blas_copy blas_copy proc~pic_ccopy pic_ccopy proc~pic_ccopy->interface~blas_copy proc~pic_dcopy pic_dcopy proc~pic_dcopy->interface~blas_copy proc~pic_scopy pic_scopy proc~pic_scopy->interface~blas_copy proc~pic_zcopy pic_zcopy proc~pic_zcopy->interface~blas_copy interface~pic_copy pic_copy interface~pic_copy->proc~pic_ccopy interface~pic_copy->proc~pic_dcopy interface~pic_copy->proc~pic_scopy interface~pic_copy->proc~pic_zcopy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_copy.html"},{"title":"blas_dot – PIC","text":"private interface blas_dot explicit interface for BLAS DOT routines Usage: result = blas_dot(x, y, incx, incy, n)\nThis is not a public interface, it is used internally by pic_dot Called by interface~~blas_dot~~CalledByGraph interface~blas_dot blas_dot proc~pic_cdotc pic_cdotc proc~pic_cdotc->interface~blas_dot proc~pic_ddot pic_ddot proc~pic_ddot->interface~blas_dot proc~pic_sdot pic_sdot proc~pic_sdot->interface~blas_dot proc~pic_zdotc pic_zdotc proc~pic_zdotc->interface~blas_dot interface~pic_dot pic_dot interface~pic_dot->proc~pic_cdotc interface~pic_dot->proc~pic_ddot interface~pic_dot->proc~pic_sdot interface~pic_dot->proc~pic_zdotc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function cdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=sp) private pure function ddot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=dp) private pure function sdot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=sp) private pure function zdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=dp)","tags":"","url":"interface/blas_dot.html"},{"title":"blas_gemm – PIC","text":"private interface blas_gemm explicit interface for BLAS GEMM routines Usage: call blas_gemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) This is not a public interface, it is used internally by pic_gemm Called by interface~~blas_gemm~~CalledByGraph interface~blas_gemm blas_gemm proc~pic_dgemm pic_dgemm proc~pic_dgemm->interface~blas_gemm proc~pic_sgemm pic_sgemm proc~pic_sgemm->interface~blas_gemm proc~pic_zgemm pic_zgemm proc~pic_zgemm->interface~blas_gemm interface~pic_gemm pic_gemm interface~pic_gemm->proc~pic_dgemm interface~pic_gemm->proc~pic_sgemm interface~pic_gemm->proc~pic_zgemm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc","tags":"","url":"interface/blas_gemm.html"},{"title":"blas_gemv – PIC","text":"private interface blas_gemv explicit interface for BLAS GEMV routines Usage: call blas_gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) This is not a public interface, it is used internally by pic_gemv Called by interface~~blas_gemv~~CalledByGraph interface~blas_gemv blas_gemv proc~pic_dgemv pic_dgemv proc~pic_dgemv->interface~blas_gemv proc~pic_sgemv pic_sgemv proc~pic_sgemv->interface~blas_gemv interface~pic_gemv pic_gemv interface~pic_gemv->proc~pic_dgemv interface~pic_gemv->proc~pic_sgemv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_gemv.html"},{"title":"blas_iamax – PIC","text":"private interface blas_iamax explicit interface for BLAS IAMAX routines Usage: idx = blas_iamax(x, incx) This is not a public interface, it is used internally by pic_iamax Called by interface~~blas_iamax~~CalledByGraph interface~blas_iamax blas_iamax proc~pic_icamax pic_icamax proc~pic_icamax->interface~blas_iamax proc~pic_idamax pic_idamax proc~pic_idamax->interface~blas_iamax proc~pic_isamax pic_isamax proc~pic_isamax->interface~blas_iamax proc~pic_izamax pic_izamax proc~pic_izamax->interface~blas_iamax interface~pic_iamax pic_iamax interface~pic_iamax->proc~pic_icamax interface~pic_iamax->proc~pic_idamax interface~pic_iamax->proc~pic_isamax interface~pic_iamax->proc~pic_izamax Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions private pure function icamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function idamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function isamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function izamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int)","tags":"","url":"interface/blas_iamax.html"},{"title":"blas_scal – PIC","text":"private interface blas_scal explicit interface for BLAS SCAL routines Usage: call blas_scal(n, alpha, x, incx) This is not a public interface, it is used internally by pic_scal Called by interface~~blas_scal~~CalledByGraph interface~blas_scal blas_scal proc~pic_cscal pic_cscal proc~pic_cscal->interface~blas_scal proc~pic_dscal pic_dscal proc~pic_dscal->interface~blas_scal proc~pic_sscal pic_sscal proc~pic_sscal->interface~blas_scal proc~pic_zscal pic_zscal proc~pic_zscal->interface~blas_scal interface~pic_scal pic_scal interface~pic_scal->proc~pic_cscal interface~pic_scal->proc~pic_dscal interface~pic_scal->proc~pic_sscal interface~pic_scal->proc~pic_zscal Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines private pure subroutine cscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine dscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine sscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine zscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx","tags":"","url":"interface/blas_scal.html"},{"title":"get_precision – PIC","text":"public  function get_precision() result(precision) Get the current precision for real numbers Arguments None Return Value integer(kind=default_int) Source Code function get_precision () result ( precision ) !! Get the current precision for real numbers integer ( default_int ) :: precision precision = dp_precision end function get_precision","tags":"","url":"proc/get_precision.html"},{"title":"pad – PIC","text":"public  function pad(s, width) result(padded) function to pad a string with a certain number of characters for nice printing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer(kind=default_int), intent(in) :: width Return Value character(len=:), allocatable Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: len_s Source Code function pad ( s , width ) result ( padded ) !! function to pad a string with a certain number of characters for nice printing character ( len =* ), intent ( in ) :: s integer ( default_int ), intent ( in ) :: width character ( len = :), allocatable :: padded integer ( default_int ) :: len_s len_s = len_trim ( s ) if ( len_s >= width ) then padded = s ( 1 : width ) else padded = repeat ( \" \" , width - len_s ) // s end if end function pad","tags":"","url":"proc/pad.html"},{"title":"to_upper – PIC","text":"public  function to_upper(str) result(upper_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) Variables Type Visibility Attributes Name Initial character(len=1), private :: ch integer(kind=default_int), private :: i Source Code function to_upper ( str ) result ( upper_str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: upper_str integer ( default_int ) :: i character :: ch do i = 1 , len ( str ) ch = str ( i : i ) if ( ch >= 'a' . and . ch <= 'z' ) then upper_str ( i : i ) = char ( iachar ( ch ) - 32 ) else upper_str ( i : i ) = ch end if end do end function to_upper","tags":"","url":"proc/to_upper.html"},{"title":"to_string_char – PIC","text":"private  function to_string_char(c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable Called by proc~~to_string_char~~CalledByGraph proc~to_string_char to_string_char interface~to_string to_string interface~to_string->proc~to_string_char proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=500), private :: str Source Code function to_string_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_string_char","tags":"","url":"proc/to_string_char.html"},{"title":"to_string_dp – PIC","text":"private  function to_string_dp(r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable Called by proc~~to_string_dp~~CalledByGraph proc~to_string_dp to_string_dp interface~to_string to_string interface~to_string->proc~to_string_dp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str character(len=32), private :: style Source Code function to_string_dp ( r ) result ( trimmed_str ) !! transform a real(dp) to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_string_dp","tags":"","url":"proc/to_string_dp.html"},{"title":"to_string_int32 – PIC","text":"private  function to_string_int32(i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable Called by proc~~to_string_int32~~CalledByGraph proc~to_string_int32 to_string_int32 interface~to_string to_string interface~to_string->proc~to_string_int32 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str Source Code function to_string_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int32","tags":"","url":"proc/to_string_int32.html"},{"title":"to_string_int64 – PIC","text":"private  function to_string_int64(i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable Called by proc~~to_string_int64~~CalledByGraph proc~to_string_int64 to_string_int64 interface~to_string to_string interface~to_string->proc~to_string_int64 proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str Source Code function to_string_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int64","tags":"","url":"proc/to_string_int64.html"},{"title":"to_string_logical – PIC","text":"private  function to_string_logical(l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable Called by proc~~to_string_logical~~CalledByGraph proc~to_string_logical to_string_logical interface~to_string to_string interface~to_string->proc~to_string_logical proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=5), private :: str Source Code function to_string_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = \"TRUE\" else str = \"FALSE\" end if trimmed_str = trim ( str ) end function to_string_logical","tags":"","url":"proc/to_string_logical.html"},{"title":"to_string_sp – PIC","text":"private  function to_string_sp(r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable Called by proc~~to_string_sp~~CalledByGraph proc~to_string_sp to_string_sp interface~to_string to_string interface~to_string->proc~to_string_sp proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=50), private :: str character(len=32), private :: style Source Code function to_string_sp ( r ) result ( trimmed_str ) !! transform a real(sp) to a string real ( kind = sp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_string_sp","tags":"","url":"proc/to_string_sp.html"},{"title":"set_precision – PIC","text":"public  subroutine set_precision(precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision Source Code subroutine set_precision ( precision ) !! Set the precision for real numbers integer ( default_int ), intent ( in ) :: precision if ( precision > 0 ) then dp_precision = precision else print * , \"Warning: Precision must be positive. Using default.\" dp_precision = default_dp_precision end if end subroutine set_precision","tags":"","url":"proc/set_precision.html"},{"title":"to_string – PIC","text":"public interface to_string converts a variable of type (int32, int64, sp, dp, char, logical)\nto a “string” which is just a collecting of chars. Usage result = to_string(variable) Note the functions here are not elemental so they won’t work for\narrays. Please use pic_print_array_v2 module for this Calls interface~~to_string~~CallsGraph interface~to_string to_string proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~to_string~~CalledByGraph interface~to_string to_string proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->interface~to_string proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->interface~to_string proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->interface~to_string proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->interface~to_string proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp print_vector_dp proc~print_vector_dp->interface~to_string proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->interface~to_string proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->interface~to_string proc~print_vector_sp print_vector_sp proc~print_vector_sp->interface~to_string proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->interface~to_string interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable","tags":"","url":"interface/to_string.html"},{"title":"get_precision – PIC","text":"private interface get_precision Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result Module Procedures private  interface get_precision () Obtain the current precision being used to print variables to strings Read more… Arguments None","tags":"","url":"interface/get_precision.html"},{"title":"pad – PIC","text":"private interface pad adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) Module Procedures private  interface pad () adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Read more… Arguments None","tags":"","url":"interface/pad.html"},{"title":"set_precision – PIC","text":"private interface set_precision This routine overrides the default dp precision used for\nprinting strings in the to_string function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Usage: call set_precision(variable) where variable is default_int Module Procedures private  interface set_precision () This routine overrides the default dp precision used for\nprinting strings in the to_string function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Read more… Arguments None","tags":"","url":"interface/set_precision.html"},{"title":"to_upper – PIC","text":"private interface to_upper takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) Module Procedures private  interface to_upper () takes a character variable and transforms it to uppercase Read more… Arguments None","tags":"","url":"interface/to_upper.html"},{"title":"print_asterisk_row – PIC","text":"public  subroutine print_asterisk_row(n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i Source Code subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row","tags":"","url":"proc/print_asterisk_row.html"},{"title":"is_equal_dp – PIC","text":"private elemental function is_equal_dp(a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical Called by proc~~is_equal_dp~~CalledByGraph proc~is_equal_dp is_equal_dp interface~is_equal is_equal interface~is_equal->proc~is_equal_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function is_equal_dp ( a , b ) result ( res ) real ( dp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_dp end function is_equal_dp","tags":"","url":"proc/is_equal_dp.html"},{"title":"is_equal_sp – PIC","text":"private elemental function is_equal_sp(a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical Called by proc~~is_equal_sp~~CalledByGraph proc~is_equal_sp is_equal_sp interface~is_equal is_equal interface~is_equal->proc~is_equal_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code elemental function is_equal_sp ( a , b ) result ( res ) real ( sp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_sp end function is_equal_sp","tags":"","url":"proc/is_equal_sp.html"},{"title":"dummy_work – PIC","text":"public  subroutine dummy_work() this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely Usage: call dummy_work() it will simply do a 256 by 256 dgemm, woo Arguments None Variables Type Visibility Attributes Name Initial real(kind=dp), private, allocatable :: A (:,:) real(kind=dp), private, allocatable :: B (:,:) real(kind=dp), private, allocatable :: C (:,:) integer(kind=int64), private :: i integer(kind=int64), private :: j integer(kind=int64), private :: k integer(kind=default_int), private :: m Source Code subroutine dummy_work () !! this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely !! !! Usage: call dummy_work() !! !! it will simply do a 256 by 256 dgemm, woo integer ( int64 ) :: i , j , k integer ( default_int ) :: m real ( dp ), allocatable :: A (:, :), B (:, :), C (:, :) m = 256_default_int allocate ( A ( m , m ), B ( m , m ), C ( m , m )) A = 1.0_dp B = 1.0_dp C = 0.0_dp do i = 1 , m do j = 1 , m do k = 1 , m C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do print * , C ( 1 , 1 ) deallocate ( A , B , C ) end subroutine dummy_work","tags":"","url":"proc/dummy_work.html"},{"title":"is_equal – PIC","text":"public interface is_equal The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about\ncomparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that\nthe two reals are exactly equal due to floating point precision issues. The functions are defined as elemental Usage: if (is_equal(a, b)) then\nwhere a and b are real numbers, and the function will return true if they are\nequal within the tolerance defined in pic_global_definitions. Calls interface~~is_equal~~CallsGraph interface~is_equal is_equal proc~is_equal_dp is_equal_dp interface~is_equal->proc~is_equal_dp proc~is_equal_sp is_equal_sp interface~is_equal->proc~is_equal_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical","tags":"","url":"interface/is_equal.html"},{"title":"get_threading_mode – PIC","text":"public  function get_threading_mode() result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical Source Code function get_threading_mode () result ( mode ) !! get the current threading mode for the array routines !! Usage: mode = get_threading_mode() logical :: mode mode = use_threaded_default end function get_threading_mode","tags":"","url":"proc/get_threading_mode.html"},{"title":"is_sorted_dp – PIC","text":"private pure function is_sorted_dp(array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Called by proc~~is_sorted_dp~~CalledByGraph proc~is_sorted_dp is_sorted_dp interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_dp ( array , order ) result ( sorted ) real ( dp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_dp","tags":"","url":"proc/is_sorted_dp.html"},{"title":"is_sorted_int32 – PIC","text":"private pure function is_sorted_int32(array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Called by proc~~is_sorted_int32~~CalledByGraph proc~is_sorted_int32 is_sorted_int32 interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_int32 ( array , order ) result ( sorted ) integer ( int32 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int32","tags":"","url":"proc/is_sorted_int32.html"},{"title":"is_sorted_int64 – PIC","text":"private pure function is_sorted_int64(array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Called by proc~~is_sorted_int64~~CalledByGraph proc~is_sorted_int64 is_sorted_int64 interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_int64 ( array , order ) result ( sorted ) integer ( int64 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int64","tags":"","url":"proc/is_sorted_int64.html"},{"title":"is_sorted_sp – PIC","text":"private pure function is_sorted_sp(array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical Called by proc~~is_sorted_sp~~CalledByGraph proc~is_sorted_sp is_sorted_sp interface~is_sorted is_sorted interface~is_sorted->proc~is_sorted_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i integer(kind=default_int), private :: sort_order Source Code pure function is_sorted_sp ( array , order ) result ( sorted ) real ( sp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_sp","tags":"","url":"proc/is_sorted_sp.html"},{"title":"sum_matrix_dp – PIC","text":"private  function sum_matrix_dp(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) Called by proc~~sum_matrix_dp~~CalledByGraph proc~sum_matrix_dp sum_matrix_dp interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_dp ( matrix , threaded ) result ( res ) real ( dp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_dp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_dp","tags":"","url":"proc/sum_matrix_dp.html"},{"title":"sum_matrix_int32 – PIC","text":"private  function sum_matrix_int32(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) Called by proc~~sum_matrix_int32~~CalledByGraph proc~sum_matrix_int32 sum_matrix_int32 interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_int32 ( matrix , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int32","tags":"","url":"proc/sum_matrix_int32.html"},{"title":"sum_matrix_int64 – PIC","text":"private  function sum_matrix_int64(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) Called by proc~~sum_matrix_int64~~CalledByGraph proc~sum_matrix_int64 sum_matrix_int64 interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_int64 ( matrix , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int64","tags":"","url":"proc/sum_matrix_int64.html"},{"title":"sum_matrix_sp – PIC","text":"private  function sum_matrix_sp(matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Called by proc~~sum_matrix_sp~~CalledByGraph proc~sum_matrix_sp sum_matrix_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code function sum_matrix_sp ( matrix , threaded ) result ( res ) real ( sp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_sp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_sp","tags":"","url":"proc/sum_matrix_sp.html"},{"title":"sum_vector_dp – PIC","text":"private  function sum_vector_dp(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) Called by proc~~sum_vector_dp~~CalledByGraph proc~sum_vector_dp sum_vector_dp interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_dp ( vector , threaded ) result ( res ) real ( dp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: i res = 0_dp if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_dp","tags":"","url":"proc/sum_vector_dp.html"},{"title":"sum_vector_int32 – PIC","text":"private  function sum_vector_int32(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) Called by proc~~sum_vector_int32~~CalledByGraph proc~sum_vector_int32 sum_vector_int32 interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_int32 ( vector , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: i res = 0_int32 if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int32","tags":"","url":"proc/sum_vector_int32.html"},{"title":"sum_vector_int64 – PIC","text":"private  function sum_vector_int64(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) Called by proc~~sum_vector_int64~~CalledByGraph proc~sum_vector_int64 sum_vector_int64 interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_int64 ( vector , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: i res = 0_int64 if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int64","tags":"","url":"proc/sum_vector_int64.html"},{"title":"sum_vector_sp – PIC","text":"private  function sum_vector_sp(vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Called by proc~~sum_vector_sp~~CalledByGraph proc~sum_vector_sp sum_vector_sp interface~pic_sum pic_sum interface~pic_sum->proc~sum_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code function sum_vector_sp ( vector , threaded ) result ( res ) real ( sp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: i res = 0_sp if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_sp","tags":"","url":"proc/sum_vector_sp.html"},{"title":"set_threading_mode – PIC","text":"public  subroutine set_threading_mode(threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Usage: call set_threading(.true.) or call set_threading(.false.) Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded Source Code subroutine set_threading_mode ( threaded ) !! set the threading mode for the array routines, this will set the use_threaded variable !! to true or false depending on the input !! !! Usage: call set_threading(.true.) or call set_threading(.false.) logical , intent ( in ) :: threaded use_threaded_default = threaded end subroutine set_threading_mode","tags":"","url":"proc/set_threading_mode.html"},{"title":"copy_matrix_dp – PIC","text":"private  subroutine copy_matrix_dp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Called by proc~~copy_matrix_dp~~CalledByGraph proc~copy_matrix_dp copy_matrix_dp interface~copy copy interface~copy->proc~copy_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :) real ( dp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_dp","tags":"","url":"proc/copy_matrix_dp.html"},{"title":"copy_matrix_int32 – PIC","text":"private  subroutine copy_matrix_int32(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Called by proc~~copy_matrix_int32~~CalledByGraph proc~copy_matrix_int32 copy_matrix_int32 interface~copy copy interface~copy->proc~copy_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :) integer ( int32 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int32","tags":"","url":"proc/copy_matrix_int32.html"},{"title":"copy_matrix_int64 – PIC","text":"private  subroutine copy_matrix_int64(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Called by proc~~copy_matrix_int64~~CalledByGraph proc~copy_matrix_int64 copy_matrix_int64 interface~copy copy interface~copy->proc~copy_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :) integer ( int64 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int64","tags":"","url":"proc/copy_matrix_int64.html"},{"title":"copy_matrix_sp – PIC","text":"private  subroutine copy_matrix_sp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded Called by proc~~copy_matrix_sp~~CalledByGraph proc~copy_matrix_sp copy_matrix_sp interface~copy copy interface~copy->proc~copy_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine copy_matrix_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :) real ( sp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_sp","tags":"","url":"proc/copy_matrix_sp.html"},{"title":"copy_vector_dp – PIC","text":"private  subroutine copy_vector_dp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded Called by proc~~copy_vector_dp~~CalledByGraph proc~copy_vector_dp copy_vector_dp interface~copy copy interface~copy->proc~copy_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:) real ( dp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_dp","tags":"","url":"proc/copy_vector_dp.html"},{"title":"copy_vector_int32 – PIC","text":"private  subroutine copy_vector_int32(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded Called by proc~~copy_vector_int32~~CalledByGraph proc~copy_vector_int32 copy_vector_int32 interface~copy copy interface~copy->proc~copy_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:) integer ( int32 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int32","tags":"","url":"proc/copy_vector_int32.html"},{"title":"copy_vector_int64 – PIC","text":"private  subroutine copy_vector_int64(dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded Called by proc~~copy_vector_int64~~CalledByGraph proc~copy_vector_int64 copy_vector_int64 interface~copy copy interface~copy->proc~copy_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:) integer ( int64 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int64","tags":"","url":"proc/copy_vector_int64.html"},{"title":"copy_vector_sp – PIC","text":"private  subroutine copy_vector_sp(dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded Called by proc~~copy_vector_sp~~CalledByGraph proc~copy_vector_sp copy_vector_sp interface~copy copy interface~copy->proc~copy_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine copy_vector_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:) real ( sp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_sp","tags":"","url":"proc/copy_vector_sp.html"},{"title":"fill_matrix_dp – PIC","text":"private  subroutine fill_matrix_dp(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_matrix_dp~~CalledByGraph proc~fill_matrix_dp fill_matrix_dp interface~fill fill interface~fill->proc~fill_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_dp ( matrix , alpha , threaded ) real ( dp ), intent ( inout ) :: matrix (:, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_dp","tags":"","url":"proc/fill_matrix_dp.html"},{"title":"fill_matrix_int32 – PIC","text":"private  subroutine fill_matrix_int32(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_matrix_int32~~CalledByGraph proc~fill_matrix_int32 fill_matrix_int32 interface~fill fill interface~fill->proc~fill_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_int32 ( matrix , alpha , threaded ) integer ( int32 ), intent ( inout ) :: matrix (:, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int32","tags":"","url":"proc/fill_matrix_int32.html"},{"title":"fill_matrix_int64 – PIC","text":"private  subroutine fill_matrix_int64(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_matrix_int64~~CalledByGraph proc~fill_matrix_int64 fill_matrix_int64 interface~fill fill interface~fill->proc~fill_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_int64 ( matrix , alpha , threaded ) integer ( int64 ), intent ( inout ) :: matrix (:, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int64","tags":"","url":"proc/fill_matrix_int64.html"},{"title":"fill_matrix_sp – PIC","text":"private  subroutine fill_matrix_sp(matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_matrix_sp~~CalledByGraph proc~fill_matrix_sp fill_matrix_sp interface~fill fill interface~fill->proc~fill_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine fill_matrix_sp ( matrix , alpha , threaded ) real ( sp ), intent ( inout ) :: matrix (:, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_sp","tags":"","url":"proc/fill_matrix_sp.html"},{"title":"fill_vector_dp – PIC","text":"private  subroutine fill_vector_dp(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_vector_dp~~CalledByGraph proc~fill_vector_dp fill_vector_dp interface~fill fill interface~fill->proc~fill_vector_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_dp ( vector , alpha , threaded ) real ( dp ), intent ( inout ) :: vector (:) real ( dp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_dp","tags":"","url":"proc/fill_vector_dp.html"},{"title":"fill_vector_int32 – PIC","text":"private  subroutine fill_vector_int32(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_vector_int32~~CalledByGraph proc~fill_vector_int32 fill_vector_int32 interface~fill fill interface~fill->proc~fill_vector_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_int32 ( vector , alpha , threaded ) integer ( int32 ), intent ( inout ) :: vector (:) integer ( int32 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int32","tags":"","url":"proc/fill_vector_int32.html"},{"title":"fill_vector_int64 – PIC","text":"private  subroutine fill_vector_int64(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_vector_int64~~CalledByGraph proc~fill_vector_int64 fill_vector_int64 interface~fill fill interface~fill->proc~fill_vector_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int64","tags":"","url":"proc/fill_vector_int64.html"},{"title":"fill_vector_sp – PIC","text":"private  subroutine fill_vector_sp(vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded Called by proc~~fill_vector_sp~~CalledByGraph proc~fill_vector_sp fill_vector_sp interface~fill fill interface~fill->proc~fill_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: i logical, private :: use_threads Source Code subroutine fill_vector_sp ( vector , alpha , threaded ) real ( sp ), intent ( inout ) :: vector (:) real ( sp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_sp","tags":"","url":"proc/fill_vector_sp.html"},{"title":"transpose_matrix_dp – PIC","text":"private  subroutine transpose_matrix_dp(A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Called by proc~~transpose_matrix_dp~~CalledByGraph proc~transpose_matrix_dp transpose_matrix_dp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_dp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_dp ( A , B , threaded ) real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_dp","tags":"","url":"proc/transpose_matrix_dp.html"},{"title":"transpose_matrix_int32 – PIC","text":"private  subroutine transpose_matrix_int32(A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Called by proc~~transpose_matrix_int32~~CalledByGraph proc~transpose_matrix_int32 transpose_matrix_int32 interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_int32 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_int32 ( A , B , threaded ) integer ( int32 ), intent ( in ) :: A (:, :) integer ( int32 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int32","tags":"","url":"proc/transpose_matrix_int32.html"},{"title":"transpose_matrix_int64 – PIC","text":"private  subroutine transpose_matrix_int64(A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Called by proc~~transpose_matrix_int64~~CalledByGraph proc~transpose_matrix_int64 transpose_matrix_int64 interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_int64 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_int64 ( A , B , threaded ) integer ( int64 ), intent ( in ) :: A (:, :) integer ( int64 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int64","tags":"","url":"proc/transpose_matrix_int64.html"},{"title":"transpose_matrix_sp – PIC","text":"private  subroutine transpose_matrix_sp(A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded Called by proc~~transpose_matrix_sp~~CalledByGraph proc~transpose_matrix_sp transpose_matrix_sp interface~pic_transpose pic_transpose interface~pic_transpose->proc~transpose_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: cols integer(kind=default_int), private :: i integer(kind=default_int), private :: ii integer(kind=default_int), private :: j integer(kind=default_int), private :: jj integer(kind=default_int), private :: rows logical, private :: use_threads Source Code subroutine transpose_matrix_sp ( A , B , threaded ) real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_sp","tags":"","url":"proc/transpose_matrix_sp.html"},{"title":"copy – PIC","text":"public interface copy copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy\nif you built pic with BLAS use the copy interface provided there, I will not beat BLAS\ncopy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types Usage: call copy(destination, source, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism Calls interface~~copy~~CallsGraph interface~copy copy proc~copy_matrix_dp copy_matrix_dp interface~copy->proc~copy_matrix_dp proc~copy_matrix_int32 copy_matrix_int32 interface~copy->proc~copy_matrix_int32 proc~copy_matrix_int64 copy_matrix_int64 interface~copy->proc~copy_matrix_int64 proc~copy_matrix_sp copy_matrix_sp interface~copy->proc~copy_matrix_sp proc~copy_vector_dp copy_vector_dp interface~copy->proc~copy_vector_dp proc~copy_vector_int32 copy_vector_int32 interface~copy->proc~copy_vector_int32 proc~copy_vector_int64 copy_vector_int64 interface~copy->proc~copy_vector_int64 proc~copy_vector_sp copy_vector_sp interface~copy->proc~copy_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded","tags":"","url":"interface/copy.html"},{"title":"fill – PIC","text":"public interface fill fill provides a generic interface to assing a value\nalpha of types (int32, int64, sp, dp) as defined in pic_types.F90\nThe inteface supports filling 1d and 2d arrays of the specified\nvariables Usage: call fill(array, value, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism Calls interface~~fill~~CallsGraph interface~fill fill proc~fill_matrix_dp fill_matrix_dp interface~fill->proc~fill_matrix_dp proc~fill_matrix_int32 fill_matrix_int32 interface~fill->proc~fill_matrix_int32 proc~fill_matrix_int64 fill_matrix_int64 interface~fill->proc~fill_matrix_int64 proc~fill_matrix_sp fill_matrix_sp interface~fill->proc~fill_matrix_sp proc~fill_vector_dp fill_vector_dp interface~fill->proc~fill_vector_dp proc~fill_vector_int32 fill_vector_int32 interface~fill->proc~fill_vector_int32 proc~fill_vector_int64 fill_vector_int64 interface~fill->proc~fill_vector_int64 proc~fill_vector_sp fill_vector_sp interface~fill->proc~fill_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded","tags":"","url":"interface/fill.html"},{"title":"is_sorted – PIC","text":"public interface is_sorted is_sorted provides a simple way to checking if a 1d array is sorted\nit is implemented for int32, int64, sp, and dp datatypes. The default\nis to check if an array is sorted in ascending fashion. Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) Calls interface~~is_sorted~~CallsGraph interface~is_sorted is_sorted proc~is_sorted_dp is_sorted_dp interface~is_sorted->proc~is_sorted_dp proc~is_sorted_int32 is_sorted_int32 interface~is_sorted->proc~is_sorted_int32 proc~is_sorted_int64 is_sorted_int64 interface~is_sorted->proc~is_sorted_int64 proc~is_sorted_sp is_sorted_sp interface~is_sorted->proc~is_sorted_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical","tags":"","url":"interface/is_sorted.html"},{"title":"pic_sum – PIC","text":"public interface pic_sum pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will\nbe too slow for large sizes of vectors and matrices. Note that this provides the total\nsum. As opposed to the blas alternative XASUM which does the absolute sum pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays Usage: result = pic_sum(array, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism Calls interface~~pic_sum~~CallsGraph interface~pic_sum pic_sum proc~sum_matrix_dp sum_matrix_dp interface~pic_sum->proc~sum_matrix_dp proc~sum_matrix_int32 sum_matrix_int32 interface~pic_sum->proc~sum_matrix_int32 proc~sum_matrix_int64 sum_matrix_int64 interface~pic_sum->proc~sum_matrix_int64 proc~sum_matrix_sp sum_matrix_sp interface~pic_sum->proc~sum_matrix_sp proc~sum_vector_dp sum_vector_dp interface~pic_sum->proc~sum_vector_dp proc~sum_vector_int32 sum_vector_int32 interface~pic_sum->proc~sum_vector_int32 proc~sum_vector_int64 sum_vector_int64 interface~pic_sum->proc~sum_vector_int64 proc~sum_vector_sp sum_vector_sp interface~pic_sum->proc~sum_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp)","tags":"","url":"interface/pic_sum.html"},{"title":"pic_transpose – PIC","text":"public interface pic_transpose pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic\nwhich will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism Calls interface~~pic_transpose~~CallsGraph interface~pic_transpose pic_transpose proc~transpose_matrix_dp transpose_matrix_dp interface~pic_transpose->proc~transpose_matrix_dp proc~transpose_matrix_int32 transpose_matrix_int32 interface~pic_transpose->proc~transpose_matrix_int32 proc~transpose_matrix_int64 transpose_matrix_int64 interface~pic_transpose->proc~transpose_matrix_int64 proc~transpose_matrix_sp transpose_matrix_sp interface~pic_transpose->proc~transpose_matrix_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded","tags":"","url":"interface/pic_transpose.html"},{"title":"get_threading_mode – PIC","text":"private interface get_threading_mode get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() Module Procedures private  interface get_threading_mode () get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None","tags":"","url":"interface/get_threading_mode.html"},{"title":"set_threading_mode – PIC","text":"private interface set_threading_mode set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) Module Procedures private  interface set_threading_mode () set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) Arguments None","tags":"","url":"interface/set_threading_mode.html"},{"title":"get_flops – PIC","text":"private  function get_flops(self) result(flops) Get the int64 number of FLOPs we currently have in the counter Usage: flops = my_flop_recorder%get() Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) Called by proc~~get_flops~~CalledByGraph proc~get_flops flop_recorder_type%get_flops proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_get_flop_rate->proc~get_flops proc~flop_rate_get_flops flop_rate_type%flop_rate_get_flops proc~flop_rate_get_flops->proc~get_flops proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code function get_flops ( self ) result ( flops ) !! Get the int64 number of FLOPs we currently have in the counter !! !! Usage: flops = my_flop_recorder%get() !! class ( flop_recorder_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % flop_count end function get_flops","tags":"","url":"proc/get_flops.html"},{"title":"add_flops – PIC","text":"private  subroutine add_flops(self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Usage: call my_flop_recorder%add(flops) Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops Called by proc~~add_flops~~CalledByGraph proc~add_flops flop_recorder_type%add_flops proc~flop_rate_add_flops flop_rate_type%flop_rate_add_flops proc~flop_rate_add_flops->proc~add_flops Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine add_flops ( self , flops ) !! Add an int64 variable which contains the FLOPs !! we use int64 since we might reach very large FLOP counts !! !! Usage: call my_flop_recorder%add(flops) !! class ( flop_recorder_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops self % flop_count = self % flop_count + flops end subroutine add_flops","tags":"","url":"proc/add_flops.html"},{"title":"reset_flop_counter – PIC","text":"private  subroutine reset_flop_counter(self) Resets the flop counter to 0_int64 Usage: call my_flop_recorder%reset() Type Bound flop_recorder_type Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self Called by proc~~reset_flop_counter~~CalledByGraph proc~reset_flop_counter flop_recorder_type%reset_flop_counter proc~flop_rate_reset flop_rate_type%flop_rate_reset proc~flop_rate_reset->proc~reset_flop_counter Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine reset_flop_counter ( self ) !! Resets the flop counter to 0_int64 !! !! Usage: call my_flop_recorder%reset() !! class ( flop_recorder_type ), intent ( inout ) :: self self % flop_count = 0_int64 end subroutine reset_flop_counter","tags":"","url":"proc/reset_flop_counter.html"},{"title":"pic_comm_finalize – PIC","text":"private  subroutine pic_comm_finalize(self) finalize the MPI library Type Bound pic_comm_type Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self Calls proc~~pic_comm_finalize~~CallsGraph proc~pic_comm_finalize pic_comm_type%pic_comm_finalize mpi_finalize mpi_finalize proc~pic_comm_finalize->mpi_finalize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: ierr Source Code subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr call MPI_Finalize ( ierr ) self % m_ierr = ierr end subroutine pic_comm_finalize","tags":"","url":"proc/pic_comm_finalize.html"},{"title":"pic_comm_init – PIC","text":"private  subroutine pic_comm_init(self) initilalize the MPI library and get the size and rank variables Type Bound pic_comm_type Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self Calls proc~~pic_comm_init~~CallsGraph proc~pic_comm_init pic_comm_type%pic_comm_init mpi_comm_rank mpi_comm_rank proc~pic_comm_init->mpi_comm_rank mpi_comm_size mpi_comm_size proc~pic_comm_init->mpi_comm_size mpi_init mpi_init proc~pic_comm_init->mpi_init Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=int32), private :: ierr integer(kind=int32), private :: rank integer(kind=int32), private :: size Source Code subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr , rank , size call MPI_Init ( ierr ) self % m_ierr = ierr self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank end subroutine pic_comm_init","tags":"","url":"proc/pic_comm_init.html"},{"title":"get_first_arg_from_command_line – PIC","text":"public  function get_first_arg_from_command_line() result(filename) get the first argument from the command line, this is expected to be a filename Usage: filename = get_first_arg_from_command_line() Arguments None Return Value character(len=255) Variables Type Visibility Attributes Name Initial character(len=255), private :: arg integer(kind=default_int), private :: num_args Source Code function get_first_arg_from_command_line () result ( filename ) !! get the first argument from the command line, this is expected to be a filename !! !! Usage: filename = get_first_arg_from_command_line() !! character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line","tags":"","url":"proc/get_first_arg_from_command_line.html"},{"title":"pic_print_banner – PIC","text":"public  subroutine pic_print_banner() my cool banner, work in progress Arguments None Source Code subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" end subroutine pic_print_banner","tags":"","url":"proc/pic_print_banner.html"},{"title":"timer_get_elapsed_time – PIC","text":"private  function timer_get_elapsed_time(self) result(elapsed) Returns the elapsed time as a real(dp) variable Usage: var = my_timer%get_elapsed_time() Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer Type Bound pic_timer_type Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self Return Value real(kind=dp) Called by proc~~timer_get_elapsed_time~~CalledByGraph proc~timer_get_elapsed_time pic_timer_type%timer_get_elapsed_time proc~flop_rate_get_flop_rate flop_rate_type%flop_rate_get_flop_rate proc~flop_rate_get_flop_rate->proc~timer_get_elapsed_time proc~flop_rate_get_time flop_rate_type%flop_rate_get_time proc~flop_rate_get_time->proc~timer_get_elapsed_time proc~timer_print_time pic_timer_type%timer_print_time proc~timer_print_time->proc~timer_get_elapsed_time proc~flop_rate_report flop_rate_type%flop_rate_report proc~flop_rate_report->proc~flop_rate_get_flop_rate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private :: current_count Source Code function timer_get_elapsed_time ( self ) result ( elapsed ) !! Returns the elapsed time as a real(dp) variable !! !! Usage: var = my_timer%get_elapsed_time() !! !! Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer !! class ( pic_timer_type ), intent ( in ) :: self real ( dp ) :: elapsed integer ( default_int ) :: current_count elapsed = 0.0_dp #ifdef _OPENMP if ( self % is_running ) then elapsed = omp_get_wtime () - self % start_time else elapsed = self % stop_time - self % start_time end if #else if ( self % is_running ) then call system_clock ( count = current_count ) elapsed = real ( current_count - self % start_count , dp ) / real ( self % count_rate , dp ) else elapsed = real ( self % stop_count - self % start_count , dp ) / real ( self % count_rate , dp ) end if #endif end function timer_get_elapsed_time","tags":"","url":"proc/timer_get_elapsed_time.html"},{"title":"timer_print_time – PIC","text":"private  subroutine timer_print_time(self) Prints the elapsed time at the time of calling Usage: call my_timer%print_time() Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer This function does not stop the timer, it will get the current time elapsed stopped or not Type Bound pic_timer_type Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self Calls proc~~timer_print_time~~CallsGraph proc~timer_print_time pic_timer_type%timer_print_time interface~to_string to_string proc~timer_print_time->interface~to_string proc~timer_get_elapsed_time pic_timer_type%timer_get_elapsed_time proc~timer_print_time->proc~timer_get_elapsed_time proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), private :: elapsed Source Code subroutine timer_print_time ( self ) !! Prints the elapsed time at the time of calling !! !! Usage: call my_timer%print_time() !! !! Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer !! !! This function does not stop the timer, it will get the current time elapsed stopped or not class ( pic_timer_type ), intent ( in ) :: self real ( dp ) :: elapsed elapsed = self % get_elapsed_time () if ( self % is_running ) then print * , \"Currently elapsed time: \" // to_string ( elapsed ) // \" seconds\" else print * , \"Elapsed time: \" // to_string ( elapsed ) // \" seconds\" end if end subroutine timer_print_time","tags":"","url":"proc/timer_print_time.html"},{"title":"timer_start – PIC","text":"private  subroutine timer_start(self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Usage: call my_timer%start() Usage assumes a declaration of type(pic_timer_type) :: my_timer Type Bound pic_timer_type Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self Called by proc~~timer_start~~CalledByGraph proc~timer_start pic_timer_type%timer_start proc~flop_rate_start_time flop_rate_type%flop_rate_start_time proc~flop_rate_start_time->proc~timer_start Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine timer_start ( self ) !! starts the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%start() !! !! Usage assumes a declaration of type(pic_timer_type) :: my_timer class ( pic_timer_type ), intent ( inout ) :: self self % is_running = . true . #ifdef _OPENMP self % start_time = omp_get_wtime () #else call system_clock ( self % start_count , self % count_rate ) #endif end subroutine timer_start","tags":"","url":"proc/timer_start.html"},{"title":"timer_stop – PIC","text":"private  subroutine timer_stop(self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Usage: call my_timer%stop() Usage assumes a declaration of type(pic_timer_type) :: my_timer\nwill fail if a timer has not been started! Type Bound pic_timer_type Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self Source Code subroutine timer_stop ( self ) !! stop the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%stop() !! !! Usage assumes a declaration of type(pic_timer_type) :: my_timer !! will fail if a timer has not been started! class ( pic_timer_type ), intent ( inout ) :: self if (. not . self % is_running ) then error stop \"Cannot stop a timer that has not been started!\" end if #ifdef _OPENMP self % stop_time = omp_get_wtime () #else call system_clock ( self % stop_count ) #endif ! if someone stops the timer, we stop ! self % is_running = . false . end subroutine timer_stop","tags":"","url":"proc/timer_stop.html"},{"title":"print_3d_tensor_dp – PIC","text":"private  subroutine print_3d_tensor_dp(matrix, format_type) Print a 3D tensor of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_dp~~CallsGraph proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2 print_array_v2 proc~print_3d_tensor_dp->interface~print_array_v2 proc~set_brackets set_brackets proc~print_3d_tensor_dp->proc~set_brackets interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~print_array_v2->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~print_array_v2->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~print_array_v2->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~print_array_v2->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~print_array_v2->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~print_array_v2->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~print_array_v2->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~print_array_v2->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~print_array_v2->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_sp->interface~print_array_v2 proc~print_3d_tensor_sp->proc~set_brackets proc~print_matrix_dp->proc~set_brackets interface~to_string to_string proc~print_matrix_dp->interface~to_string proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_string proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_string proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_string proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_string proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_string proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_string proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_dp~~CalledByGraph proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2 print_array_v2 proc~print_3d_tensor_dp->interface~print_array_v2 interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_dp ( matrix , format_type ) !! Print a 3D tensor of dp values real ( dp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call print_array_v2 ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_dp","tags":"","url":"proc/print_3d_tensor_dp.html"},{"title":"print_3d_tensor_sp – PIC","text":"private  subroutine print_3d_tensor_sp(matrix, format_type) Print a 3D tensor of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_3d_tensor_sp~~CallsGraph proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2 print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 proc~set_brackets set_brackets proc~print_3d_tensor_sp->proc~set_brackets interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_matrix_dp print_matrix_dp interface~print_array_v2->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~print_array_v2->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~print_array_v2->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~print_array_v2->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~print_array_v2->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~print_array_v2->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~print_array_v2->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~print_array_v2->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~print_array_v2->proc~print_vector_sp to_upper to_upper proc~set_brackets->to_upper proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_dp->proc~set_brackets proc~print_matrix_dp->proc~set_brackets interface~to_string to_string proc~print_matrix_dp->interface~to_string proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int32->interface~to_string proc~print_matrix_int64->proc~set_brackets proc~print_matrix_int64->interface~to_string proc~print_matrix_sp->proc~set_brackets proc~print_matrix_sp->interface~to_string proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_sp->proc~set_brackets proc~print_packed_matrix_sp->interface~to_string proc~print_vector_dp->proc~set_brackets proc~print_vector_dp->interface~to_string proc~print_vector_int32->proc~set_brackets proc~print_vector_int32->interface~to_string proc~print_vector_int64->proc~set_brackets proc~print_vector_int64->interface~to_string proc~print_vector_sp->proc~set_brackets proc~print_vector_sp->interface~to_string proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_3d_tensor_sp~~CalledByGraph proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2 print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_dp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_3d_tensor_sp ( matrix , format_type ) !! Print a 3D tensor of sp values real ( sp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call print_array_v2 ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_sp","tags":"","url":"proc/print_3d_tensor_sp.html"},{"title":"print_matrix_dp – PIC","text":"private  subroutine print_matrix_dp(matrix, format_type) print a matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_dp~~CallsGraph proc~print_matrix_dp print_matrix_dp interface~to_string to_string proc~print_matrix_dp->interface~to_string proc~set_brackets set_brackets proc~print_matrix_dp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_dp~~CalledByGraph proc~print_matrix_dp print_matrix_dp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_dp ( matrix , format_type ) !! print a matrix of dp values real ( dp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_dp","tags":"","url":"proc/print_matrix_dp.html"},{"title":"print_matrix_int32 – PIC","text":"private  subroutine print_matrix_int32(matrix, format_type) print a matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_int32~~CallsGraph proc~print_matrix_int32 print_matrix_int32 interface~to_string to_string proc~print_matrix_int32->interface~to_string proc~set_brackets set_brackets proc~print_matrix_int32->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_int32~~CalledByGraph proc~print_matrix_int32 print_matrix_int32 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_int32 ( matrix , format_type ) !! print a matrix of int32 values integer ( int32 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int32","tags":"","url":"proc/print_matrix_int32.html"},{"title":"print_matrix_int64 – PIC","text":"private  subroutine print_matrix_int64(matrix, format_type) print a matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_int64~~CallsGraph proc~print_matrix_int64 print_matrix_int64 interface~to_string to_string proc~print_matrix_int64->interface~to_string proc~set_brackets set_brackets proc~print_matrix_int64->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_int64~~CalledByGraph proc~print_matrix_int64 print_matrix_int64 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_int64 ( matrix , format_type ) !! print a matrix of int64 values integer ( int64 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int64","tags":"","url":"proc/print_matrix_int64.html"},{"title":"print_matrix_sp – PIC","text":"private  subroutine print_matrix_sp(matrix, format_type) print a matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type Calls proc~~print_matrix_sp~~CallsGraph proc~print_matrix_sp print_matrix_sp interface~to_string to_string proc~print_matrix_sp->interface~to_string proc~set_brackets set_brackets proc~print_matrix_sp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_matrix_sp~~CalledByGraph proc~print_matrix_sp print_matrix_sp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_matrix_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_matrix_sp ( matrix , format_type ) !! print a matrix of sp values real ( sp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_sp","tags":"","url":"proc/print_matrix_sp.html"},{"title":"print_packed_matrix_dp – PIC","text":"private  subroutine print_packed_matrix_dp(packed, n_elements, format_type) Print a packed lower triangular matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_dp~~CallsGraph proc~print_packed_matrix_dp print_packed_matrix_dp interface~to_string to_string proc~print_packed_matrix_dp->interface~to_string proc~set_brackets set_brackets proc~print_packed_matrix_dp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_dp~~CalledByGraph proc~print_packed_matrix_dp print_packed_matrix_dp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_packed_matrix_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=dp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_dp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of dp values real ( dp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_dp","tags":"","url":"proc/print_packed_matrix_dp.html"},{"title":"print_packed_matrix_int32 – PIC","text":"private  subroutine print_packed_matrix_int32(packed, n_elements, format_type) Print a packed lower triangular matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_int32~~CallsGraph proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~to_string to_string proc~print_packed_matrix_int32->interface~to_string proc~set_brackets set_brackets proc~print_packed_matrix_int32->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_int32~~CalledByGraph proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_packed_matrix_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=int32), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_int32 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of int32 values integer ( int32 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( int32 ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_int32 + sqrt ( 1.0_int32 + 8.0_int32 * real ( n_elements , int32 ))) / 2.0_int32 n = int ( n_real + 0.5_int32 ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int32","tags":"","url":"proc/print_packed_matrix_int32.html"},{"title":"print_packed_matrix_int64 – PIC","text":"private  subroutine print_packed_matrix_int64(packed, n_elements, format_type) Print a packed lower triangular matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_int64~~CallsGraph proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~to_string to_string proc~print_packed_matrix_int64->interface~to_string proc~set_brackets set_brackets proc~print_packed_matrix_int64->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_int64~~CalledByGraph proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_packed_matrix_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=int64), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_int64 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of int64 values integer ( int64 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( int64 ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_int64 + sqrt ( 1.0_int64 + 8.0_int64 * real ( n_elements , int64 ))) / 2.0_int64 n = int ( n_real + 0.5_int64 ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int64","tags":"","url":"proc/print_packed_matrix_int64.html"},{"title":"print_packed_matrix_sp – PIC","text":"private  subroutine print_packed_matrix_sp(packed, n_elements, format_type) Print a packed lower triangular matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type Calls proc~~print_packed_matrix_sp~~CallsGraph proc~print_packed_matrix_sp print_packed_matrix_sp interface~to_string to_string proc~print_packed_matrix_sp->interface~to_string proc~set_brackets set_brackets proc~print_packed_matrix_sp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_packed_matrix_sp~~CalledByGraph proc~print_packed_matrix_sp print_packed_matrix_sp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_packed_matrix_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=1), private :: close_bracket integer(kind=default_int), private :: i integer(kind=default_int), private :: idx integer(kind=default_int), private :: j integer(kind=default_int), private :: n real(kind=sp), private :: n_real character(len=1), private :: open_bracket character(len=20), private :: print_format Source Code subroutine print_packed_matrix_sp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of sp values real ( sp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( sp ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_sp + sqrt ( 1.0_sp + 8.0_sp * real ( n_elements , sp ))) / 2.0_sp n = int ( n_real + 0.5_sp ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_sp","tags":"","url":"proc/print_packed_matrix_sp.html"},{"title":"print_vector_dp – PIC","text":"private  subroutine print_vector_dp(vector, format_type) print a vector of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_dp~~CallsGraph proc~print_vector_dp print_vector_dp interface~to_string to_string proc~print_vector_dp->interface~to_string proc~set_brackets set_brackets proc~print_vector_dp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_dp~~CalledByGraph proc~print_vector_dp print_vector_dp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_vector_dp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_dp ( vector , format_type ) !! print a vector of dp values real ( dp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_dp","tags":"","url":"proc/print_vector_dp.html"},{"title":"print_vector_int32 – PIC","text":"private  subroutine print_vector_int32(vector, format_type) print a vector of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_int32~~CallsGraph proc~print_vector_int32 print_vector_int32 interface~to_string to_string proc~print_vector_int32->interface~to_string proc~set_brackets set_brackets proc~print_vector_int32->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_int32~~CalledByGraph proc~print_vector_int32 print_vector_int32 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_vector_int32 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_int32 ( vector , format_type ) !! print a vector of int32 values integer ( int32 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int32","tags":"","url":"proc/print_vector_int32.html"},{"title":"print_vector_int64 – PIC","text":"private  subroutine print_vector_int64(vector, format_type) print a vector of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_int64~~CallsGraph proc~print_vector_int64 print_vector_int64 interface~to_string to_string proc~print_vector_int64->interface~to_string proc~set_brackets set_brackets proc~print_vector_int64->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_int64~~CalledByGraph proc~print_vector_int64 print_vector_int64 interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_vector_int64 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_int64 ( vector , format_type ) !! print a vector of int64 values integer ( int64 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int64 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int64","tags":"","url":"proc/print_vector_int64.html"},{"title":"print_vector_sp – PIC","text":"private  subroutine print_vector_sp(vector, format_type) print a vector of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type Calls proc~~print_vector_sp~~CallsGraph proc~print_vector_sp print_vector_sp interface~to_string to_string proc~print_vector_sp->interface~to_string proc~set_brackets set_brackets proc~print_vector_sp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~print_vector_sp~~CalledByGraph proc~print_vector_sp print_vector_sp interface~print_array_v2 print_array_v2 interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=20), private :: print_format Source Code subroutine print_vector_sp ( vector , format_type ) !! print a vector of sp values real ( sp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_sp","tags":"","url":"proc/print_vector_sp.html"},{"title":"set_brackets – PIC","text":"private  subroutine set_brackets(format_type, open_bracket, close_bracket) Set brackets based on output format type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: format_type character(len=1), intent(out) :: open_bracket character(len=1), intent(out) :: close_bracket Calls proc~~set_brackets~~CallsGraph proc~set_brackets set_brackets to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~set_brackets~~CalledByGraph proc~set_brackets set_brackets proc~print_3d_tensor_dp print_3d_tensor_dp proc~print_3d_tensor_dp->proc~set_brackets interface~print_array_v2 print_array_v2 proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp print_3d_tensor_sp proc~print_3d_tensor_sp->proc~set_brackets proc~print_3d_tensor_sp->interface~print_array_v2 proc~print_matrix_dp print_matrix_dp proc~print_matrix_dp->proc~set_brackets proc~print_matrix_int32 print_matrix_int32 proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int64 print_matrix_int64 proc~print_matrix_int64->proc~set_brackets proc~print_matrix_sp print_matrix_sp proc~print_matrix_sp->proc~set_brackets proc~print_packed_matrix_dp print_packed_matrix_dp proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_int32 print_packed_matrix_int32 proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int64 print_packed_matrix_int64 proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_sp print_packed_matrix_sp proc~print_packed_matrix_sp->proc~set_brackets proc~print_vector_dp print_vector_dp proc~print_vector_dp->proc~set_brackets proc~print_vector_int32 print_vector_int32 proc~print_vector_int32->proc~set_brackets proc~print_vector_int64 print_vector_int64 proc~print_vector_int64->proc~set_brackets proc~print_vector_sp print_vector_sp proc~print_vector_sp->proc~set_brackets interface~print_array_v2->proc~print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_sp interface~print_array_v2->proc~print_matrix_dp interface~print_array_v2->proc~print_matrix_int32 interface~print_array_v2->proc~print_matrix_int64 interface~print_array_v2->proc~print_matrix_sp interface~print_array_v2->proc~print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_sp interface~print_array_v2->proc~print_vector_dp interface~print_array_v2->proc~print_vector_int32 interface~print_array_v2->proc~print_vector_int64 interface~print_array_v2->proc~print_vector_sp Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code subroutine set_brackets ( format_type , open_bracket , close_bracket ) !! Set brackets based on output format type character ( len =* ), intent ( in ) :: format_type character ( len = 1 ), intent ( out ) :: open_bracket , close_bracket select case ( trim ( to_upper ( adjustl ( format_type )))) case ( \"NUMPY\" ) open_bracket = \"[\" close_bracket = \"]\" case ( \"MATHEMATICA\" ) open_bracket = \"{\" close_bracket = \"}\" case ( \"PLAIN\" ) open_bracket = \"[\" close_bracket = \"]\" case default print * , \"Warning: Unsupported format type '\" // trim ( format_type ) // \"'. Defaulting to NumPy style.\" open_bracket = \"[\" close_bracket = \"]\" end select end subroutine set_brackets","tags":"","url":"proc/set_brackets.html"},{"title":"print_array_v2 – PIC","text":"public interface print_array_v2 Generic interface for printing arrays of different types Usage: call print_array_v2(array, [optional] format)\nWhere format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) Implemented types are: array(:)   -> int32, int64, sp, dp array(:,:) -> int32, int64, sp, dp array(:) (packed matrix) -> sp, dp array(:,:,:) -> sp, dp Calls interface~~print_array_v2~~CallsGraph interface~print_array_v2 print_array_v2 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_matrix_dp print_matrix_dp interface~print_array_v2->proc~print_matrix_dp proc~print_matrix_int32 print_matrix_int32 interface~print_array_v2->proc~print_matrix_int32 proc~print_matrix_int64 print_matrix_int64 interface~print_array_v2->proc~print_matrix_int64 proc~print_matrix_sp print_matrix_sp interface~print_array_v2->proc~print_matrix_sp proc~print_packed_matrix_dp print_packed_matrix_dp interface~print_array_v2->proc~print_packed_matrix_dp proc~print_packed_matrix_int32 print_packed_matrix_int32 interface~print_array_v2->proc~print_packed_matrix_int32 proc~print_packed_matrix_int64 print_packed_matrix_int64 interface~print_array_v2->proc~print_packed_matrix_int64 proc~print_packed_matrix_sp print_packed_matrix_sp interface~print_array_v2->proc~print_packed_matrix_sp proc~print_vector_dp print_vector_dp interface~print_array_v2->proc~print_vector_dp proc~print_vector_int32 print_vector_int32 interface~print_array_v2->proc~print_vector_int32 proc~print_vector_int64 print_vector_int64 interface~print_array_v2->proc~print_vector_int64 proc~print_vector_sp print_vector_sp interface~print_array_v2->proc~print_vector_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~set_brackets set_brackets proc~print_3d_tensor_dp->proc~set_brackets proc~print_3d_tensor_sp->interface~print_array_v2 proc~print_3d_tensor_sp->proc~set_brackets interface~to_string to_string proc~print_matrix_dp->interface~to_string proc~print_matrix_dp->proc~set_brackets proc~print_matrix_int32->interface~to_string proc~print_matrix_int32->proc~set_brackets proc~print_matrix_int64->interface~to_string proc~print_matrix_int64->proc~set_brackets proc~print_matrix_sp->interface~to_string proc~print_matrix_sp->proc~set_brackets proc~print_packed_matrix_dp->interface~to_string proc~print_packed_matrix_dp->proc~set_brackets proc~print_packed_matrix_int32->interface~to_string proc~print_packed_matrix_int32->proc~set_brackets proc~print_packed_matrix_int64->interface~to_string proc~print_packed_matrix_int64->proc~set_brackets proc~print_packed_matrix_sp->interface~to_string proc~print_packed_matrix_sp->proc~set_brackets proc~print_vector_dp->interface~to_string proc~print_vector_dp->proc~set_brackets proc~print_vector_int32->interface~to_string proc~print_vector_int32->proc~set_brackets proc~print_vector_int64->interface~to_string proc~print_vector_int64->proc~set_brackets proc~print_vector_sp->interface~to_string proc~print_vector_sp->proc~set_brackets proc~to_string_char to_string_char interface~to_string->proc~to_string_char proc~to_string_dp to_string_dp interface~to_string->proc~to_string_dp proc~to_string_int32 to_string_int32 interface~to_string->proc~to_string_int32 proc~to_string_int64 to_string_int64 interface~to_string->proc~to_string_int64 proc~to_string_logical to_string_logical interface~to_string->proc~to_string_logical proc~to_string_sp to_string_sp interface~to_string->proc~to_string_sp to_upper to_upper proc~set_brackets->to_upper Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~print_array_v2~~CalledByGraph interface~print_array_v2 print_array_v2 proc~print_3d_tensor_dp print_3d_tensor_dp interface~print_array_v2->proc~print_3d_tensor_dp proc~print_3d_tensor_sp print_3d_tensor_sp interface~print_array_v2->proc~print_3d_tensor_sp proc~print_3d_tensor_dp->interface~print_array_v2 proc~print_3d_tensor_sp->interface~print_array_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private  subroutine print_vector_int32 (vector, format_type) print a vector of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array_v2.html"},{"title":"pic_matrix_printer – PIC","text":"Matrix printing module Uses pic_types pic_string_utils module~~pic_matrix_printer~~UsesGraph module~pic_matrix_printer pic_matrix_printer module~pic_string_utils pic_string_utils module~pic_matrix_printer->module~pic_string_utils module~pic_types pic_types module~pic_matrix_printer->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_matrix_printer~~UsedByGraph module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_matrix_printer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: fmt_edge = \"(F14.10)\" no comma format character(len=*), private, parameter :: fmt_in = '(F14.10, \", \")' comma format for between arrays Interfaces public        interface print_array general interface for printing a one or two dimensional array\nwill be deprecated private  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type public        interface print_array_with_bounds general interface to print an array within certain bounds private  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type Subroutines private  subroutine print_matrix (mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_in_format (mat, format_type, n_cols, n_rows) private subroutine to print a matrix in format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows private  subroutine print_matrix_m_n (mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type private  subroutine print_plain_matrix (mat, n_cols, n_rows) private subroutine that prints a plain matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in), optional :: n_cols integer(kind=default_int), intent(in), optional :: n_rows private  subroutine print_plain_vector (vec, n_elements) private subroutine that prints a vector of n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in), optional :: n_elements private  subroutine print_vector (vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_in_format (vec, format_type, n_elements) private subroutine that prints a vector in a format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in) :: format_type format can be mathematica or numpy integer(kind=default_int), intent(in), optional :: n_elements private  subroutine print_vector_n (vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type","tags":"","url":"module/pic_matrix_printer.html"},{"title":"pic_global_definitions – PIC","text":"Global definitions for input output Uses pic_types module~~pic_global_definitions~~UsesGraph module~pic_global_definitions pic_global_definitions module~pic_types pic_types module~pic_global_definitions->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_global_definitions~~UsedByGraph module~pic_global_definitions pic_global_definitions module~pic_logger pic_logger module~pic_logger->module~pic_global_definitions module~pic_test_helpers pic_test_helpers module~pic_test_helpers->module~pic_global_definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: logfile_unit = 99 assign output unit 99 for the logfile integer(kind=default_int), public, parameter :: stdout = 6 assign output unit 6 for stdout real(kind=dp), public, parameter :: tol_dp = 1.0e-12_dp real(kind=sp), public, parameter :: tol_sp = 1.0e-6_sp","tags":"","url":"module/pic_global_definitions.html"},{"title":"pic_optional_value – PIC","text":"Uses pic_types module~~pic_optional_value~~UsesGraph module~pic_optional_value pic_optional_value module~pic_types pic_types module~pic_optional_value->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface pic_optional private pure function optional_int32 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_sp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp) private pure function optional_dp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_char (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable Functions private pure function optional_char (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name character(len=*), intent(in), optional :: input_value character(len=*), intent(in) :: default_value Return Value character(len=:), allocatable private pure function optional_dp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in), optional :: input_value real(kind=dp), intent(in) :: default_value Return Value real(kind=dp) private pure function optional_int32 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in), optional :: input_value integer(kind=int32), intent(in) :: default_value Return Value integer(kind=int32) private pure function optional_int64 (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in), optional :: input_value integer(kind=int64), intent(in) :: default_value Return Value integer(kind=int64) private pure function optional_sp (input_value, default_value) result(output) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in), optional :: input_value real(kind=sp), intent(in) :: default_value Return Value real(kind=sp)","tags":"","url":"module/pic_optional_value.html"},{"title":"pic_logger – PIC","text":"this is the logger module Uses pic_global_definitions pic_types module~~pic_logger~~UsesGraph module~pic_logger pic_logger module~pic_global_definitions pic_global_definitions module~pic_logger->module~pic_global_definitions module~pic_types pic_types module~pic_logger->module~pic_types module~pic_global_definitions->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: debug_level = 10 integer(kind=default_int), public, parameter :: error_level = 5 type( logger_type ), public :: global_logger integer(kind=default_int), public, parameter :: info_level = 8 integer(kind=default_int), public, parameter :: performance_level = 7 integer(kind=default_int), public, parameter :: verbose_level = 9 integer(kind=default_int), public, parameter :: warning_level = 6 character(len=*), private, parameter :: name = \"pic_logger\" Derived Types type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info logical, private :: log_file_open = .false. integer(kind=default_int), private :: log_file_unit = -1 Type-Bound Procedures procedure, public, pass(self) :: close_log_file Close the log file, needs to be called at the end of the program.\nUsage: call my_logger%close_log_file() procedure, public, pass(self) :: configuration Get the current logger verbosity configuration.\nUsage: call my_logger%configuration(level) procedure, public, pass(self) :: configure Configure the logger to be a certain verbosity level.\nUsage: call my_logger%configure(level) procedure, public, pass(self) :: configure_file_output Configure the logger to file to be a certain verbosity level.\nUsage: call my_logger%configure_file_output(filename, level) procedure, public, pass(self) :: debug Log a message that will only be printed at the debug level of verbosity.\nUsage: call my_logger%debug(“MESSAGE”) procedure, public, pass(self) :: error Log a message that will only be printed at the error level of verbosity.\nUsage: call my_logger%error(“MESSAGE”) procedure, public, pass(self) :: info Log a message that will only be printed at the info level of verbosity.\nUsage: call my_logger%info(“MESSAGE”) procedure, public, pass(self) :: performance Log a message that will only be printed at the performance level of verbosity.\nUsage: call my_logger%performance(“MESSAGE”) procedure, public, pass(self) :: verbose Log a message that will only be printed at the verbose level of verbosity.\nUsage: call my_logger%verbose(“MESSAGE”) procedure, public, pass(self) :: warning Log a message that will only be printed at the warning level of verbosity.\nUsage: call my_logger%warning(“MESSAGE”) procedure, private, pass(self) :: log Processes the message and filters it according to the verbosity level set by the user or the default Subroutines private  subroutine close_log_file (self) Close the log file, needs to be called at the end of the program Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self private pure subroutine configuration (self, level) Get the current logger verbosity configuration Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level private pure subroutine configure (self, level) Configure the logger to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level private  subroutine configure_file_output (self, filename, level) Configure the logger to file to be a certain verbosity level Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level private  subroutine debug (self, message, module, procedure) Log a message that will only be printed at the debug level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine error (self, message, module, procedure) Log a message that will only be printed at the error of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine info (self, message, module, procedure) Log a message that will only be printed at the info level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine log (self, level, message, module, procedure) internal subroutines that processes the message and filters it according to\nthe verbosity level set by the user or the default\nthis is a private subroutine so it is not exposed to the user Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine performance (self, message, module, procedure) Log a message that will only be printed at the performance of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine verbose (self, message, module, procedure) Log a message that will only be printed at the verbose level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine warning (self, message, module, procedure) Log a message that will only be printed at the warning level of verbosity Read more… Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure private  subroutine write_log_line (unit, level, message, module, procedure) Internal subroutine that will write the message to the log\nno interface to the public Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: unit character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure","tags":"","url":"module/pic_logger.html"},{"title":"pic_flop_rate – PIC","text":"pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer\nit is used to measure the flop rate of a given operation, and report it Uses pic_flop_recorder pic_timer pic_types pic_string_utils module~~pic_flop_rate~~UsesGraph module~pic_flop_rate pic_flop_rate module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_string_utils pic_string_utils module~pic_flop_rate->module~pic_string_utils module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_types pic_types module~pic_flop_rate->module~pic_types module~pic_flop_recorder->module~pic_types module~pic_string_utils->module~pic_types module~pic_timer->module~pic_string_utils module~pic_timer->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Components Type Visibility Attributes Name Initial real(kind=dp), private :: m_flop_rate private by default so that people use the accessor functions type( flop_recorder_type ), private :: m_flops type( pic_timer_type ), private :: m_timer Type-Bound Procedures procedure, public :: add_flops => flop_rate_add_flops procedure, public :: get_flop_rate => flop_rate_get_flop_rate procedure, public :: get_flops => flop_rate_get_flops procedure, public :: get_time => flop_rate_get_time procedure, public :: report => flop_rate_report procedure, public :: reset => flop_rate_reset procedure, public :: start_time => flop_rate_start_time procedure, public :: stop_time => flop_rate_stop_time Functions private  function flop_rate_get_flop_rate (self) result(flop_rate) get the flop rate in GFLOP/s, this will calculate the flop rate based on the\nnumber of flops and the elapsed time Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) private  function flop_rate_get_flops (self) result(flops) get the number of flops recorded in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) private  function flop_rate_get_time (self) result(time) get the elapsed time in seconds from the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) Subroutines private  subroutine flop_rate_add_flops (self, flops) add flops to the flop rate type, this will add the flops to the flop recorder\nUsage: call my_flop_rate%add_flops(1000) Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops private  subroutine flop_rate_report (self) report the flop rate, this will print the flop rate in GFLOP/s Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_reset (self) reset the flop rate type, this will reset the timer and the flop recorder Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_start_time (self) Calls the start method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self private  subroutine flop_rate_stop_time (self) Calls the stop method for the timer contained in the flop rate type Read more… Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self","tags":"","url":"module/pic_flop_rate.html"},{"title":"pic_blas_interfaces – PIC","text":"pic_blas_interfaces.F90 provides the interfaces for the BLAS routines\nthe idea is to have a two level interface, first pic_blas_xyz which\nis the way programmers will use BLAS, it’ll do some checks and then\ncall the “overloaded” BLAS interfaces to call the correct BLAS routine Uses pic_types module~~pic_blas_interfaces~~UsesGraph module~pic_blas_interfaces pic_blas_interfaces module~pic_types pic_types module~pic_blas_interfaces->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface pic_asum general interface of the BLAS ASUM routines, will call SASUM, DASUM, SCASUM, DZASUM Usage: result = pic_asum(x, incx) where x is a vector and incx is the increment, this will return the sum of the absolute values\nof the elements of x. The vector x must be an allocatable array, we deduce the shape from it.\nThe increment incx is 1 by default. private  function pic_sasum (x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dasum (x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_scasum (x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dzasum (x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) public        interface pic_axpy general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY Usage: call pic_axpy(n, alpha, x, incx, y, incy) where n is the number of elements, alpha is the scaling factor,\nx is the input vector, incx is the increment for x, y is the output vector,\nand incy is the increment for y. The vectors x and y must be allocatable arrays, we deduce the shapes from them.\nThe increments incx and incy are 1 by default. private  subroutine pic_saxpy (x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_daxpy (x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_caxpy (x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zaxpy (x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha public        interface pic_copy general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY Usage: call pic_copy(x, y) where x is the input vector, y is the output vector.\nThe vectors x and y must be allocatable arrays, we deduce the shapes from them. private  subroutine pic_scopy (x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) private  subroutine pic_dcopy (x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) private  subroutine pic_ccopy (x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) private  subroutine pic_zcopy (x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) public        interface pic_dot general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC Usage: result = pic_dot(x, y) where x is the input vector, y is the output vector.\nThe vectors x and y must be allocatable arrays, we deduce the shapes from them. private  function pic_sdot (x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) private  function pic_ddot (x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) private  function pic_cdotc (x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) private  function pic_zdotc (x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp) public        interface pic_gemm general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, CGEMM, ZGEMM Usage: call pic_gemm(A, B, C, [optional] transa, [optional] transb, [optional] alpha, [optional] beta) where A, B, C are matrices, transa and transb are optional transpose options,\nalpha and beta are optional scaling factors By default, if not specified transA and transB are “N” (no transpose),\nand alpha and beta are 1.0 and 0.0 respectively. The matrices A, B, C must be allocatable arrays, we deduce the shapes from them. private pure subroutine pic_sgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private pure subroutine pic_zgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta public        interface pic_gemv general interface of the BLAS GEMV routines, will call SGEMV, DGEMV, CGEMV, ZGEMV Usage: call pic_gemv(A, x, y, [optional] transa, [optional] alpha, [optional] beta) where A is a matrix, x and y are vectors, transa is an optional transpose option,\nalpha and beta are optional scaling factors. The matrix A must be an allocatable array, we deduce the shapes from it.\nTransA is “N” (no transpose) by default. And alpha and beta are 1.0 and 0.0 respectively. private pure subroutine pic_sgemv (A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemv (A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta public        interface pic_iamax general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX Usage: idx = pic_iamax(x, incx) where x is the input vector, incx is the increment.\nThe vector x must be an allocatable array, we deduce the shape from it.\nThe increment incx is 1 by default. private  function pic_isamax (x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_idamax (x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_icamax (x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_izamax (x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) public        interface pic_scal general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL Usage: call pic_scal(x, [optional] alpha) where x is the input vector, alpha is the scaling factor.\nThe vector x must be an allocatable array, we deduce the shape from it.\nThe scaling factor alpha is 1.0 by default. private  subroutine pic_sscal (x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_dscal (x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_cscal (x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zscal (x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha private        interface blas_asum this is the interface for the BLAS ASUM routines, it will call SASUM, DASUM, SCASUM, DZASUM\nUsage: result = blas_asum(x, incx)\nwhere x is the input vector, incx is the increment. This is not a public interface, it is used internally by pic_asum private pure function dasum(n, x, incx) result(res_dasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function dzasum(n, x, incx) result(res_dzasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function sasum(n, x, incx) result(res_sasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) private pure function scasum(n, x, incx) result(res_scasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) private        interface blas_axpy explicit interface for BLAS AXPY routines Usage: call blas_axpy(n, alpha, x, incx, y, incy) This is not a public interface, it is used internally by pic_axpy private pure subroutine caxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine daxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine saxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zaxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private        interface blas_copy explicit interface for BLAS COPY routines Usage: call blas_copy(x, y) This is not a public interface, it is used internally by pic_copy private pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private        interface blas_dot explicit interface for BLAS DOT routines Usage: result = blas_dot(x, y, incx, incy, n)\nThis is not a public interface, it is used internally by pic_dot private pure function cdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=sp) private pure function ddot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=dp) private pure function sdot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=sp) private pure function zdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=dp) private        interface blas_gemm explicit interface for BLAS GEMM routines Usage: call blas_gemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) This is not a public interface, it is used internally by pic_gemm private pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private        interface blas_gemv explicit interface for BLAS GEMV routines Usage: call blas_gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) This is not a public interface, it is used internally by pic_gemv private pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private        interface blas_iamax explicit interface for BLAS IAMAX routines Usage: idx = blas_iamax(x, incx) This is not a public interface, it is used internally by pic_iamax private pure function icamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function idamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function isamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function izamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private        interface blas_scal explicit interface for BLAS SCAL routines Usage: call blas_scal(n, alpha, x, incx) This is not a public interface, it is used internally by pic_scal private pure subroutine cscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine dscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine sscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine zscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx Functions private  function pic_cdotc (x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) private  function pic_dasum (x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_ddot (x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) private  function pic_dzasum (x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_icamax (x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_idamax (x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_isamax (x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_izamax (x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_sasum (x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_scasum (x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_sdot (x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) private  function pic_zdotc (x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp) Subroutines private  subroutine pic_caxpy (x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_ccopy (x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) private  subroutine pic_cscal (x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_daxpy (x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_dcopy (x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) private pure subroutine pic_dgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private pure subroutine pic_dgemv (A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private  subroutine pic_dscal (x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_saxpy (x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_scopy (x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) private pure subroutine pic_sgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_sgemv (A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private  subroutine pic_sscal (x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_zaxpy (x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha private  subroutine pic_zcopy (x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) private pure subroutine pic_zgemm (A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta private  subroutine pic_zscal (x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"module/pic_blas_interfaces.html"},{"title":"pic_string_utils – PIC","text":"General string utilities Uses pic_types module~~pic_string_utils~~UsesGraph module~pic_string_utils pic_string_utils module~pic_types pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_string_utils~~UsedByGraph module~pic_string_utils pic_string_utils module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_string_utils module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools->module~pic_matrix_printer module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_string_utils module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_matrix_printer->module~pic_string_utils module~pic_matrix_printer_v2 pic_matrix_printer_v2 module~pic_matrix_printer_v2->module~pic_string_utils module~pic_timer->module~pic_string_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), private, parameter :: default_dp_precision = 12 integer(kind=default_int), private :: dp_precision = default_dp_precision Interfaces public        interface to_string converts a variable of type (int32, int64, sp, dp, char, logical)\nto a “string” which is just a collecting of chars. Usage result = to_string(variable) Note the functions here are not elemental so they won’t work for\narrays. Please use pic_print_array_v2 module for this private  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable private        interface get_precision Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result private  interface get_precision () Obtain the current precision being used to print variables to strings Usage: precision = get_precision() returns a default_int result Arguments None private        interface pad adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) private  interface pad () adds a number X of spaces to the left of a “string” whcih is just a\ncollection of characters. Mostly used for nice printing Usage: var = pad(“hello”, n_spaces) Arguments None private        interface set_precision This routine overrides the default dp precision used for\nprinting strings in the to_string function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Usage: call set_precision(variable) where variable is default_int private  interface set_precision () This routine overrides the default dp precision used for\nprinting strings in the to_string function, the default\nis : integer(default_int), parameter :: default_dp_precision = 12 Usage: call set_precision(variable) where variable is default_int Arguments None private        interface to_upper takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) private  interface to_upper () takes a character variable and transforms it to uppercase usage var = to_upper(“hello”) Arguments None Functions public  function get_precision () result(precision) Get the current precision for real numbers Arguments None Return Value integer(kind=default_int) public  function pad (s, width) result(padded) function to pad a string with a certain number of characters for nice printing Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: s integer(kind=default_int), intent(in) :: width Return Value character(len=:), allocatable public  function to_upper (str) result(upper_str) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str Return Value character(len=len) private  function to_string_char (c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_string_dp (r) result(trimmed_str) transform a real(dp) to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_int32 (i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_int64 (i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_logical (l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable private  function to_string_sp (r) result(trimmed_str) transform a real(sp) to a string Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: r Return Value character(len=:), allocatable Subroutines public  subroutine set_precision (precision) Set the precision for real numbers Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: precision","tags":"","url":"module/pic_string_utils.html"},{"title":"pic_constants – PIC","text":"this will be the physical constants module Uses pic_types module~~pic_constants~~UsesGraph module~pic_constants pic_constants module~pic_types pic_types module~pic_constants->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial real(kind=dp), public, parameter :: gravity = 9.81_dp","tags":"","url":"module/pic_constants.html"},{"title":"pic_output_helpers – PIC","text":"Assorted output helper routines Uses pic_types module~~pic_output_helpers~~UsesGraph module~pic_output_helpers pic_output_helpers module~pic_types pic_types module~pic_output_helpers->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_asterisk_row (n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print","tags":"","url":"module/pic_output_helpers.html"},{"title":"pic_test_helpers – PIC","text":"simple reusable helpers for random things Uses pic_global_definitions pic_types module~~pic_test_helpers~~UsesGraph module~pic_test_helpers pic_test_helpers module~pic_global_definitions pic_global_definitions module~pic_test_helpers->module~pic_global_definitions module~pic_types pic_types module~pic_test_helpers->module~pic_types module~pic_global_definitions->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface is_equal The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about\ncomparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that\nthe two reals are exactly equal due to floating point precision issues. The functions are defined as elemental Usage: if (is_equal(a, b)) then\nwhere a and b are real numbers, and the function will return true if they are\nequal within the tolerance defined in pic_global_definitions. private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical Functions private elemental function is_equal_dp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: a real(kind=dp), intent(in) :: b Return Value logical private elemental function is_equal_sp (a, b) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: a real(kind=sp), intent(in) :: b Return Value logical Subroutines public  subroutine dummy_work () this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely Read more… Arguments None","tags":"","url":"module/pic_test_helpers.html"},{"title":"pic_array – PIC","text":"Please do not modify this file to implement new methods, please go look at tools/autogen/pic_array_cpu.fypp\nand edit the generator. Uses pic_types module~~pic_array~~UsesGraph module~pic_array pic_array module~pic_types pic_types module~pic_array->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: ASCENDING = 1 integer(kind=default_int), public, parameter :: DESCENDING = 2 integer(kind=default_int), private, parameter :: block_size = 32 This is the size to block over for matrices for performance purposes logical, private :: use_threaded_default = .false. Interfaces public        interface copy copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy\nif you built pic with BLAS use the copy interface provided there, I will not beat BLAS\ncopy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types Usage: call copy(destination, source, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded public        interface fill fill provides a generic interface to assing a value\nalpha of types (int32, int64, sp, dp) as defined in pic_types.F90\nThe inteface supports filling 1d and 2d arrays of the specified\nvariables Usage: call fill(array, value, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to .true. Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded public        interface is_sorted is_sorted provides a simple way to checking if a 1d array is sorted\nit is implemented for int32, int64, sp, and dp datatypes. The default\nis to check if an array is sorted in ascending fashion. Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical public        interface pic_sum pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will\nbe too slow for large sizes of vectors and matrices. Note that this provides the total\nsum. As opposed to the blas alternative XASUM which does the absolute sum pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays Usage: result = pic_sum(array, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) public        interface pic_transpose pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic\nwhich will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) This subroutine is threaded for performance purposes if threaded is set to true Note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private        interface get_threading_mode get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() private  interface get_threading_mode () get_threading_mode returns the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None private        interface set_threading_mode set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) private  interface set_threading_mode () set_threading sets the threading mode for the array routines\nthis will set the use_threaded variable to true or false depending on the input\nUsage: call set_threading_mode(.true.) or call set_threading_mode(.false.) Arguments None Functions public  function get_threading_mode () result(mode) get the current threading mode for the array routines\nUsage: mode = get_threading_mode() Arguments None Return Value logical private pure function is_sorted_dp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int32 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_int64 (array, order) result(sorted) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private pure function is_sorted_sp (array, order) result(sorted) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: array (:) integer(kind=default_int), intent(in), optional :: order Return Value logical private  function sum_matrix_dp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_matrix_int32 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_matrix_int64 (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_matrix_sp (matrix, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) logical, intent(in), optional :: threaded Return Value real(kind=sp) private  function sum_vector_dp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=dp) private  function sum_vector_int32 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int32) private  function sum_vector_int64 (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value integer(kind=int64) private  function sum_vector_sp (vector, threaded) result(res) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) logical, intent(in), optional :: threaded Return Value real(kind=sp) Subroutines public  subroutine set_threading_mode (threaded) set the threading mode for the array routines, this will set the use_threaded variable\nto true or false depending on the input Read more… Arguments Type Intent Optional Attributes Name logical, intent(in) :: threaded private  subroutine copy_matrix_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:,:) real(kind=dp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:,:) integer(kind=int32), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:,:) integer(kind=int64), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_matrix_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:,:) real(kind=sp), intent(in) :: source (:,:) logical, intent(in), optional :: threaded private  subroutine copy_vector_dp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: dest (:) real(kind=dp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int32 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: dest (:) integer(kind=int32), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_int64 (dest, source, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: dest (:) integer(kind=int64), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine copy_vector_sp (dest, source, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: dest (:) real(kind=sp), intent(in) :: source (:) logical, intent(in), optional :: threaded private  subroutine fill_matrix_dp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: matrix (:,:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int32 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: matrix (:,:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_int64 (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: matrix (:,:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_matrix_sp (matrix, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: matrix (:,:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_dp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: vector (:) real(kind=dp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int32 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(inout) :: vector (:) integer(kind=int32), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_int64 (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(inout) :: vector (:) integer(kind=int64), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine fill_vector_sp (vector, alpha, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: vector (:) real(kind=sp), intent(in) :: alpha logical, intent(in), optional :: threaded private  subroutine transpose_matrix_dp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int32 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: A (:,:) integer(kind=int32), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_int64 (A, B, threaded) Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: A (:,:) integer(kind=int64), intent(out) :: B (:,:) logical, intent(in), optional :: threaded private  subroutine transpose_matrix_sp (A, B, threaded) Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(out) :: B (:,:) logical, intent(in), optional :: threaded","tags":"","url":"module/pic_array.html"},{"title":"pic_flop_recorder – PIC","text":"general flop recorder module Uses pic_types module~~pic_flop_recorder~~UsesGraph module~pic_flop_recorder pic_flop_recorder module~pic_types pic_types module~pic_flop_recorder->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_flop_recorder~~UsedByGraph module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_flop_recorder Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Components Type Visibility Attributes Name Initial integer(kind=int64), private :: flop_count = 0_int64 Type-Bound Procedures procedure, public :: add => add_flops procedure, public :: get => get_flops procedure, public :: reset => reset_flop_counter Functions private  function get_flops (self) result(flops) Get the int64 number of FLOPs we currently have in the counter Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) Subroutines private  subroutine add_flops (self, flops) Add an int64 variable which contains the FLOPs\nwe use int64 since we might reach very large FLOP counts Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops private  subroutine reset_flop_counter (self) Resets the flop counter to 0_int64 Read more… Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self","tags":"","url":"module/pic_flop_recorder.html"},{"title":"pic_mpi – PIC","text":"General MPI interface module Uses mpi_f08 pic_types module~~pic_mpi~~UsesGraph module~pic_mpi pic_mpi module~pic_types pic_types module~pic_mpi->module~pic_types mpi_f08 mpi_f08 module~pic_mpi->mpi_f08 iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( pic_comm_type ), public :: world_comm our world comm Derived Types type, public :: pic_comm_type custom data type that holds the MPI communicators Components Type Visibility Attributes Name Initial type(MPI_COMM), public :: comm use the MPI_COMM from the mpi_f08 module interface integer(kind=int32), public :: m_ierr integer(kind=int32), public :: m_rank MPI rank integer(kind=int32), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize procedure, public :: init => pic_comm_init Subroutines private  subroutine pic_comm_finalize (self) finalize the MPI library Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self private  subroutine pic_comm_init (self) initilalize the MPI library and get the size and rank variables Arguments Type Intent Optional Attributes Name class( pic_comm_type ), intent(inout) :: self","tags":"","url":"module/pic_mpi.html"},{"title":"pic_types – PIC","text":"main module for defining types for integer and double precision Uses iso_fortran_env module~~pic_types~~UsesGraph module~pic_types pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_types~~UsedByGraph module~pic_types pic_types module~pic_array pic_array module~pic_array->module~pic_types module~pic_blas_interfaces pic_blas_interfaces module~pic_blas_interfaces->module~pic_types module~pic_command_line pic_command_line module~pic_command_line->module~pic_types module~pic_constants pic_constants module~pic_constants->module~pic_types module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_types module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_string_utils pic_string_utils module~pic_flop_rate->module~pic_string_utils module~pic_timer pic_timer module~pic_flop_rate->module~pic_timer module~pic_flop_recorder->module~pic_types module~pic_global_definitions pic_global_definitions module~pic_global_definitions->module~pic_types module~pic_logger pic_logger module~pic_logger->module~pic_types module~pic_logger->module~pic_global_definitions module~pic_matrix_printer pic_matrix_printer module~pic_matrix_printer->module~pic_types module~pic_matrix_printer->module~pic_string_utils module~pic_matrix_printer_v2 pic_matrix_printer_v2 module~pic_matrix_printer_v2->module~pic_types module~pic_matrix_printer_v2->module~pic_string_utils module~pic_mpi pic_mpi module~pic_mpi->module~pic_types module~pic_optional_value pic_optional_value module~pic_optional_value->module~pic_types module~pic_output_helpers pic_output_helpers module~pic_output_helpers->module~pic_types module~pic_string_utils->module~pic_types module~pic_test_helpers pic_test_helpers module~pic_test_helpers->module~pic_types module~pic_test_helpers->module~pic_global_definitions module~pic_timer->module~pic_types module~pic_timer->module~pic_string_utils module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_matrix_printer module~pic_debugging_tools->module~pic_string_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: default_complex = dp default complex is double precision integer, public, parameter :: default_int = int32 the default integer kind in PIC is int32 which faciliates the interfaces to MPI\npay special attention if linking PIC to a code that use default int size of 8 integer, public, parameter :: default_real = dp naturally, our default real is double precision integer, public, parameter :: dp = SELECTED_REAL_KIND(15, 307) double precision size integer, public, parameter :: qp = SELECTED_REAL_KIND(33, 4931) quadruple precision size, varies by compiler integer, public, parameter :: sp = SELECTED_REAL_KIND(6, 37) single precision size","tags":"","url":"module/pic_types.html"},{"title":"pic_command_line – PIC","text":"command line interaction module Uses pic_types module~~pic_command_line~~UsesGraph module~pic_command_line pic_command_line module~pic_types pic_types module~pic_command_line->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_first_arg_from_command_line () result(filename) get the first argument from the command line, this is expected to be a filename Read more… Arguments None Return Value character(len=255)","tags":"","url":"module/pic_command_line.html"},{"title":"pic – PIC","text":"simple interface module that prints banner and other information about the library\nmostly here to verify installs, etc. Subroutines public  subroutine pic_print_banner () my cool banner, work in progress Arguments None","tags":"","url":"module/pic.html"},{"title":"pic_debugging_tools – PIC","text":"simple single include for printing routines Uses pic_matrix_printer pic_string_utils module~~pic_debugging_tools~~UsesGraph module~pic_debugging_tools pic_debugging_tools module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools->module~pic_matrix_printer module~pic_string_utils pic_string_utils module~pic_debugging_tools->module~pic_string_utils module~pic_matrix_printer->module~pic_string_utils module~pic_types pic_types module~pic_matrix_printer->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/pic_debugging_tools.html"},{"title":"pic_timer – PIC","text":"contains a simple timer module to measure and record time Uses pic_types pic_string_utils module~~pic_timer~~UsesGraph module~pic_timer pic_timer module~pic_string_utils pic_string_utils module~pic_timer->module~pic_string_utils module~pic_types pic_types module~pic_timer->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_timer~~UsedByGraph module~pic_timer pic_timer module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_timer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: pic_timer_type derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp. If PIC is compiled with OpenMP the default\ntimer will be the omp time. This is mostly to minimize problems with threading\nand system clock Components Type Visibility Attributes Name Initial integer(kind=default_int), private :: count_rate = 1_default_int logical, private :: is_running = .false. integer(kind=default_int), private :: start_count = 0_default_int real(kind=dp), private :: start_time = 0.0_dp integer(kind=default_int), private :: stop_count = 0_default_int real(kind=dp), private :: stop_time = 0.0_dp real(kind=dp), private :: walltime Type-Bound Procedures procedure, public :: get_elapsed_time => timer_get_elapsed_time procedure, public :: print_time => timer_print_time procedure, public :: start => timer_start procedure, public :: stop => timer_stop Functions private  function timer_get_elapsed_time (self) result(elapsed) Returns the elapsed time as a real(dp) variable Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self Return Value real(kind=dp) Subroutines private  subroutine timer_print_time (self) Prints the elapsed time at the time of calling Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(in) :: self private  subroutine timer_start (self) starts the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self private  subroutine timer_stop (self) stop the timer. If OMP is enabled, it will use omp_get_wtime()\nif not, it will use Fortran’s system_clock Read more… Arguments Type Intent Optional Attributes Name class( pic_timer_type ), intent(inout) :: self","tags":"","url":"module/pic_timer.html"},{"title":"pic_matrix_printer_v2 – PIC","text":"Generic module for printing arrays Uses pic_types pic_string_utils module~~pic_matrix_printer_v2~~UsesGraph module~pic_matrix_printer_v2 pic_matrix_printer_v2 module~pic_string_utils pic_string_utils module~pic_matrix_printer_v2->module~pic_string_utils module~pic_types pic_types module~pic_matrix_printer_v2->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial character(len=5), private, parameter :: default_format = \"NUMPY\" supported formats: NUMPY, MATHEMATICA, and PLAIN which resembles numpy character(len=*), private, parameter :: fmt_edge = \"(A)\" character(len=*), private, parameter :: fmt_in = '(A, \", \")' Interfaces public        interface print_array_v2 Generic interface for printing arrays of different types Usage: call print_array_v2(array, [optional] format)\nWhere format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) Implemented types are: array(:)   -> int32, int64, sp, dp array(:,:) -> int32, int64, sp, dp array(:) (packed matrix) -> sp, dp array(:,:,:) -> sp, dp private  subroutine print_vector_int32 (vector, format_type) print a vector of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type Subroutines private  subroutine print_3d_tensor_dp (matrix, format_type) Print a 3D tensor of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_3d_tensor_sp (matrix, format_type) Print a 3D tensor of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_dp (matrix, format_type) print a matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int32 (matrix, format_type) print a matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_int64 (matrix, format_type) print a matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_sp (matrix, format_type) print a matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: matrix (:,:) character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_dp (packed, n_elements, format_type) Print a packed lower triangular matrix of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int32 (packed, n_elements, format_type) Print a packed lower triangular matrix of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_int64 (packed, n_elements, format_type) Print a packed lower triangular matrix of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_packed_matrix_sp (packed, n_elements, format_type) Print a packed lower triangular matrix of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: packed (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_vector_dp (vector, format_type) print a vector of dp values Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int32 (vector, format_type) print a vector of int32 values Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_int64 (vector, format_type) print a vector of int64 values Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine print_vector_sp (vector, format_type) print a vector of sp values Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: vector (:) character(len=*), intent(in), optional :: format_type private  subroutine set_brackets (format_type, open_bracket, close_bracket) Set brackets based on output format type Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: format_type character(len=1), intent(out) :: open_bracket character(len=1), intent(out) :: close_bracket","tags":"","url":"module/pic_matrix_printer_v2.html"},{"title":"pic_matrix_printer.f90 – PIC","text":"Routines to print vectors and matrices, currently no support for higher\ndimensional arrays. Need to fix that! This file depends on sourcefile~~pic_matrix_printer.f90~~EfferentGraph sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_matrix_printer.f90~~AfferentGraph sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Routines to print vectors and matrices, currently no support for higher !! dimensional arrays. Need to fix that! module pic_matrix_printer !! Matrix printing module use pic_types , only : dp , default_int use pic_string_utils , only : to_string implicit none private public :: print_array , print_array_with_bounds interface print_array !! general interface for printing a one or two dimensional array !! will be deprecated module procedure print_vector module procedure print_matrix end interface print_array interface print_array_with_bounds !! general interface to print an array within certain bounds module procedure print_vector_n module procedure print_matrix_m_n end interface print_array_with_bounds character ( len =* ), parameter :: fmt_edge = \"(F14.10)\" !! no comma format character ( len =* ), parameter :: fmt_in = '(F14.10, \", \")' !! comma format for between arrays contains subroutine print_vector_n ( vec , n_elements , format_type ) !! print a vector from start up to n_elements real ( dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected integer ( kind = default_int ), intent ( in ) :: n_elements ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec , n_elements ) else call print_vector_in_format ( vec , format_selected , n_elements ) end if end subroutine print_vector_n subroutine print_vector ( vec , format_type ) !! print a vector real ( kind = dp ), intent ( in ) :: vec (:) ! 1D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec ) else call print_vector_in_format ( vec , format_selected ) end if end subroutine print_vector subroutine print_matrix_m_n ( mat , n_cols , n_rows , format_type ) !! Print a matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array integer ( kind = default_int ), intent ( in ) :: n_cols , n_rows character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat , n_cols , n_rows ) else call print_matrix_in_format ( mat , format_selected , n_cols , n_rows ) end if end subroutine print_matrix_m_n subroutine print_matrix ( mat , format_type ) !! print a matrix in a given format real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat ) else call print_matrix_in_format ( mat , format_selected ) end if end subroutine print_matrix subroutine print_plain_vector ( vec , n_elements ) !! private subroutine that prints a vector of n_elements real ( kind = dp ), intent ( in ) :: vec (:) integer ( kind = default_int ), intent ( in ), optional :: n_elements integer ( kind = default_int ) :: i , loop_bound if ( present ( n_elements )) then loop_bound = n_elements else loop_bound = size ( vec ) end if print * , \"Vector (Plain format):\" do i = 1 , loop_bound write ( * , fmt_edge ) vec ( i ) end do end subroutine print_plain_vector subroutine print_plain_matrix ( mat , n_cols , n_rows ) !! private subroutine that prints a plain matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if print * , \"Matrix (Plain format):\" do i = 1 , loop_bound_i do j = 1 , loop_bound_j if ( j == loop_bound_j ) then write ( * , fmt_edge , advance = \"yes\" ) mat ( i , j ) ! Last element in the row, new line else write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) ! In-between elements end if end do end do end subroutine print_plain_matrix subroutine print_vector_in_format ( vec , format_type , n_elements ) !! private subroutine that prints a vector in a format real ( kind = dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy integer ( kind = default_int ), intent ( in ), optional :: n_elements character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ) :: i , loop_bound_i if ( present ( n_elements )) then loop_bound_i = n_elements else loop_bound_i = size ( vec ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the vector in the selected format print * , \"Vector (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) vec ( i ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) vec ( i ) end if end do print * , close_bracket end subroutine print_vector_in_format subroutine print_matrix_in_format ( mat , format_type , n_cols , n_rows ) !! private subroutine to print a matrix in format real ( kind = dp ), intent ( in ) :: mat (:, :) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the matrix in the selected format print * , \"Matrix (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i write ( * , \"(A)\" , advance = \"no\" ) open_bracket ! Start of a row do j = 1 , loop_bound_j if ( j == loop_bound_j ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) mat ( i , j ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) end if end do if ( i == loop_bound_i ) then print * , close_bracket ! Close bracket without a comma for the last row else print * , close_bracket , \",\" ! Close bracket with a comma for all other rows end if end do print * , close_bracket end subroutine print_matrix_in_format end module pic_matrix_printer","tags":"","url":"sourcefile/pic_matrix_printer.f90.html"},{"title":"pic_global_definitions.f90 – PIC","text":"this is an experimental file that contains definitions\nthat will be uses across the program, for example input/output units\nthat PIC will use across things. This file depends on sourcefile~~pic_global_definitions.f90~~EfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_global_definitions.f90~~AfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this is an experimental file that contains definitions !! that will be uses across the program, for example input/output units !! that PIC will use across things. module pic_global_definitions !! Global definitions for input output use pic_types , only : default_int , sp , dp implicit none private public :: stdout , logfile_unit public :: tol_sp , tol_dp integer ( default_int ), parameter :: stdout = 6 !! assign output unit 6 for stdout integer ( default_int ), parameter :: logfile_unit = 99 !! assign output unit 99 for the logfile real ( dp ), parameter :: tol_dp = 1.0e-12_dp real ( sp ), parameter :: tol_sp = 1.0e-6_sp end module pic_global_definitions","tags":"","url":"sourcefile/pic_global_definitions.f90.html"},{"title":"pic_optional.f90 – PIC","text":"This file depends on sourcefile~~pic_optional.f90~~EfferentGraph sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module pic_optional_value use pic_types , only : sp , dp , int32 , int64 implicit none private public :: pic_optional interface pic_optional module procedure :: optional_int32 module procedure :: optional_int64 module procedure :: optional_sp module procedure :: optional_dp module procedure :: optional_char end interface contains pure function optional_int32 ( input_value , default_value ) result ( output ) integer ( int32 ), intent ( in ), optional :: input_value integer ( int32 ), intent ( in ) :: default_value integer ( int32 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int32 pure function optional_int64 ( input_value , default_value ) result ( output ) integer ( int64 ), intent ( in ), optional :: input_value integer ( int64 ), intent ( in ) :: default_value integer ( int64 ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_int64 pure function optional_sp ( input_value , default_value ) result ( output ) real ( sp ), intent ( in ), optional :: input_value real ( sp ), intent ( in ) :: default_value real ( sp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_sp pure function optional_dp ( input_value , default_value ) result ( output ) real ( dp ), intent ( in ), optional :: input_value real ( dp ), intent ( in ) :: default_value real ( dp ) :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_dp pure function optional_char ( input_value , default_value ) result ( output ) character ( len =* ), intent ( in ), optional :: input_value character ( len =* ), intent ( in ) :: default_value character ( len = :), allocatable :: output if ( present ( input_value )) then output = input_value else output = default_value end if end function optional_char end module pic_optional_value","tags":"","url":"sourcefile/pic_optional.f90.html"},{"title":"pic_logger.f90 – PIC","text":"the pic_logger.f90 is the base file that defines the logger function\nthis is heavily inspired by the logger from the standard library\nbut with some key changes for my purposes.\nThe logger will be the way in which the code interacts\nwith the output to console and files This file depends on sourcefile~~pic_logger.f90~~EfferentGraph sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! the pic_logger.f90 is the base file that defines the logger function !! this is heavily inspired by the logger from the standard library !! but with some key changes for my purposes. !! The logger will be the way in which the code interacts !! with the output to console and files module pic_logger !! this is the logger module use pic_types , only : default_int use pic_global_definitions , only : stdout , logfile_unit implicit none private public :: global_logger , logger_type character ( * ), parameter :: name = \"pic_logger\" integer ( default_int ), parameter , public :: & debug_level = 10 , & verbose_level = 9 , & info_level = 8 , & performance_level = 7 , & warning_level = 6 , & error_level = 5 type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration !! Get the current logger verbosity configuration. !! Usage: call my_logger%configuration(level) procedure , public , pass ( self ) :: configure !! Configure the logger to be a certain verbosity level. !! Usage: call my_logger%configure(level) procedure , public , pass ( self ) :: configure_file_output !! Configure the logger to file to be a certain verbosity level. !! Usage: call my_logger%configure_file_output(filename, level) procedure , public , pass ( self ) :: close_log_file !! Close the log file, needs to be called at the end of the program. !! Usage: call my_logger%close_log_file() procedure , public , pass ( self ) :: debug !! Log a message that will only be printed at the debug level of verbosity. !! Usage: call my_logger%debug(\"MESSAGE\") procedure , public , pass ( self ) :: verbose !! Log a message that will only be printed at the verbose level of verbosity. !! Usage: call my_logger%verbose(\"MESSAGE\") procedure , public , pass ( self ) :: info !! Log a message that will only be printed at the info level of verbosity. !! Usage: call my_logger%info(\"MESSAGE\") procedure , public , pass ( self ) :: performance !! Log a message that will only be printed at the performance level of verbosity. !! Usage: call my_logger%performance(\"MESSAGE\") procedure , public , pass ( self ) :: warning !! Log a message that will only be printed at the warning level of verbosity. !! Usage: call my_logger%warning(\"MESSAGE\") procedure , public , pass ( self ) :: error !! Log a message that will only be printed at the error level of verbosity. !! Usage: call my_logger%error(\"MESSAGE\") procedure , private , pass ( self ) :: log !! Processes the message and filters it according to the verbosity level set by the user or the default end type logger_type type ( logger_type ) :: global_logger contains pure subroutine configuration ( self , level ) !! Get the current logger verbosity configuration !! !! Usage: call my_logger%configuration(level) !! !! TODO: this should be a function class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration pure subroutine configure ( self , level ) !! Configure the logger to be a certain verbosity level !! !! Usage: call my_logger%configure(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5 !! class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure subroutine configure_file_output ( self , filename , level ) !! Configure the logger to file to be a certain verbosity level !! !! Usage: call my_logger%configure_file_output(level) !! !! Where level can be a number according to the level struct !! or can be loaded from the level struct to be !! !! debug_level = 10, & !! !! verbose_level = 9, & !! !! info_level = 8, & !! !! performance_level = 7, & !! !! warning_level = 6, & !! !! error_level = 5 !! class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = \"replace\" , action = \"write\" , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) \"ERROR: Failed to open log file: \" , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output subroutine close_log_file ( self ) !! Close the log file, needs to be called at the end of the program !! !! Usage: call my_logger%close_log_file() !! !! TODO: revisit class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file subroutine debug ( self , message , module , procedure ) !! Log a message that will only be printed at the debug level of verbosity !! !! Usage: call my_logger%debug(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug subroutine verbose ( self , message , module , procedure ) !! Log a message that will only be printed at the verbose level of verbosity !! !! Usage: call my_logger%verbose(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose subroutine info ( self , message , module , procedure ) !! Log a message that will only be printed at the info level of verbosity !! !! Usage: call my_logger%info(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info subroutine warning ( self , message , module , procedure ) !! Log a message that will only be printed at the warning level of verbosity !! !! Usage: call my_logger%warning(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning subroutine performance ( self , message , module , procedure ) !! Log a message that will only be printed at the performance of verbosity !! !! Usage: call my_logger%performance(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance subroutine error ( self , message , module , procedure ) !! Log a message that will only be printed at the error of verbosity !! !! Usage: call my_logger%error(\"MESSAGE\") !! class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error subroutine write_log_line ( unit , level , message , module , procedure ) !! Internal subroutine that will write the message to the log !! no interface to the public integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line subroutine log ( self , level , message , module , procedure ) !! internal subroutines that processes the message and filters it according to !! the verbosity level set by the user or the default !! this is a private subroutine so it is not exposed to the user class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( \"DEBUG\" ) log_level_value = debug_level case ( \"VERBOSE\" ) log_level_value = verbose_level case ( \"INFO\" ) log_level_value = info_level case ( \"WARNING\" ) log_level_value = warning_level case ( \"PERFORMANCE\" ) log_level_value = performance_level case ( \"ERROR\" ) log_level_value = error_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log end module pic_logger","tags":"","url":"sourcefile/pic_logger.f90.html"},{"title":"pic_flop_rate.f90 – PIC","text":"flop rate handler modules This file depends on sourcefile~~pic_flop_rate.f90~~EfferentGraph sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop rate handler modules module pic_flop_rate !! pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer !! it is used to measure the flop rate of a given operation, and report it use pic_types , only : dp , int64 use pic_timer , only : pic_timer_type use pic_flop_recorder , only : flop_recorder_type use pic_string_utils , only : to_string implicit none private public :: flop_rate_type type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( pic_timer_type ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure :: start_time => flop_rate_start_time procedure :: stop_time => flop_rate_stop_time procedure :: add_flops => flop_rate_add_flops procedure :: get_flops => flop_rate_get_flops procedure :: get_time => flop_rate_get_time procedure :: get_flop_rate => flop_rate_get_flop_rate procedure :: report => flop_rate_report procedure :: reset => flop_rate_reset end type flop_rate_type contains subroutine flop_rate_start_time ( self ) !! Calls the start method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%start_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % start () end subroutine flop_rate_start_time subroutine flop_rate_stop_time ( self ) !! Calls the stop method for the timer contained in the flop rate type !! !! Usage: call my_flop_rate%stop_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % stop () end subroutine flop_rate_stop_time subroutine flop_rate_add_flops ( self , flops ) !! add flops to the flop rate type, this will add the flops to the flop recorder !! Usage: call my_flop_rate%add_flops(1000) !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops call self % m_flops % add ( flops ) end subroutine flop_rate_add_flops function flop_rate_get_flops ( self ) result ( flops ) !! get the number of flops recorded in the flop rate type !! !! Usage: flops = my_flop_rate%get_flops() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % m_flops % get () end function flop_rate_get_flops function flop_rate_get_time ( self ) result ( time ) !! get the elapsed time in seconds from the timer contained in the flop rate type !! !! Usage: time = my_flop_rate%get_time() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( in ) :: self real ( dp ) :: time time = self % m_timer % get_elapsed_time () end function flop_rate_get_time function flop_rate_get_flop_rate ( self ) result ( flop_rate ) !! get the flop rate in GFLOP/s, this will calculate the flop rate based on the !! number of flops and the elapsed time !! !! Usage: flop_rate = my_flop_rate%get_flop_rate() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self real ( dp ) :: flop_rate real ( dp ) :: time integer ( int64 ) :: flops flops = self % m_flops % get () time = self % m_timer % get_elapsed_time () if ( time <= 0.0_dp ) then print * , \"Warning: Time is zero or negative, setting flop rate to zero.\" self % m_flop_rate = 0.0_dp flop_rate = 0.0_dp return else self % m_flop_rate = flops / time / 1.0e9_dp flop_rate = self % m_flop_rate end if end function flop_rate_get_flop_rate subroutine flop_rate_report ( self ) !! report the flop rate, this will print the flop rate in GFLOP/s !! !! Usage: call my_flop_rate%report() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self self % m_flop_rate = self % get_flop_rate () print * , \"Flop rate is \" // to_string ( self % m_flop_rate ) // \" GFLOP/s\" end subroutine flop_rate_report subroutine flop_rate_reset ( self ) !! reset the flop rate type, this will reset the timer and the flop recorder !! !! Usage: call my_flop_rate%reset() !! !! where my_flop_rate is an instance of flop_rate_type !! class ( flop_rate_type ), intent ( inout ) :: self call self % m_flops % reset () end subroutine flop_rate_reset end module pic_flop_rate","tags":"","url":"sourcefile/pic_flop_rate.f90.html"},{"title":"pic_blas_interfaces.F90 – PIC","text":"this file contains the interfaces for the BLAS routines of all levels\nI might consider splitting them up later but alas, I don’t have the time now\nthe idea of this file is to provide something akin to\ninterface blas_gemm\n subroutine sgemm()\n subroutine dgemm()\n  … etc,\nend interface blas_gemm\nso that I can use the same interface for all BLAS routines This file depends on sourcefile~~pic_blas_interfaces.f90~~EfferentGraph sourcefile~pic_blas_interfaces.f90 pic_blas_interfaces.F90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_blas_interfaces.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the interfaces for the BLAS routines of all levels !! I might consider splitting them up later but alas, I don't have the time now !! the idea of this file is to provide something akin to !! interface blas_gemm !!  subroutine sgemm() !!  subroutine dgemm() !!   ... etc, !! end interface blas_gemm !! so that I can use the same interface for all BLAS routines module pic_blas_interfaces !! pic_blas_interfaces.F90 provides the interfaces for the BLAS routines !! the idea is to have a two level interface, first pic_blas_xyz which !! is the way programmers will use BLAS, it'll do some checks and then !! call the \"overloaded\" BLAS interfaces to call the correct BLAS routine use pic_types , only : sp , dp , default_int implicit none private ! these are the cool overloaded interfaces, the pic_xyz function ! has the procedures pic_(type)xyz which will call the correct BLAS routine ! depending on the data type of the arguments ! this _needs_ allocatable arrays since we deduce shapes from the arrays themselves public :: pic_gemm , pic_gemv , pic_asum , pic_axpy , pic_copy , pic_dot , pic_scal , pic_iamax ! tested interface pic_gemm !! general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, CGEMM, ZGEMM !! !! Usage: call pic_gemm(A, B, C, [optional] transa, [optional] transb, [optional] alpha, [optional] beta) !! !! where A, B, C are matrices, transa and transb are optional transpose options, !! alpha and beta are optional scaling factors !! !! By default, if not specified transA and transB are \"N\" (no transpose), !! and alpha and beta are 1.0 and 0.0 respectively. !! !! The matrices A, B, C must be allocatable arrays, we deduce the shapes from them. module procedure :: pic_sgemm module procedure :: pic_dgemm module procedure :: pic_zgemm end interface pic_gemm interface pic_gemv !! general interface of the BLAS GEMV routines, will call SGEMV, DGEMV, CGEMV, ZGEMV !! !! Usage: call pic_gemv(A, x, y, [optional] transa, [optional] alpha, [optional] beta) !! !! where A is a matrix, x and y are vectors, transa is an optional transpose option, !! alpha and beta are optional scaling factors. !! !! The matrix A must be an allocatable array, we deduce the shapes from it. !! TransA is \"N\" (no transpose) by default. And alpha and beta are 1.0 and 0.0 respectively. !! module procedure :: pic_sgemv module procedure :: pic_dgemv end interface pic_gemv ! tested interface pic_asum !! general interface of the BLAS ASUM routines, will call SASUM, DASUM, SCASUM, DZASUM !! !! Usage: result = pic_asum(x, incx) !! !! where x is a vector and incx is the increment, this will return the sum of the absolute values !! of the elements of x. !! !! The vector x must be an allocatable array, we deduce the shape from it. !! The increment incx is 1 by default. !! module procedure :: pic_sasum module procedure :: pic_dasum module procedure :: pic_scasum module procedure :: pic_dzasum end interface pic_asum interface pic_axpy !! general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY !! !! Usage: call pic_axpy(n, alpha, x, incx, y, incy) !! !! where n is the number of elements, alpha is the scaling factor, !! x is the input vector, incx is the increment for x, y is the output vector, !! and incy is the increment for y. !! !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! The increments incx and incy are 1 by default. !! module procedure :: pic_saxpy module procedure :: pic_daxpy module procedure :: pic_caxpy ! not tested module procedure :: pic_zaxpy ! not tested end interface pic_axpy interface pic_copy !! general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY !! !! Usage: call pic_copy(x, y) !! !! where x is the input vector, y is the output vector. !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! module procedure :: pic_scopy module procedure :: pic_dcopy module procedure :: pic_ccopy module procedure :: pic_zcopy end interface pic_copy interface pic_dot !! general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC !! !! Usage: result = pic_dot(x, y) !! !! where x is the input vector, y is the output vector. !! The vectors x and y must be allocatable arrays, we deduce the shapes from them. !! module procedure :: pic_sdot module procedure :: pic_ddot module procedure :: pic_cdotc module procedure :: pic_zdotc end interface pic_dot interface pic_scal !! general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL !! !! Usage: call pic_scal(x, [optional] alpha) !! !! where x is the input vector, alpha is the scaling factor. !! The vector x must be an allocatable array, we deduce the shape from it. !! The scaling factor alpha is 1.0 by default. !! module procedure :: pic_sscal module procedure :: pic_dscal module procedure :: pic_cscal module procedure :: pic_zscal end interface pic_scal interface pic_iamax !! general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX !! !! Usage: idx = pic_iamax(x, incx) !! !! where x is the input vector, incx is the increment. !! The vector x must be an allocatable array, we deduce the shape from it. !! The increment incx is 1 by default. !! module procedure :: pic_isamax module procedure :: pic_idamax module procedure :: pic_icamax module procedure :: pic_izamax end interface pic_iamax interface blas_asum !! this is the interface for the BLAS ASUM routines, it will call SASUM, DASUM, SCASUM, DZASUM !! Usage: result = blas_asum(x, incx) !! where x is the input vector, incx is the increment. !! !! This is not a public interface, it is used internally by pic_asum pure function sasum ( n , x , incx ) result ( res_sasum ) import :: sp , default_int implicit none real ( sp ) :: res_sasum real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function sasum pure function dasum ( n , x , incx ) result ( res_dasum ) import :: dp , default_int implicit none real ( dp ) :: res_dasum real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dasum pure function scasum ( n , x , incx ) result ( res_scasum ) import :: sp , default_int implicit none real ( sp ) :: res_scasum complex ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function scasum pure function dzasum ( n , x , incx ) result ( res_dzasum ) import :: dp , default_int implicit none real ( dp ) :: res_dzasum complex ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dzasum end interface blas_asum interface blas_axpy !! explicit interface for BLAS AXPY routines !! !! Usage: call blas_axpy(n, alpha, x, incx, y, incy) !! !! This is not a public interface, it is used internally by pic_axpy pure subroutine saxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine saxpy pure subroutine daxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine daxpy pure subroutine caxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine caxpy pure subroutine zaxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine zaxpy end interface blas_axpy interface blas_copy !! explicit interface for BLAS COPY routines !! !! Usage: call blas_copy(x, y) !! !! This is not a public interface, it is used internally by pic_copy pure subroutine scopy ( n , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine scopy pure subroutine dcopy ( n , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine dcopy pure subroutine ccopy ( n , x , incx , y , incy ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine ccopy pure subroutine zcopy ( n , x , incx , y , incy ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine zcopy end interface blas_copy interface blas_dot !! explicit interface for BLAS DOT routines !! !! Usage: result = blas_dot(x, y, incx, incy, n) !! This is not a public interface, it is used internally by pic_dot !! pure function sdot ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none real ( sp ) :: res real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function sdot pure function ddot ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none real ( dp ) :: res real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function ddot pure function cdotc ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none complex ( sp ) :: res complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function cdotc pure function zdotc ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none complex ( dp ) :: res complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function zdotc end interface blas_dot interface blas_scal !! explicit interface for BLAS SCAL routines !! !! Usage: call blas_scal(n, alpha, x, incx) !! !! This is not a public interface, it is used internally by pic_scal pure subroutine sscal ( n , alpha , x , incx ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine sscal pure subroutine dscal ( n , alpha , x , incx ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine dscal pure subroutine cscal ( n , alpha , x , incx ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine cscal pure subroutine zscal ( n , alpha , x , incx ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine zscal end interface blas_scal interface blas_iamax !! explicit interface for BLAS IAMAX routines !! !! Usage: idx = blas_iamax(x, incx) !! !! This is not a public interface, it is used internally by pic_iamax pure function isamax ( n , x , incx ) result ( idx ) import :: sp , default_int implicit none integer ( default_int ) :: idx real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function isamax pure function idamax ( n , x , incx ) result ( idx ) import :: dp , default_int implicit none integer ( default_int ) :: idx real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function idamax pure function icamax ( n , x , incx ) result ( idx ) import :: sp , default_int implicit none integer ( default_int ) :: idx complex ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function icamax pure function izamax ( n , x , incx ) result ( idx ) import :: dp , default_int implicit none integer ( default_int ) :: idx complex ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function izamax end interface blas_iamax interface blas_gemv !! explicit interface for BLAS GEMV routines !! !! Usage: call blas_gemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) !! !! This is not a public interface, it is used internally by pic_gemv pure subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemv pure subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemv pure subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemv pure subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemv end interface blas_gemv interface blas_gemm !! explicit interface for BLAS GEMM routines !! !! Usage: call blas_gemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) !! !! This is not a public interface, it is used internally by pic_gemm pure subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: b ( ldb , * ) real ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemm pure subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: b ( ldb , * ) real ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemm pure subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: b ( ldb , * ) complex ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemm pure subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: b ( ldb , * ) complex ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemm end interface blas_gemm contains pure subroutine pic_sgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: B (:, :) real ( sp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( sp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_sgemm pure subroutine pic_dgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: B (:, :) real ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_dgemm pure subroutine pic_zgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication complex ( dp ), intent ( in ) :: A (:, :) complex ( dp ), intent ( in ) :: B (:, :) complex ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb complex ( dp ), intent ( in ), optional :: alpha complex ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B complex ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_zgemm pure subroutine pic_sgemv ( A , x , y , trans_a , alpha , beta ) !! interface for single precision matrix-vector multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta real ( sp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_sgemv pure subroutine pic_dgemv ( A , x , y , trans_a , alpha , beta ) !! interface for double precision matrix-vector multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta real ( dp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_dgemv function pic_sasum ( x ) result ( res ) !! interface for single precision absolute sum real ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_sasum function pic_dasum ( x ) result ( res ) !! interface for double precision absolute sum real ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dasum function pic_scasum ( x ) result ( res ) !! interface for single precision complex absolute sum complex ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_scasum function pic_dzasum ( x ) result ( res ) !! interface for double precision complex absolute sum complex ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dzasum subroutine pic_saxpy ( x , y , alpha ) !! interface for single precision AXPY real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_saxpy subroutine pic_daxpy ( x , y , alpha ) !! interface for double precision AXPY real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_daxpy subroutine pic_caxpy ( x , y , alpha ) !! interface for single precision complex AXPY complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_caxpy subroutine pic_zaxpy ( x , y , alpha ) !! interface for double precision complex AXPY complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_zaxpy subroutine pic_scopy ( x , y ) !! interface for single precision copy real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_scopy subroutine pic_dcopy ( x , y ) !! interface for double precision copy real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_dcopy subroutine pic_ccopy ( x , y ) !! interface for single precision complex copy complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_ccopy subroutine pic_zcopy ( x , y ) !! interface for double precision complex copy complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_zcopy function pic_sdot ( x , y ) result ( res ) !! interface for single precision dot product real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( in ) :: y (:) real ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_sdot function pic_ddot ( x , y ) result ( res ) !! interface for double precision dot product real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( in ) :: y (:) real ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_ddot function pic_cdotc ( x , y ) result ( res ) !! interface for single precision complex dot product complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( in ) :: y (:) complex ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_cdotc function pic_zdotc ( x , y ) result ( res ) !! interface for double precision complex dot product complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( in ) :: y (:) complex ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_zdotc subroutine pic_sscal ( x , alpha ) !! interface for single precision scaling real ( sp ), intent ( inout ) :: x (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_sscal subroutine pic_dscal ( x , alpha ) !! interface for double precision scaling real ( dp ), intent ( inout ) :: x (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_dscal subroutine pic_cscal ( x , alpha ) !! interface for single precision complex scaling complex ( sp ), intent ( inout ) :: x (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_cscal subroutine pic_zscal ( x , alpha ) !! interface for double precision complex scaling complex ( dp ), intent ( inout ) :: x (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_zscal function pic_isamax ( x ) result ( idx ) !! interface for single precision index of maximum absolute value real ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_isamax function pic_idamax ( x ) result ( idx ) !! interface for double precision index of maximum absolute value real ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_idamax function pic_icamax ( x ) result ( idx ) !! interface for single precision complex index of maximum absolute value complex ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_icamax function pic_izamax ( x ) result ( idx ) !! interface for double precision complex index of maximum absolute value complex ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_izamax end module pic_blas_interfaces","tags":"","url":"sourcefile/pic_blas_interfaces.f90.html"},{"title":"pic_string_utils.f90 – PIC","text":"Life is easier when we have strings. This file\ncontains the necessary routines to transform key data\ntypes into strings This file depends on sourcefile~~pic_string_utils.f90~~EfferentGraph sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_string_utils.f90~~AfferentGraph sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer_v2.f90 pic_matrix_printer_v2.f90 sourcefile~pic_matrix_printer_v2.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Life is easier when we have strings. This file !! contains the necessary routines to transform key data !! types into strings module pic_string_utils !! General string utilities use pic_types , only : sp , dp , int32 , int64 , default_int implicit none ! Generic interface for to_string to handle different types private integer ( default_int ), parameter :: default_dp_precision = 12 integer ( default_int ) :: dp_precision = default_dp_precision public :: to_string , pad , to_upper public :: set_precision , get_precision interface to_string !! converts a variable of type (int32, int64, sp, dp, char, logical) !! to a \"string\" which is just a collecting of chars. !! !! Usage result = to_string(variable) !! !! @note the functions here are not elemental so they won't work for !! arrays. Please use pic_print_array_v2 module for this !! module procedure to_string_int32 module procedure to_string_int64 module procedure to_string_sp module procedure to_string_dp module procedure to_string_char module procedure to_string_logical end interface interface to_upper !! takes a character variable and transforms it to uppercase !! !! usage var = to_upper(\"hello\") !! module procedure to_upper end interface interface pad !! adds a number X of spaces to the left of a \"string\" whcih is just a !! collection of characters. Mostly used for nice printing !! !! Usage: var = pad(\"hello\", n_spaces) !! module procedure pad end interface interface set_precision !! This routine overrides the default dp precision used for !! printing strings in the to_string function, the default !! is : integer(default_int), parameter :: default_dp_precision = 12 !! !! Usage: call set_precision(variable) where variable is default_int !! module procedure set_precision end interface interface get_precision !! Obtain the current precision being used to print variables to strings !! !! Usage: precision = get_precision() !! !! returns a default_int result module procedure get_precision end interface contains function to_upper ( str ) result ( upper_str ) character ( len =* ), intent ( in ) :: str character ( len = len ( str )) :: upper_str integer ( default_int ) :: i character :: ch do i = 1 , len ( str ) ch = str ( i : i ) if ( ch >= 'a' . and . ch <= 'z' ) then upper_str ( i : i ) = char ( iachar ( ch ) - 32 ) else upper_str ( i : i ) = ch end if end do end function to_upper function pad ( s , width ) result ( padded ) !! function to pad a string with a certain number of characters for nice printing character ( len =* ), intent ( in ) :: s integer ( default_int ), intent ( in ) :: width character ( len = :), allocatable :: padded integer ( default_int ) :: len_s len_s = len_trim ( s ) if ( len_s >= width ) then padded = s ( 1 : width ) else padded = repeat ( \" \" , width - len_s ) // s end if end function pad subroutine set_precision ( precision ) !! Set the precision for real numbers integer ( default_int ), intent ( in ) :: precision if ( precision > 0 ) then dp_precision = precision else print * , \"Warning: Precision must be positive. Using default.\" dp_precision = default_dp_precision end if end subroutine set_precision function get_precision () result ( precision ) !! Get the current precision for real numbers integer ( default_int ) :: precision precision = dp_precision end function get_precision function to_string_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int32 function to_string_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int64 function to_string_sp ( r ) result ( trimmed_str ) !! transform a real(sp) to a string real ( kind = sp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_string_sp function to_string_dp ( r ) result ( trimmed_str ) !! transform a real(dp) to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str character ( len = 32 ) :: style !call write_with_precision(r, str) write ( style , '(A,I0,A)' ) '(F0.' , dp_precision , ')' write ( str , style ) r trimmed_str = trim ( str ) end function to_string_dp function to_string_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_string_char function to_string_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = \"TRUE\" else str = \"FALSE\" end if trimmed_str = trim ( str ) end function to_string_logical end module pic_string_utils","tags":"","url":"sourcefile/pic_string_utils.f90.html"},{"title":"pic_constants.f90 – PIC","text":"all things constants, physical, chemical, etc This file depends on sourcefile~~pic_constants.f90~~EfferentGraph sourcefile~pic_constants.f90 pic_constants.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_constants.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! all things constants, physical, chemical, etc module pic_constants !! this will be the physical constants module use pic_types , only : dp implicit none private real ( dp ), parameter , public :: gravity = 9.81_dp end module pic_constants","tags":"","url":"sourcefile/pic_constants.f90.html"},{"title":"pic_output_helpers.f90 – PIC","text":"this file contains “helper” routines, for example printing\na set amount of x characters to creates tables, etc. This file depends on sourcefile~~pic_output_helpers.f90~~EfferentGraph sourcefile~pic_output_helpers.f90 pic_output_helpers.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_output_helpers.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains \"helper\" routines, for example printing !! a set amount of x characters to creates tables, etc. module pic_output_helpers !! Assorted output helper routines use pic_types , only : default_int implicit none private public :: print_asterisk_row contains subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row end module pic_output_helpers","tags":"","url":"sourcefile/pic_output_helpers.f90.html"},{"title":"pic_helpers.f90 – PIC","text":"General helpers This file depends on sourcefile~~pic_helpers.f90~~EfferentGraph sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! General helpers module pic_test_helpers !! simple reusable helpers for random things use pic_types , only : int64 , dp , default_int , sp use pic_global_definitions , only : tol_sp , tol_dp implicit none private public :: dummy_work , is_equal interface is_equal !! The is equal interface is used to circumvent the fact that Fortran, rightfully, complains about !! comparing two reals without involving a tolerance, i.e. if(a == b) since there is no guarantee that !! the two reals are exactly equal due to floating point precision issues. The functions are defined as elemental !! !! Usage: if (is_equal(a, b)) then !! where a and b are real numbers, and the function will return true if they are !! equal within the tolerance defined in pic_global_definitions. module procedure is_equal_sp module procedure is_equal_dp end interface is_equal contains elemental function is_equal_sp ( a , b ) result ( res ) real ( sp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_sp end function is_equal_sp elemental function is_equal_dp ( a , b ) result ( res ) real ( dp ), intent ( in ) :: a , b logical :: res res = abs ( a - b ) < tol_dp end function is_equal_dp subroutine dummy_work () !! this subroutine runs a random dgemm to create work so that timers and other testing utils work nicely !! !! Usage: call dummy_work() !! !! it will simply do a 256 by 256 dgemm, woo integer ( int64 ) :: i , j , k integer ( default_int ) :: m real ( dp ), allocatable :: A (:, :), B (:, :), C (:, :) m = 256_default_int allocate ( A ( m , m ), B ( m , m ), C ( m , m )) A = 1.0_dp B = 1.0_dp C = 0.0_dp do i = 1 , m do j = 1 , m do k = 1 , m C ( i , j ) = C ( i , j ) + A ( i , k ) * B ( k , j ) end do end do end do print * , C ( 1 , 1 ) deallocate ( A , B , C ) end subroutine dummy_work end module pic_test_helpers","tags":"","url":"sourcefile/pic_helpers.f90.html"},{"title":"pic_array.f90 – PIC","text":"pic array contains L0.5 BLAS level routines, as in things that could be use in\nlieu of blas if you don’t have it but if you do, please don’t use these routines This file depends on sourcefile~~pic_array.f90~~EfferentGraph sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_array.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! pic array contains L0.5 BLAS level routines, as in things that could be use in !! lieu of blas if you don't have it but if you do, please don't use these routines module pic_array !! Please do not modify this file to implement new methods, please go look at tools/autogen/pic_array_cpu.fypp !! and edit the generator. use pic_types , only : sp , dp , int32 , int64 , default_int implicit none private public :: fill , copy , pic_transpose , pic_sum public :: is_sorted public :: set_threading_mode , get_threading_mode logical :: use_threaded_default = . false . public :: ASCENDING , DESCENDING integer ( default_int ), parameter :: ASCENDING = 1 integer ( default_int ), parameter :: DESCENDING = 2 interface set_threading_mode !! set_threading sets the threading mode for the array routines !! this will set the use_threaded variable to true or false depending on the input !! Usage: call set_threading_mode(.true.) or call set_threading_mode(.false.) module procedure set_threading_mode end interface interface get_threading_mode !! get_threading_mode returns the current threading mode for the array routines !! Usage: mode = get_threading_mode() module procedure get_threading_mode end interface get_threading_mode interface fill !! fill provides a generic interface to assing a value !! alpha of types (int32, int64, sp, dp) as defined in pic_types.F90 !! The inteface supports filling 1d and 2d arrays of the specified !! variables !! !! Usage: call fill(array, value, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to .true. !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism module procedure fill_vector_int32 module procedure fill_vector_int64 module procedure fill_vector_sp module procedure fill_vector_dp module procedure fill_matrix_int32 module procedure fill_matrix_int64 module procedure fill_matrix_sp module procedure fill_matrix_dp end interface interface copy !! copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy !! if you built pic with BLAS use the copy interface provided there, I will not beat BLAS !! copy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types !! !! Usage: call copy(destination, source, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to .true. !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism module procedure copy_vector_int32 module procedure copy_vector_int64 module procedure copy_vector_sp module procedure copy_vector_dp module procedure copy_matrix_int32 module procedure copy_matrix_int64 module procedure copy_matrix_sp module procedure copy_matrix_dp end interface interface pic_transpose !! pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic !! which will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices !! !! pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays !! !! Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to true !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism !! module procedure transpose_matrix_int32 module procedure transpose_matrix_int64 module procedure transpose_matrix_sp module procedure transpose_matrix_dp end interface interface pic_sum !! pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will !! be too slow for large sizes of vectors and matrices. Note that this provides the total !! sum. As opposed to the blas alternative XASUM which does the absolute sum !! !! pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays !! !! Usage: result = pic_sum(array, [optional] threaded) !! !! This subroutine is threaded for performance purposes if threaded is set to true !! !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism !! module procedure sum_vector_int32 module procedure sum_vector_int64 module procedure sum_vector_sp module procedure sum_vector_dp module procedure sum_matrix_int32 module procedure sum_matrix_int64 module procedure sum_matrix_sp module procedure sum_matrix_dp end interface interface is_sorted !! is_sorted provides a simple way to checking if a 1d array is sorted !! it is implemented for int32, int64, sp, and dp datatypes. The default !! is to check if an array is sorted in ascending fashion. !! !! Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING) module procedure is_sorted_int32 module procedure is_sorted_int64 module procedure is_sorted_sp module procedure is_sorted_dp end interface ! potentially implement a shallow copy? nah? integer ( default_int ), parameter :: block_size = 32 !! This is the size to block over for matrices for performance purposes contains subroutine set_threading_mode ( threaded ) !! set the threading mode for the array routines, this will set the use_threaded variable !! to true or false depending on the input !! !! Usage: call set_threading(.true.) or call set_threading(.false.) logical , intent ( in ) :: threaded use_threaded_default = threaded end subroutine set_threading_mode function get_threading_mode () result ( mode ) !! get the current threading mode for the array routines !! Usage: mode = get_threading_mode() logical :: mode mode = use_threaded_default end function get_threading_mode subroutine fill_vector_int32 ( vector , alpha , threaded ) integer ( int32 ), intent ( inout ) :: vector (:) integer ( int32 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int32 subroutine fill_vector_int64 ( vector , alpha , threaded ) integer ( int64 ), intent ( inout ) :: vector (:) integer ( int64 ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_int64 subroutine fill_vector_sp ( vector , alpha , threaded ) real ( sp ), intent ( inout ) :: vector (:) real ( sp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_sp subroutine fill_vector_dp ( vector , alpha , threaded ) real ( dp ), intent ( inout ) :: vector (:) real ( dp ), intent ( in ) :: alpha logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( vector , 1 ) vector ( i ) = alpha end do !$omp end parallel do else vector = alpha end if end subroutine fill_vector_dp subroutine fill_matrix_int32 ( matrix , alpha , threaded ) integer ( int32 ), intent ( inout ) :: matrix (:, :) integer ( int32 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int32 subroutine fill_matrix_int64 ( matrix , alpha , threaded ) integer ( int64 ), intent ( inout ) :: matrix (:, :) integer ( int64 ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_int64 subroutine fill_matrix_sp ( matrix , alpha , threaded ) real ( sp ), intent ( inout ) :: matrix (:, :) real ( sp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_sp subroutine fill_matrix_dp ( matrix , alpha , threaded ) real ( dp ), intent ( inout ) :: matrix (:, :) real ( dp ), intent ( in ) :: alpha integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj logical , intent ( in ), optional :: threaded logical :: use_threads rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) matrix ( i , j ) = alpha end do end do end do end do !$omp end parallel do else matrix = alpha end if end subroutine fill_matrix_dp subroutine copy_vector_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:) integer ( int32 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int32 subroutine copy_vector_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:) integer ( int64 ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_int64 subroutine copy_vector_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:) real ( sp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_sp subroutine copy_vector_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:) real ( dp ), intent ( in ) :: source (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i if ( size ( dest , 1 ) /= size ( source , 1 )) then error stop \"Vector size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(1) private(i) do i = 1 , size ( dest , 1 ) dest ( i ) = source ( i ) end do !$omp end parallel do else dest = source end if end subroutine copy_vector_dp subroutine copy_matrix_int32 ( dest , source , threaded ) integer ( int32 ), intent ( inout ) :: dest (:, :) integer ( int32 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int32 subroutine copy_matrix_int64 ( dest , source , threaded ) integer ( int64 ), intent ( inout ) :: dest (:, :) integer ( int64 ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_int64 subroutine copy_matrix_sp ( dest , source , threaded ) real ( sp ), intent ( inout ) :: dest (:, :) real ( sp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_sp subroutine copy_matrix_dp ( dest , source , threaded ) real ( dp ), intent ( inout ) :: dest (:, :) real ( dp ), intent ( in ) :: source (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , rows , cols integer ( default_int ) :: ii , jj if ( size ( dest , 1 ) /= size ( source , 1 ) . or . size ( dest , 2 ) /= size ( source , 2 )) then error stop \"Matrix size mismatch\" end if rows = size ( source , 1 ) cols = size ( source , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) dest ( i , j ) = source ( i , j ) end do end do end do end do !$omp end parallel do else dest = source end if end subroutine copy_matrix_dp subroutine transpose_matrix_int32 ( A , B , threaded ) integer ( int32 ), intent ( in ) :: A (:, :) integer ( int32 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int32 subroutine transpose_matrix_int64 ( A , B , threaded ) integer ( int64 ), intent ( in ) :: A (:, :) integer ( int64 ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_int64 subroutine transpose_matrix_sp ( A , B , threaded ) real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_sp subroutine transpose_matrix_dp ( A , B , threaded ) real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( out ) :: B (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( default_int ) :: i , j , ii , jj , rows , cols rows = size ( A , 1 ) cols = size ( A , 2 ) if ( size ( B , 1 ) /= cols . or . size ( B , 2 ) /= rows ) then error stop \"transpose: size mismatch\" end if if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) B ( j , i ) = A ( i , j ) end do end do end do end do !$omp end parallel do else B = transpose ( A ) end if end subroutine transpose_matrix_dp function sum_vector_int32 ( vector , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: i res = 0_int32 if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int32 function sum_vector_int64 ( vector , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: i res = 0_int64 if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_int64 function sum_vector_sp ( vector , threaded ) result ( res ) real ( sp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: i res = 0_sp if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_sp function sum_vector_dp ( vector , threaded ) result ( res ) real ( dp ), intent ( in ) :: vector (:) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: i res = 0_dp if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if if ( use_threads ) then !$omp parallel do private(i) collapse(1) reduction(+:res) do i = 1 , size ( vector , 1 ) res = res + vector ( i ) end do !$omp end parallel do else res = sum ( vector ) end if end function sum_vector_dp function sum_matrix_int32 ( matrix , threaded ) result ( res ) integer ( int32 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int32 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_int32 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int32 function sum_matrix_int64 ( matrix , threaded ) result ( res ) integer ( int64 ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads integer ( int64 ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_int64 if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_int64 function sum_matrix_sp ( matrix , threaded ) result ( res ) real ( sp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( sp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_sp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_sp function sum_matrix_dp ( matrix , threaded ) result ( res ) real ( dp ), intent ( in ) :: matrix (:, :) logical , intent ( in ), optional :: threaded logical :: use_threads real ( dp ) :: res integer ( default_int ) :: cols , rows , i , j , ii , jj rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) if ( present ( threaded )) then use_threads = threaded else use_threads = use_threaded_default end if res = 0_dp if ( use_threads ) then !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res) do jj = 1 , cols , block_size do ii = 1 , rows , block_size do j = jj , min ( jj + block_size - 1 , cols ) do i = ii , min ( ii + block_size - 1 , rows ) res = res + matrix ( i , j ) end do end do end do end do !$omp end parallel do else res = sum ( matrix ) end if end function sum_matrix_dp pure function is_sorted_int32 ( array , order ) result ( sorted ) integer ( int32 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int32 pure function is_sorted_int64 ( array , order ) result ( sorted ) integer ( int64 ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_int64 pure function is_sorted_sp ( array , order ) result ( sorted ) real ( sp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_sp pure function is_sorted_dp ( array , order ) result ( sorted ) real ( dp ), intent ( in ) :: array (:) integer ( default_int ), intent ( in ), optional :: order integer ( default_int ) :: sort_order integer ( default_int ) :: i logical :: sorted sorted = . true . sort_order = ASCENDING if ( present ( order )) then sort_order = order end if select case ( sort_order ) case ( DESCENDING ) do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) > array ( i )) then sorted = . false . return end if end do case default ! ASCENDING or any other value do i = 1 , size ( array ) - 1 if ( array ( i + 1 ) < array ( i )) then sorted = . false . return end if end do end select end function is_sorted_dp end module pic_array","tags":"","url":"sourcefile/pic_array.f90.html"},{"title":"pic_flop_recorder.f90 – PIC","text":"flop recorder This file depends on sourcefile~~pic_flop_recorder.f90~~EfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_flop_recorder.f90~~AfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop recorder module pic_flop_recorder !! general flop recorder module use pic_types , only : int64 implicit none private public :: flop_recorder_type type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure :: add => add_flops procedure :: get => get_flops procedure :: reset => reset_flop_counter end type flop_recorder_type contains subroutine add_flops ( self , flops ) !! Add an int64 variable which contains the FLOPs !! we use int64 since we might reach very large FLOP counts !! !! Usage: call my_flop_recorder%add(flops) !! class ( flop_recorder_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops self % flop_count = self % flop_count + flops end subroutine add_flops function get_flops ( self ) result ( flops ) !! Get the int64 number of FLOPs we currently have in the counter !! !! Usage: flops = my_flop_recorder%get() !! class ( flop_recorder_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % flop_count end function get_flops subroutine reset_flop_counter ( self ) !! Resets the flop counter to 0_int64 !! !! Usage: call my_flop_recorder%reset() !! class ( flop_recorder_type ), intent ( inout ) :: self self % flop_count = 0_int64 end subroutine reset_flop_counter end module pic_flop_recorder","tags":"","url":"sourcefile/pic_flop_recorder.f90.html"},{"title":"pic_mpi.F90 – PIC","text":"The pic_mpi.F90 file is the main interface to the MPI implementation, it should\nbe done in such a way that we can compile the library with and without MPI\nit will be a pain in general, but meh, let’s see what we can do This file depends on sourcefile~~pic_mpi.f90~~EfferentGraph sourcefile~pic_mpi.f90 pic_mpi.F90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_mpi.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! The pic_mpi.F90 file is the main interface to the MPI implementation, it should !! be done in such a way that we can compile the library with and without MPI !! it will be a pain in general, but meh, let's see what we can do module pic_mpi !! General MPI interface module use pic_types , only : int32 use mpi_f08 , only : MPI_COMM , MPI_COMM_WORLD , MPI_Init , MPI_Finalize , & MPI_Comm_size , MPI_Comm_rank implicit none private public :: pic_comm_type type :: pic_comm_type !! custom data type that holds the MPI communicators private type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface integer ( int32 ), public :: m_rank !! MPI rank integer ( int32 ), public :: m_size !! MPI size integer ( int32 ), public :: m_ierr contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm_type type ( pic_comm_type ), public :: world_comm !! our world comm contains subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr , rank , size call MPI_Init ( ierr ) self % m_ierr = ierr self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank end subroutine pic_comm_init subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm_type ), intent ( inout ) :: self integer ( int32 ) :: ierr call MPI_Finalize ( ierr ) self % m_ierr = ierr end subroutine pic_comm_finalize end module pic_mpi","tags":"","url":"sourcefile/pic_mpi.f90.html"},{"title":"pic_types.F90 – PIC","text":"pic_types.F90 controls the standarized sizes for the datatypes across\npic, this is key for interfacing with other codes specially those that\nuse default sizes Files dependent on this one sourcefile~~pic_types.f90~~AfferentGraph sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_array.f90 pic_array.f90 sourcefile~pic_array.f90->sourcefile~pic_types.f90 sourcefile~pic_blas_interfaces.f90 pic_blas_interfaces.F90 sourcefile~pic_blas_interfaces.f90->sourcefile~pic_types.f90 sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 sourcefile~pic_constants.f90 pic_constants.f90 sourcefile~pic_constants.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 sourcefile~pic_helpers.f90 pic_helpers.f90 sourcefile~pic_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_helpers.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer_v2.f90 pic_matrix_printer_v2.f90 sourcefile~pic_matrix_printer_v2.f90->sourcefile~pic_types.f90 sourcefile~pic_matrix_printer_v2.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_mpi.f90 pic_mpi.F90 sourcefile~pic_mpi.f90->sourcefile~pic_types.f90 sourcefile~pic_optional.f90 pic_optional.f90 sourcefile~pic_optional.f90->sourcefile~pic_types.f90 sourcefile~pic_output_helpers.f90 pic_output_helpers.f90 sourcefile~pic_output_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! pic_types.F90 controls the standarized sizes for the datatypes across !! pic, this is key for interfacing with other codes specially those that !! use default sizes module pic_types !! main module for defining types for integer and double precision use , intrinsic :: iso_fortran_env , only : int32 , int64 implicit none private public :: int32 , int64 ! Define kinds for different data types ! int32 and int64 are defined in the iso_fortran_env, if you need to change things please do so here integer , parameter , public :: sp = SELECTED_REAL_KIND ( 6 , 37 ) !! single precision size integer , parameter , public :: dp = SELECTED_REAL_KIND ( 15 , 307 ) !! double precision size integer , parameter , public :: qp = SELECTED_REAL_KIND ( 33 , 4931 ) !! quadruple precision size, varies by compiler ! Define default types #ifdef USE_INT8 integer , parameter , public :: default_int = int64 !! if you compile PIC requesting USE_INT8 the default_int will be set to int64 this is kinda equivalent !! to compiling with -i8. If linking to a legacy codebase that relies on this, compile PIC with USE_INT8 #else integer , parameter , public :: default_int = int32 !! the default integer kind in PIC is int32 which faciliates the interfaces to MPI !! pay special attention if linking PIC to a code that use default int size of 8 #endif integer , parameter , public :: default_real = dp !! naturally, our default real is double precision integer , parameter , public :: default_complex = dp !! default complex is double precision end module pic_types","tags":"","url":"sourcefile/pic_types.f90.html"},{"title":"pic_command_line.f90 – PIC","text":"The pic_command_line.f90 file will contain all routines that will interact with the command line This file depends on sourcefile~~pic_command_line.f90~~EfferentGraph sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! The pic_command_line.f90 file will contain all routines that will interact with the command line module pic_command_line !! command line interaction module use pic_types , only : default_int implicit none private public :: get_first_arg_from_command_line contains function get_first_arg_from_command_line () result ( filename ) !! get the first argument from the command line, this is expected to be a filename !! !! Usage: filename = get_first_arg_from_command_line() !! character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line end module pic_command_line","tags":"","url":"sourcefile/pic_command_line.f90.html"},{"title":"pic.f90 – PIC","text":"the main pic module interface: versions, banners, random quotes etc will go here Source Code !! the main pic module interface: versions, banners, random quotes etc will go here module pic !! simple interface module that prints banner and other information about the library !! mostly here to verify installs, etc. implicit none private public :: pic_print_banner contains subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" end subroutine pic_print_banner end module pic","tags":"","url":"sourcefile/pic.f90.html"},{"title":"pic_debugging_tools.f90 – PIC","text":"This file is intended to contain tools that can be useful when debugging\nlarge programs, simple printing routines, extracting data from an array etc. This file depends on sourcefile~~pic_debugging_tools.f90~~EfferentGraph sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file is intended to contain tools that can be useful when debugging !! large programs, simple printing routines, extracting data from an array etc. module pic_debugging_tools !! simple single include for printing routines use pic_matrix_printer , only : print_array , print_array_with_bounds use pic_string_utils , only : to_string implicit none private contains end module pic_debugging_tools","tags":"","url":"sourcefile/pic_debugging_tools.f90.html"},{"title":"pic_timer.F90 – PIC","text":"timing routines in general This file depends on sourcefile~~pic_timer.f90~~EfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_timer.f90~~AfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! timing routines in general module pic_timer !! contains a simple timer module to measure and record time use pic_types , only : dp , default_int use pic_string_utils , only : to_string #ifdef _OPENMP use omp_lib , only : omp_get_wtime #endif implicit none private public :: pic_timer_type type :: pic_timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp. If PIC is compiled with OpenMP the default !! timer will be the omp time. This is mostly to minimize problems with threading !! and system clock private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time end type pic_timer_type contains subroutine timer_start ( self ) !! starts the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%start() !! !! Usage assumes a declaration of type(pic_timer_type) :: my_timer class ( pic_timer_type ), intent ( inout ) :: self self % is_running = . true . #ifdef _OPENMP self % start_time = omp_get_wtime () #else call system_clock ( self % start_count , self % count_rate ) #endif end subroutine timer_start subroutine timer_stop ( self ) !! stop the timer. If OMP is enabled, it will use omp_get_wtime() !! if not, it will use Fortran's system_clock !! !! Usage: call my_timer%stop() !! !! Usage assumes a declaration of type(pic_timer_type) :: my_timer !! will fail if a timer has not been started! class ( pic_timer_type ), intent ( inout ) :: self if (. not . self % is_running ) then error stop \"Cannot stop a timer that has not been started!\" end if #ifdef _OPENMP self % stop_time = omp_get_wtime () #else call system_clock ( self % stop_count ) #endif ! if someone stops the timer, we stop ! self % is_running = . false . end subroutine timer_stop subroutine timer_print_time ( self ) !! Prints the elapsed time at the time of calling !! !! Usage: call my_timer%print_time() !! !! Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer !! !! This function does not stop the timer, it will get the current time elapsed stopped or not class ( pic_timer_type ), intent ( in ) :: self real ( dp ) :: elapsed elapsed = self % get_elapsed_time () if ( self % is_running ) then print * , \"Currently elapsed time: \" // to_string ( elapsed ) // \" seconds\" else print * , \"Elapsed time: \" // to_string ( elapsed ) // \" seconds\" end if end subroutine timer_print_time function timer_get_elapsed_time ( self ) result ( elapsed ) !! Returns the elapsed time as a real(dp) variable !! !! Usage: var = my_timer%get_elapsed_time() !! !! Needs my_timer to be declared previously as type(pic_timer_type) :: my_timer !! class ( pic_timer_type ), intent ( in ) :: self real ( dp ) :: elapsed integer ( default_int ) :: current_count elapsed = 0.0_dp #ifdef _OPENMP if ( self % is_running ) then elapsed = omp_get_wtime () - self % start_time else elapsed = self % stop_time - self % start_time end if #else if ( self % is_running ) then call system_clock ( count = current_count ) elapsed = real ( current_count - self % start_count , dp ) / real ( self % count_rate , dp ) else elapsed = real ( self % stop_count - self % start_count , dp ) / real ( self % count_rate , dp ) end if #endif end function timer_get_elapsed_time end module pic_timer","tags":"","url":"sourcefile/pic_timer.f90.html"},{"title":"pic_matrix_printer_v2.f90 – PIC","text":"This is v2 of the matrix printer module, a single interface for printing arrays of various types and in various formats This file depends on sourcefile~~pic_matrix_printer_v2.f90~~EfferentGraph sourcefile~pic_matrix_printer_v2.f90 pic_matrix_printer_v2.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_matrix_printer_v2.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_matrix_printer_v2.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This is v2 of the matrix printer module, a single interface for printing arrays of various types and in various formats module pic_matrix_printer_v2 !! Generic module for printing arrays use pic_types , only : sp , dp , int32 , int64 , default_int use pic_string_utils , only : to_string , to_upper implicit none private public :: print_array_v2 interface print_array_v2 !! Generic interface for printing arrays of different types !! !! Usage: call print_array_v2(array, [optional] format) !! Where format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps) !! !! Implemented types are: !! !! array(:)   -> int32, int64, sp, dp !! !! array(:,:) -> int32, int64, sp, dp !! !! array(:) (packed matrix) -> sp, dp !! !! array(:,:,:) -> sp, dp !! module procedure print_vector_int32 module procedure print_vector_int64 module procedure print_vector_sp module procedure print_vector_dp module procedure print_matrix_int32 module procedure print_matrix_int64 module procedure print_matrix_sp module procedure print_matrix_dp module procedure print_packed_matrix_int32 module procedure print_packed_matrix_int64 module procedure print_packed_matrix_sp module procedure print_packed_matrix_dp module procedure print_3d_tensor_sp module procedure print_3d_tensor_dp end interface print_array_v2 character ( len = 5 ), parameter :: default_format = \"NUMPY\" !! supported formats: NUMPY, MATHEMATICA, and PLAIN which resembles numpy character ( len =* ), parameter :: fmt_edge = \"(A)\" character ( len =* ), parameter :: fmt_in = '(A, \", \")' contains subroutine set_brackets ( format_type , open_bracket , close_bracket ) !! Set brackets based on output format type character ( len =* ), intent ( in ) :: format_type character ( len = 1 ), intent ( out ) :: open_bracket , close_bracket select case ( trim ( to_upper ( adjustl ( format_type )))) case ( \"NUMPY\" ) open_bracket = \"[\" close_bracket = \"]\" case ( \"MATHEMATICA\" ) open_bracket = \"{\" close_bracket = \"}\" case ( \"PLAIN\" ) open_bracket = \"[\" close_bracket = \"]\" case default print * , \"Warning: Unsupported format type '\" // trim ( format_type ) // \"'. Defaulting to NumPy style.\" open_bracket = \"[\" close_bracket = \"]\" end select end subroutine set_brackets subroutine print_vector_int32 ( vector , format_type ) !! print a vector of int32 values integer ( int32 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int32 subroutine print_vector_int64 ( vector , format_type ) !! print a vector of int64 values integer ( int64 ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int64 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_int64 subroutine print_vector_sp ( vector , format_type ) !! print a vector of sp values real ( sp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_sp subroutine print_vector_dp ( vector , format_type ) !! print a vector of dp values real ( dp ), intent ( in ) :: vector (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , loop_bound_i loop_bound_i = size ( vector ) call set_brackets ( print_format , open_bracket , close_bracket ) write ( * , \"(A)\" , advance = \"no\" ) open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) to_string ( vector ( i )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( vector ( i )) end if end do print * , close_bracket end block print end subroutine print_vector_dp subroutine print_matrix_int32 ( matrix , format_type ) !! print a matrix of int32 values integer ( int32 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int32 subroutine print_matrix_int64 ( matrix , format_type ) !! print a matrix of int64 values integer ( int64 ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_int64 subroutine print_matrix_sp ( matrix , format_type ) !! print a matrix of sp values real ( sp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_sp subroutine print_matrix_dp ( matrix , format_type ) !! print a matrix of dp values real ( dp ), intent ( in ) :: matrix (:, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , rows , cols rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do i = 1 , rows write ( * , \"(A)\" , advance = \"no\" ) open_bracket do j = 1 , cols if ( j == cols ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) to_string ( matrix ( i , j )) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) to_string ( matrix ( i , j )) end if end do if ( i == rows ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end block print end subroutine print_matrix_dp subroutine print_packed_matrix_int32 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of int32 values integer ( int32 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( int32 ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_int32 + sqrt ( 1.0_int32 + 8.0_int32 * real ( n_elements , int32 ))) / 2.0_int32 n = int ( n_real + 0.5_int32 ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int32 subroutine print_packed_matrix_int64 ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of int64 values integer ( int64 ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( int64 ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_int64 + sqrt ( 1.0_int64 + 8.0_int64 * real ( n_elements , int64 ))) / 2.0_int64 n = int ( n_real + 0.5_int64 ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_int64 subroutine print_packed_matrix_sp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of sp values real ( sp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( sp ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_sp + sqrt ( 1.0_sp + 8.0_sp * real ( n_elements , sp ))) / 2.0_sp n = int ( n_real + 0.5_sp ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_sp subroutine print_packed_matrix_dp ( packed , n_elements , format_type ) !! Print a packed lower triangular matrix of dp values real ( dp ), intent ( in ) :: packed (:) integer ( default_int ), intent ( in ) :: n_elements character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format character ( len = 1 ) :: open_bracket , close_bracket integer ( default_int ) :: i , j , idx , n real ( dp ) :: n_real ! Determine format if ( present ( format_type )) then print_format = trim ( adjustl ( format_type )) else print_format = \"NUMPY\" end if call set_brackets ( print_format , open_bracket , close_bracket ) ! Compute n from packed size n_real = ( - 1.0_dp + sqrt ( 1.0_dp + 8.0_dp * real ( n_elements , dp ))) / 2.0_dp n = int ( n_real + 0.5_dp ) if ( n * ( n + 1 ) / 2 /= n_elements ) then print * , \"Error: n_elements does not form a valid packed triangle\" return end if ! Print lower triangle directly from packed array print * , open_bracket idx = 0 do i = 1 , n write ( * , '(A)' , advance = \"no\" ) open_bracket do j = 1 , i idx = idx + 1 if ( j == i ) then write ( * , '(A)' , advance = \"no\" ) to_string ( packed ( idx )) else write ( * , '(A)' , advance = \"no\" ) trim ( to_string ( packed ( idx )) // \", \" ) end if end do if ( i == n ) then print * , close_bracket else print * , close_bracket , \",\" end if end do print * , close_bracket end subroutine print_packed_matrix_dp subroutine print_3d_tensor_sp ( matrix , format_type ) !! Print a 3D tensor of sp values real ( sp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call print_array_v2 ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_sp subroutine print_3d_tensor_dp ( matrix , format_type ) !! Print a 3D tensor of dp values real ( dp ), intent ( in ) :: matrix (:, :, :) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: print_format if ( present ( format_type )) then print_format = format_type else print_format = default_format end if print : block character ( len = 1 ) :: open_bracket , close_bracket integer ( int32 ) :: i , j , k , rows , cols , depth rows = size ( matrix , 1 ) cols = size ( matrix , 2 ) depth = size ( matrix , 3 ) call set_brackets ( print_format , open_bracket , close_bracket ) print * , open_bracket do k = 1 , depth if ( k > 1 ) print * , \",\" print * , open_bracket call print_array_v2 ( matrix (:, :, k ), print_format ) print * , close_bracket end do print * , close_bracket end block print end subroutine print_3d_tensor_dp end module pic_matrix_printer_v2","tags":"","url":"sourcefile/pic_matrix_printer_v2.f90.html"},{"title":"About PIC – PIC","text":"Todo I want a logo. If you are a graphics artist and want to help me design a logo, please reach out to me! I will pay you. Reasoning behind PIC In my relatively short career as a programmer I have used multiple languages: C, C++, Python, Julia, Bash, and of course, Fortran. During this time I have explored multiple avenues within each of the languages and have written quite a bit of code in most of them. Probably\nthe one I’ve written the most code in is C++, since I was one of the main contributors the GAMESS-ECP project that saw the\ncreation of GMS-HPC and the initial lines of code of what would become EXESS. While I was a postdoc at the Barca group I had the joy of meeting some of the best computer scientists I’ve ever met. I quickly realized\nthat I was John Snow, I didn’t know anything. It was the first time that I had the opportunity to colaborate closely with people that were trained in computer science and software engineering. Before that I lived in the academic programming world, which is mostly a “WRITE CODE, PUBLISH PAPER, GET GRANT” type of mindset. If a code\nworks, nice, you go ahead and publish a paper on it. Is the code good? Most of the times the answer to this is: no. I was fortunate enough to be a part of the rewriting of the EXESS codebase. Lead by, hopefully soon to be, Dr. Ryan Stocks we rewrote\nthe entire thing using some very cool features of the C++ language and tightly coupled it with MPI, CUDA/HIP, and ran some of the largest and and most performant simulations ever done. We even won a Gordon Bell prize in 2024 because of this! In the end this was a gigantic team effort which wouldn’t have been possible without the contributions done by the entire team and the money provided by Dr Barca’s company QDX. Without this it would have been impossible to rewrite the entire code the way we did. After leaving my position as a postdoc at the Barca group I joined the National Computational Infrastructure (NCI) in Canberra where\nI could put to use all of my HPC and software engineering knowledge to test in other domains outside of computational quanutm chemistry. In my last year or so of my postdoc I took up a big interest in the Fortran programming language. I had used it before during my undergrad and early PhD but the ECP project had pushed me to full C++ and CUDA for GPU support. I discovered the beautiful community that is the Fortran Discourse and the associated projects people associated to it have undertaken. Examples are the Fortran Package Manager, the Fortran Standard Library and the LFortran compiler. I found a community of people that I hadn’t found in the C/C++ world and this drove me to start exploring the language a bit more. Why Fortran Fortran is an old language and with age comes lots of baggage. A lot of Fortran’s perceived baggage is due to legacy codes that use\nold language constructs that are no longer in the standard or just simply bad academic code. I somehow dislike the idea of the existence of Modern Fortran, but since there is also Modern C++ I wonder if my dislike is not reasonble. Modern Fortran or from now on just “Fortran” is whatever the language became since the release of Fortran 90 and beyond. People usually associate Fortran with code that looks like: PROGRAM MAIN IMPLICIT DOUBLE PRECISION ( A - H , O - Z ) REAL * 8 HTY , FTY , HUY , RUY CALL MTRBR ( ABC , BAC , CDF , EFG , DFGE , ASY ) IF ( VAR . EQ . TRUE ) THEN GOTO 500 ENDIF ... 500 PRINT * , \"YOU FOOL!\" END PROGRAM MAIN The ugly all caps; undescriptive, short variable names; the use of GOTO statements, and of course, the code starting in the 7 column. There is a lot of code that looks like this yes, however, new Fortran does not look like this at all. This is the famed transition\nfrom fixed to free format Fortran which lets one write code in whichever column you want to write. New Fortran looks quite differnt and I’d dare even say similar to other language, like Julia maybe. For example, this snippet of code from PIC itself: subroutine fill_vector_int64(vector, alpha, threaded)\n      integer(int64), intent(inout) :: vector(:)\n      integer(int64), intent(in)    :: alpha\n      logical, intent(in), optional :: threaded\n      logical :: use_threads\n      integer(default_int) :: i\n\n      if (present(threaded)) then\n         use_threads = threaded\n      else\n         use_threads = use_threaded_default\n      end if\n      if (use_threads) then\n         !$omp parallel do collapse(1) private(i)\n         do i = 1, size(vector, 1)\n            vector(i) = alpha\n         end do\n         !$omp end parallel do\n      else\n         vector = alpha\n      end if\n\n   end subroutine fill_vector_int64 There is nothing “ugly” to look at here. Everything is nice lower caps with nice spacing. Variable names mean something\nto anyone that can speak english and I even showcase the use of OMP parallelism. One thing that you might comment on here “Oh, ew, you have to declare everything at the start like in C89”. And yeah,\nI see that comment a lot. HOWEVER. This is not the case anymore. I just did it like this here because the subroutine is rather small. Fortran has introduced the concept of blocks which are used to determine scope in a program, very similar to the {} in C/C++. For example, the above code could be rewritten as: subroutine fill_vector_int64(vector, alpha, threaded)\n      integer(int64), intent(inout) :: vector(:)\n      integer(int64), intent(in)    :: alpha\n      logical, intent(in), optional :: threaded\n      logical :: use_threads\n\n      if (present(threaded)) then\n         use_threads = threaded\n      else\n         use_threads = use_threaded_default\n      end if\n      if (use_threads) then\n      loop: block\n        integer(default_int) :: i\n         !$omp parallel do collapse(1) private(i)\n         do i = 1, size(vector, 1)\n            vector(i) = alpha\n         end do\n         !$omp end parallel do\n      end block loop\n      else\n         vector = alpha\n      end if\n\n   end subroutine fill_vector_int64 And now we’ve limited the scope of the i variable in the program. Blocks can be named or also omitted. I.e. you could ommit the name loop: and you’d still be fine. You can nest blocks in blocks, they just delimit the scope of variables. Now you might wonder, why do I need to say what size of int ? why am I using a default_int size for my integer. Well, this is one of\nthe things in PIC that had to be done in order for the code to be interfaceable with legacy Fortran applications. You see, in the old days, codes that wanted to use int64 or double precision , i.e. fp64 , had to use something similar to real(8) :: my_var this meant the number of bits used to represent the variable. People back then were lazy and the computers\ndid not help for this. You could tell the compiler to make all integer or real variables a default of int64 and double precision . This way all of your integers and reals would always be the precision you wanted them to be. This is unsurprisingly a very bad design decision. This makes it such that if any code wants to interface with your code the sizes of integers and reals need to match. This becomes\nextraordinarily painful if interfacing with C/C++ codes. Therefore, to avoid using this compiler flags I’ve set up PIC so that the default integer size can be toggled at compile time from within the program itself - not via the compiler. But I am getting distracted now. Why Fortran? Well one: out of spite. The C++ people seem to believe that you cannot achieve the same level and portability as a C++ code can. I\ndon’t believe this but I cannot just say it, I need to show it. I believe that Fortran can provide an easy entrance and avenue to High Performance Scientific Computing without having to be bogged\ndown by all of the program design choices that need to be taken if a code is written in C++. In the end, it is all code. Certain things are easier in Fortran, certain things are easier in C++. I’d argue that it is easier for\nscientists, who have little time to think about “How to write good code”, to write decent code in Fortran than in C++. C++ is an extremely powerful language, beyond my comprehension; however, the language is vast, a never ending horizon without mountains in sight. There is simply too much and for newcomers this is overwhelming. I experienced it and continue to do so, even after 8 years of programming in C++. Fortran is also extremely powerful - but also, not so vast as C++. This is due to the lack of standard library that is distributed with every compiler. Fortran is making a Standard Library but it is in its early stages. This is also a pain point in Fortran. There are many things in the standard library that are just good and make many tasks simple. The idea of the #include <iostream> and you get extremely powerful I/O capabilities. Also std::vector , #include <algorithm> etc. they provide a developer with very well built implementations of very simple (mundane tasks). For example, in Fortran there is no sort function that provides similar functionality to the ones in C++. The Fortran standard library is aiming to fix this, and they are working on it right now. However, there are many other functionalities that need to be covered and implemented for all types of programs. This is what drove me\nto create PIC. PIC is intended to be a set of functions and subroutines that facilitate developing code aimed for High Performance Computing for Scientific Applications. For example, weather simulations, finite element methods, computational quanutm chemistry, molecular dynamics, etc. The idea of PIC is to provide seamless interfaces to MPI, BLAS to allow people to think about their science instead of the code. The aim is to maybe “look pythonic in nature”, but probably closer to Julia. For example, being able to do call pic_gemm(A,B,C) and have PIC decide the bounds of the arrays and if the operations happens on the CPU or the GPU. PIC aims to provide a stable development platform for people that want to write high performance code for modern hardware architectures.","tags":"","url":"page/index.html"},{"title":"Contributing – PIC","text":"Contributing to PIC All contributions to PIC are welcome! If you have an idea for a new feature, a bug fix, or an improvement, please open an issue or submit a pull request. PIC is an open source project licensed under the MIT License, so you can use it in your own projects without any restrictions. If you use PIC in your project and your wrote a paper with it, please consider citing it by including a link to the repository in your paper. All code that you contribute to PIC will be licensed under the MIT license, so please make sure that you are comfortable with this before submitting your changes. How to contribute The following guidelines will help you contribute effectively: Fork the repository : Create your own fork of the PIC repository on GitHub. Create a new branch : Always create a new branch for your changes. This keeps your work organized and makes it easier to manage pull requests. I don’t really care about the branch name, but I suggest you abide by [type]/[description] format; where type is one of feat , fix , docs , chore , and experiment . Write tests : If you are adding new features or fixing bugs, please include tests to ensure that your changes work as expected. Follow the coding style : Please adhere to the coding style used in the project. This includes naming conventions, indentation, and commenting. Document your changes : Update the documentation to reflect any changes you make. This includes updating the README, comments in the code, and any relevant documentation files. Run tests : Before submitting your changes, make sure to run the tests to ensure that everything works as expected. The CI should catch any compiler issues. Submit a pull request : Once you have made your changes and tested them, submit a pull request to the main repository. Provide a clear description of your changes and why they are needed. The most important thing in the code is that we are aiming to support int32 and int64 as the default integer types. This is why\nwe use the default_int parameter in the pic_types.F90 module. When you are writing new code, please ensure that it is compatible with both integer types by always using integer(default_int) instead of integer or integer(kind=4) or integer(kind=8) . On the use of LLMs, AI thingies, etc. I do not care. As long as your code is tested, works, and is well documented I could not care less if you used an AI to write it. Can I copy paste code from PIC into ChatGPT, Claude, or whatever AI I use? Yes, you can. I don’t care. I do not consider this plagiarism, since the code is open source and you are free to use it as you wish. Documenting your code We use Ford to generate the documentation. The idea is to have coverage of almost every function in the code, except those that\ncan be self explanatory or if they are module procedure inside an interface block. For example: interface fill !! fill provides a generic interface to assing a value !! alpha of types ( int32 , int64 , sp , dp ) as defined in pic_types . F90 !! The inteface supports filling 1 d and 2 d arrays of the specified !! variables !! !! Usage : call fill ( array , value , [ optional ] threaded ) !! !! This subroutine is threaded for performance purposes if threaded is set to . true . !! module procedure fill_vector_int32 module procedure fill_vector_int64 module procedure fill_vector_sp module procedure fill_vector_dp module procedure fill_matrix_int32 module procedure fill_matrix_int64 module procedure fill_matrix_sp module procedure fill_matrix_dp end interface There’s really no need to go document each fill_vector_* or fill_matrix_* procedure, since the interface already provides\neverything we need to know about the procedures within the fill interface. Documenting each of these would mean to just\nwrite fills a vector of type int32 with the value alpha, uses threads if enabled which is redundant and not really useful. Code style We mostly follow the best practices outlined in the Fortran Best Practices guide. We have a pre-commit hook that will run fprettify to format the code before committing, this will ensure that the formatting is consistent across the codebase. To install pre-commit do: python3 -m pip install pre-commit\npre-commit install You can also run pre-commit run --all-files to format all the files in the repository. Module naming convention All our of modules are named using the pic_ prefix, followed by the name of the module. For example, the module that provides the basic types is called pic_types , and the module that provides the BLAS functionality is called pic_blas_interfaces . MOst of the time the module name matches the name of the file, if you find an instance where this is not the case, please open an issue or submit a pull request to fix it. Based on the file = module_name convention, there should only be one module per file. We follow the convention that the end module statement should contain the name of the module. Derived type naming convention All derived types should be named using the pic_ prefix, followed by the name of the type. For example, the type that represents a vector is called pic_vector , and the type that represents a matrix is called pic_matrix . Function and subroutine naming convention I really don’t care about naming conventions for functions or subroutines, I only suggest that you make the name descriptive and meaningful. Also,\nusing interfaces to hide the name of the subroutine inside the module is a good practice, since it allows you to change the implementation without affecting the users of the module. For example, in pic_timer.F90 we have the following interface: type :: pic_timer_type !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp private real ( dp ) :: start_time = 0.0_dp real ( dp ) :: stop_time = 0.0_dp real ( dp ) :: walltime logical :: is_running = . false . integer ( default_int ) :: start_count = 0_default_int integer ( default_int ) :: stop_count = 0_default_int integer ( default_int ) :: count_rate = 1_default_int contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time end type pic_timer_type You can see that the start procedure is mapped to timer_start , this way it is more intuitive for people to use my_timer%start() instead of my_timer%timer_start() . This is a good practice to follow, since it makes the code more readable and easier to use. We follow the same convention for functions and subroutines, as we do for modules. This is, the end function or end subroutine statement should contain the name of the function or subroutine. Code reviews Code reviews are an essential part of the contribution process. When you submit a pull request, it will be reviewed by the maintainers of the project. They will provide feedback on your code, suggest improvements, and ensure that it meets the project’s standards. Please be open to feedback and willing to make changes to your code based on the review. The goal is to improve the quality of the code and ensure that it is maintainable in the long run. If you are new to contributing to open source projects, don’t be discouraged by the review process. It is a learning experience, and the maintainers are here to help you improve your code and understand the project better. If you feel connected to the project and want to help out with reviews, please let me know. I would be happy to invite as many people as possible to the main repository.","tags":"","url":"page/contributing.html"},{"title":"Design – PIC","text":"Design philosophy The idea of this library was inspired a bit by a very cool talk Chris Lattner gave\nat some conference. In his talk, he mentions how the LLVM project just grew in\nmany directions thanks to how the design of the project was done. I.e. the fact\nthat most of the components of the LLVM are in the lib subdirectory. If you’ve never compiled the LLVM I suggest you do it, you’ll see that you can\nenable different compoenents depending on your needs. Rarely does one need to build everything in it. The same idea will be applied to PIC. I want to provide a set of components\nthat can be used independently of each other. There will be of course, a core library\nthat will provide the most basic functionality. For example, everything at the very bottom depends\non the pic_types.F90 module, so you cannot really use PIC without it. So following this concept, PIC will create a series of libraries that are based\nupon the core library, i.e. the very basic functionality that will always be built\nno matter what project you select on top. This idea is more important if you’re using the CMake build system, since this\nwill need to be configured when building from source. Otherwise, if you are using\nthe Fortrn package manager and using pic as a dependency in your project, the FPM\nwill only builds the modules/components that you actually include in your project. I find this very neat. At this point, the core library is everything, I haven’t refactored the code to be\nbuilt into separate libraries, however I already have the modularity to not build\ncertain bits, like BLAS, or MPI. I envision the following structure libpic_core\nlibpic_blas\nlibpic_mpi\nlibpic_gpu And PIC will be able to build all of these with default_int set to either int32 or int64 , depending on the needs of the user.\nNaturally, the MPI module will only use int32 as the default integer type, since MPI ( mpi_f08 ) does not support int64 in its API. Design goals I hope that this library will be useful for many people, mostly as a fast and efficient way to\nwrite parallel code in Fortran. I also hope that it will be a good example of how\nto write (modern) Fortran code that is modular, extensible, and easy to use. This is also my attempt into showcasing that Fortran is not a boring old language that only has\na relevance in legacy code. I want to show that Fortran can be used to write modern, high-performance code that is easy to read and maintain.","tags":"","url":"page/design.html"}]}