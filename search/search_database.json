var tipuesearch = {"pages":[{"title":" PIC ","text":"PIC PIC is named after the Huastec word PIC which means otter. A work in progress on writing a cool backend for Fortan applications focused on Quantum Chemistry software. Building and dependencies There’s two build systems included in the present version, CMake and the Fortran Package Manager . The dependencies of the project are, as of now, CMake (if using cmake), MPI, OpenMP, and a BLAS/LAPACK library. You can find the the source docs here CMake CMake offers a very modular build of PIC, the following options are available and can be triggered by -DPIC_ENABLE_XYZ=ON/OFF Option Name Default Description PIC_DEFAULT_INT8 OFF Use 8-byte integers as default PIC_ENABLE_MPI OFF Enable the use of MPI in PIC PIC_ENABLE_OMP OFF Enable the use of OpenMP in PIC PIC_ENABLE_BLAS OFF Enable BLAS/LAPACK libraries in PIC PIC_ENABLE_TESTING ON Enable testing for PIC PIC_ENABLE_JONQUIL OFF Enable Jonquil for JSON/TOML handling Advanced options: Option Name Default Description PIC_USE_VAPAA OFF Use vapaa for binding to MPI Information on vapaa see here which is my\npersonal fork which is pulled from here, and Jeff’s project . Will update to use the orignal project at a later date. Building: mkdir build\ncd build\ncmake ../\nmake -j\nctest FPM Install the FPM following the instructions and then simply: fpm build Developer Info Jorge Luis Galvez Vallejo","tags":"home","url":"index.html"},{"title":"flop_recorder_type – PIC ","text":"type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Inherited by type~~flop_recorder_type~~InheritedByGraph type~flop_recorder_type flop_recorder_type type~flop_rate_type flop_rate_type type~flop_rate_type->type~flop_recorder_type m_flops Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: add => add_flops private  subroutine add_flops(self, flops) add the FLOPs! Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public :: get => get_flops private  function get_flops(self) result(flops) return the FLOPs at a given point in time Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public :: reset => reset_flop_counter private  subroutine reset_flop_counter(self) reset the FLOP the counter Arguments Type Intent Optional Attributes Name class( flop_recorder_type ), intent(inout) :: self Source Code type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure :: add => add_flops procedure :: get => get_flops procedure :: reset => reset_flop_counter end type flop_recorder_type","tags":"","url":"type/flop_recorder_type.html"},{"title":"pic_timer – PIC ","text":"type, public :: pic_timer derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp Inherited by type~~pic_timer~~InheritedByGraph type~pic_timer pic_timer type~flop_rate_type flop_rate_type type~flop_rate_type->type~pic_timer m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: get_elapsed_time => timer_get_elapsed_time private  function timer_get_elapsed_time(self) result(elapsed) get the elapsed time in seconds, the function is aware if you’re asking for the time while the timer is running or not Arguments Type Intent Optional Attributes Name class( pic_timer ), intent(in) :: self Return Value real(kind=dp) procedure, public :: print_time => timer_print_time private  subroutine timer_print_time(self) print the time nicely Arguments Type Intent Optional Attributes Name class( pic_timer ), intent(in) :: self procedure, public :: set private  subroutine set(self, time) set the walltime directly, useful for testing or when you want to set a specific time Arguments Type Intent Optional Attributes Name class( pic_timer ), intent(inout) :: self real(kind=dp), intent(in) :: time procedure, public :: start => timer_start private  subroutine timer_start(self) and away we go! Arguments Type Intent Optional Attributes Name class( pic_timer ), intent(inout) :: self procedure, public :: stop => timer_stop private  subroutine timer_stop(self) and we’re done! Arguments Type Intent Optional Attributes Name class( pic_timer ), intent(inout) :: self Source Code type :: pic_timer !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp private real ( dp ) :: start_time , stop_time real ( dp ) :: walltime logical :: is_running = . false . integer :: start_count , stop_count integer :: count_rate contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time procedure :: set end type pic_timer","tags":"","url":"type/pic_timer.html"},{"title":"logger_type – PIC ","text":"type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info Type-Bound Procedures procedure, public, pass(self) :: close_log_file private  subroutine close_log_file(self) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self procedure, public, pass(self) :: configuration private pure subroutine configuration(self, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self integer(kind=default_int), intent(out), optional :: level procedure, public, pass(self) :: configure private pure subroutine configure(self, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: configure_file_output private  subroutine configure_file_output(self, filename, level) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(inout) :: self character(len=*), intent(in) :: filename integer(kind=default_int), intent(in), optional :: level procedure, public, pass(self) :: debug private  subroutine debug(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: error private  subroutine error(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: info private  subroutine info(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: log private  subroutine log(self, level, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: level character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: performance private  subroutine performance(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: verbose private  subroutine verbose(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure procedure, public, pass(self) :: warning private  subroutine warning(self, message, module, procedure) Arguments Type Intent Optional Attributes Name class( logger_type ), intent(in) :: self character(len=*), intent(in) :: message character(len=*), intent(in), optional :: module character(len=*), intent(in), optional :: procedure Source Code type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: configure_file_output procedure , public , pass ( self ) :: close_log_file procedure , public , pass ( self ) :: log procedure , public , pass ( self ) :: debug procedure , public , pass ( self ) :: verbose procedure , public , pass ( self ) :: info procedure , public , pass ( self ) :: performance procedure , public , pass ( self ) :: warning procedure , public , pass ( self ) :: error end type logger_type","tags":"","url":"type/logger_type.html"},{"title":"pic_comm – PIC ","text":"type, public :: pic_comm custom data type that holds the MPI communicators Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: dummy_comm if we don’t use MPI use an integer for a comm integer(kind=default_int), public :: m_ierr integer(kind=default_int), public :: m_rank MPI rank integer(kind=default_int), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize private  subroutine pic_comm_finalize(self) finalize the MPI library Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self procedure, public :: init => pic_comm_init private  subroutine pic_comm_init(self) initilalize the MPI library and get the size and rank variables Arguments Type Intent Optional Attributes Name class( pic_comm ), intent(inout) :: self Source Code type :: pic_comm !! custom data type that holds the MPI communicators private #ifdef USE_MPI type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface #else integer ( default_int ), public :: dummy_comm !! if we don't use MPI use an integer for a comm #endif integer ( default_int ), public :: m_rank !! MPI rank integer ( default_int ), public :: m_size !! MPI size integer ( default_int ), public :: m_ierr contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm","tags":"","url":"type/pic_comm.html"},{"title":"flop_rate_type – PIC ","text":"type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Inherits type~~flop_rate_type~~InheritsGraph type~flop_rate_type flop_rate_type type~flop_recorder_type flop_recorder_type type~flop_rate_type->type~flop_recorder_type m_flops type~pic_timer pic_timer type~flop_rate_type->type~pic_timer m_timer Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Type-Bound Procedures procedure, public :: add_flops => flop_rate_add_flops private  subroutine flop_rate_add_flops(self, flops) add flops to the flop rate Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self integer(kind=int64), intent(in) :: flops procedure, public :: get_flop_rate => flop_rate_get_flop_rate private  function flop_rate_get_flop_rate(self) result(flop_rate) get the flop rate in GFLOP/s, return 0.0 if time is zero or negative Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Return Value real(kind=dp) procedure, public :: get_flops => flop_rate_get_flops private  function flop_rate_get_flops(self) result(flops) get the number of flops recorded Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value integer(kind=int64) procedure, public :: get_time => flop_rate_get_time private  function flop_rate_get_time(self) result(time) get the elapsed time for the timer through the flop rate type Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(in) :: self Return Value real(kind=dp) procedure, public :: report => flop_rate_report private  subroutine flop_rate_report(self) report the flop rate in GFLOP/s\nthis is a convenience function to print the flop rate Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: reset => flop_rate_reset private  subroutine flop_rate_reset(self) reset the flop rate, this will reset the flops, this is mostly for testing Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: start_time => flop_rate_start_time private  subroutine flop_rate_start_time(self) start the timer for the flop rate Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self procedure, public :: stop_time => flop_rate_stop_time private  subroutine flop_rate_stop_time(self) stop the timer for the flop rate Arguments Type Intent Optional Attributes Name class( flop_rate_type ), intent(inout) :: self Source Code type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( pic_timer ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure :: start_time => flop_rate_start_time procedure :: stop_time => flop_rate_stop_time procedure :: add_flops => flop_rate_add_flops procedure :: get_flops => flop_rate_get_flops procedure :: get_time => flop_rate_get_time procedure :: get_flop_rate => flop_rate_get_flop_rate procedure :: report => flop_rate_report procedure :: reset => flop_rate_reset end type flop_rate_type","tags":"","url":"type/flop_rate_type.html"},{"title":"to_string – PIC","text":"public interface to_string public interface to transform variables to strings Module Procedures private  function to_string_int32(i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_int64(i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_dp(r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_char(c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_string_logical(l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable","tags":"","url":"interface/to_string.html"},{"title":"print_array – PIC","text":"public interface print_array general interface for printing a one or two dimensional array Module Procedures private  subroutine print_vector(vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix(mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array.html"},{"title":"print_array_with_bounds – PIC","text":"public interface print_array_with_bounds general interface to print an array within certain bounds Module Procedures private  subroutine print_vector_n(vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_m_n(mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type","tags":"","url":"interface/print_array_with_bounds.html"},{"title":"get_first_arg_from_command_line – PIC","text":"public  function get_first_arg_from_command_line() result(filename) obtain the first argument from the command line Arguments None Return Value character(len=255) Source Code function get_first_arg_from_command_line () result ( filename ) !! obtain the first argument from the command line character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line","tags":"","url":"proc/get_first_arg_from_command_line.html"},{"title":"blas_asum – PIC","text":"public interface blas_asum explicit interface for BLAS ASUM routines Functions private pure function dasum(n, x, incx) result(res_dasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function dzasum(n, x, incx) result(res_dzasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function sasum(n, x, incx) result(res_sasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) private pure function scasum(n, x, incx) result(res_scasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp)","tags":"","url":"interface/blas_asum.html"},{"title":"blas_axpy – PIC","text":"public interface blas_axpy explicit interface for BLAS AXPY routines Subroutines private pure subroutine caxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine daxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine saxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zaxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_axpy.html"},{"title":"blas_copy – PIC","text":"public interface blas_copy explicit interface for BLAS COPY routines Subroutines private pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_copy.html"},{"title":"blas_dot – PIC","text":"public interface blas_dot explicit interface for BLAS DOT routines Functions private pure function cdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=sp) private pure function ddot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=dp) private pure function sdot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=sp) private pure function zdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=dp)","tags":"","url":"interface/blas_dot.html"},{"title":"blas_gemm – PIC","text":"public interface blas_gemm explicit interface for BLAS GEMM routines Subroutines private pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc","tags":"","url":"interface/blas_gemm.html"},{"title":"blas_gemv – PIC","text":"public interface blas_gemv explicit interface for BLAS GEMV routines Subroutines private pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy","tags":"","url":"interface/blas_gemv.html"},{"title":"blas_iamax – PIC","text":"public interface blas_iamax explicit interface for BLAS IAMAX routines Functions private pure function icamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function idamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function isamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function izamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int)","tags":"","url":"interface/blas_iamax.html"},{"title":"blas_scal – PIC","text":"public interface blas_scal explicit interface for BLAS SCAL routines Subroutines private pure subroutine cscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine dscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine sscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine zscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx","tags":"","url":"interface/blas_scal.html"},{"title":"pic_asum – PIC","text":"public interface pic_asum general interface of the BLAS SASUM routines, will call xASUM Module Procedures private  function pic_sasum(x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dasum(x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_scasum(x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dzasum(x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp)","tags":"","url":"interface/pic_asum.html"},{"title":"pic_axpy – PIC","text":"public interface pic_axpy general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY Module Procedures private  subroutine pic_saxpy(x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_daxpy(x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_caxpy(x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zaxpy(x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"interface/pic_axpy.html"},{"title":"pic_copy – PIC","text":"public interface pic_copy general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY Module Procedures private  subroutine pic_scopy(x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) private  subroutine pic_dcopy(x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) private  subroutine pic_ccopy(x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) private  subroutine pic_zcopy(x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:)","tags":"","url":"interface/pic_copy.html"},{"title":"pic_dot – PIC","text":"public interface pic_dot general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC Module Procedures private  function pic_sdot(x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) private  function pic_ddot(x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) private  function pic_cdotc(x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) private  function pic_zdotc(x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp)","tags":"","url":"interface/pic_dot.html"},{"title":"pic_gemm – PIC","text":"public interface pic_gemm general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, or ZGEMM Module Procedures private pure subroutine pic_sgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private pure subroutine pic_zgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta","tags":"","url":"interface/pic_gemm.html"},{"title":"pic_gemv – PIC","text":"public interface pic_gemv general interface of the BLAS GEMV routines, will call SGEMV, DGEMV Module Procedures private pure subroutine pic_sgemv(A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemv(A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta","tags":"","url":"interface/pic_gemv.html"},{"title":"pic_iamax – PIC","text":"public interface pic_iamax general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX Module Procedures private  function pic_isamax(x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_idamax(x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_icamax(x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_izamax(x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int)","tags":"","url":"interface/pic_iamax.html"},{"title":"pic_scal – PIC","text":"public interface pic_scal general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL Module Procedures private  subroutine pic_sscal(x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_dscal(x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_cscal(x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zscal(x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"interface/pic_scal.html"},{"title":"print_asterisk_row – PIC","text":"public  subroutine print_asterisk_row(n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print Source Code subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row","tags":"","url":"proc/print_asterisk_row.html"},{"title":"pic_print_banner – PIC","text":"public  subroutine pic_print_banner() my cool banner, work in progress Arguments None Source Code subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" end subroutine pic_print_banner","tags":"","url":"proc/pic_print_banner.html"},{"title":"pic_string_utils – PIC","text":"General string utilities Uses pic_types module~~pic_string_utils~~UsesGraph module~pic_string_utils pic_string_utils module~pic_types pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_string_utils~~UsedByGraph module~pic_string_utils pic_string_utils module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_string_utils module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools->module~pic_matrix_printer module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_string_utils module~pic_timers pic_timers module~pic_flop_rate->module~pic_timers module~pic_matrix_printer->module~pic_string_utils module~pic_timers->module~pic_string_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface to_string public interface to transform variables to strings private  function to_string_int32(i) result(trimmed_str) transform an int32 to a string Arguments Type Intent Optional Attributes Name integer(kind=int32), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_int64(i) result(trimmed_str) transform an int64 to a string Arguments Type Intent Optional Attributes Name integer(kind=int64), intent(in) :: i Return Value character(len=:), allocatable private  function to_string_dp(r) result(trimmed_str) transform a real to a string Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: r Return Value character(len=:), allocatable private  function to_string_char(c) result(trimmed_str) transform a character to a string Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: c Return Value character(len=:), allocatable private  function to_string_logical(l) result(trimmed_str) tranform a logical to a string either true or false Arguments Type Intent Optional Attributes Name logical, intent(in) :: l Return Value character(len=:), allocatable","tags":"","url":"module/pic_string_utils.html"},{"title":"pic_global_definitions – PIC","text":"Global definitions for input output Uses pic_types module~~pic_global_definitions~~UsesGraph module~pic_global_definitions pic_global_definitions module~pic_types pic_types module~pic_global_definitions->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_global_definitions~~UsedByGraph module~pic_global_definitions pic_global_definitions module~pic_logger pic_logger module~pic_logger->module~pic_global_definitions Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: logfile_unit = 99 assign output unit 99 for the logfile integer(kind=default_int), public, parameter :: stdout = 6 assign output unit 6 for stdout","tags":"","url":"module/pic_global_definitions.html"},{"title":"pic_flop_recorder – PIC","text":"general flop recorder module Uses pic_types module~~pic_flop_recorder~~UsesGraph module~pic_flop_recorder pic_flop_recorder module~pic_types pic_types module~pic_flop_recorder->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_flop_recorder~~UsedByGraph module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_flop_recorder Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_recorder_type the flop recorder type simply contains a flop count\nthis should be the largest possible integer in the planet\ncurrently this will overflow for zetta flops Type-Bound Procedures procedure, public :: add => add_flops procedure, public :: get => get_flops procedure, public :: reset => reset_flop_counter","tags":"","url":"module/pic_flop_recorder.html"},{"title":"pic_timers – PIC","text":"contains a simple timer module to measure and record time Uses pic_string_utils pic_types module~~pic_timers~~UsesGraph module~pic_timers pic_timers module~pic_string_utils pic_string_utils module~pic_timers->module~pic_string_utils module~pic_types pic_types module~pic_timers->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_timers~~UsedByGraph module~pic_timers pic_timers module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_timers Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: pic_timer derived type for a timer, contains the start, stop, and count variables\ncan work with or without omp Type-Bound Procedures procedure, public :: get_elapsed_time => timer_get_elapsed_time procedure, public :: print_time => timer_print_time procedure, public :: set procedure, public :: start => timer_start procedure, public :: stop => timer_stop","tags":"","url":"module/pic_timers.html"},{"title":"pic_matrix_printer – PIC","text":"Matrix printing module Uses pic_string_utils pic_types module~~pic_matrix_printer~~UsesGraph module~pic_matrix_printer pic_matrix_printer module~pic_string_utils pic_string_utils module~pic_matrix_printer->module~pic_string_utils module~pic_types pic_types module~pic_matrix_printer->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_matrix_printer~~UsedByGraph module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_matrix_printer Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface print_array general interface for printing a one or two dimensional array private  subroutine print_vector(vec, format_type) print a vector Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) character(len=*), intent(in), optional :: format_type private  subroutine print_matrix(mat, format_type) print a matrix in a given format Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) character(len=*), intent(in), optional :: format_type public        interface print_array_with_bounds general interface to print an array within certain bounds private  subroutine print_vector_n(vec, n_elements, format_type) print a vector from start up to n_elements Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: vec (:) integer(kind=default_int), intent(in) :: n_elements character(len=*), intent(in), optional :: format_type private  subroutine print_matrix_m_n(mat, n_cols, n_rows, format_type) Print a matrix of n_cols by n_rows Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: mat (:,:) integer(kind=default_int), intent(in) :: n_cols integer(kind=default_int), intent(in) :: n_rows character(len=*), intent(in), optional :: format_type","tags":"","url":"module/pic_matrix_printer.html"},{"title":"pic_command_line – PIC","text":"command line interaction module Uses pic_types module~~pic_command_line~~UsesGraph module~pic_command_line pic_command_line module~pic_types pic_types module~pic_command_line->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public  function get_first_arg_from_command_line () result(filename) obtain the first argument from the command line Arguments None Return Value character(len=255)","tags":"","url":"module/pic_command_line.html"},{"title":"pic_logger – PIC","text":"this is the logger module Uses pic_types pic_global_definitions module~~pic_logger~~UsesGraph module~pic_logger pic_logger module~pic_global_definitions pic_global_definitions module~pic_logger->module~pic_global_definitions module~pic_types pic_types module~pic_logger->module~pic_types module~pic_global_definitions->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer(kind=default_int), public, parameter :: debug_level = 10 integer(kind=default_int), public, parameter :: error_level = 5 type( logger_type ), public :: global_logger integer(kind=default_int), public, parameter :: info_level = 8 integer(kind=default_int), public, parameter :: performance_level = 7 integer(kind=default_int), public, parameter :: verbose_level = 9 integer(kind=default_int), public, parameter :: warning_level = 6 Derived Types type, public :: logger_type custom logger data type Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: log_file_level = verbose_level set default log file log level to verbose integer(kind=default_int), public :: log_level = info_level set default log level to info Type-Bound Procedures procedure, public, pass(self) :: close_log_file procedure, public, pass(self) :: configuration procedure, public, pass(self) :: configure procedure, public, pass(self) :: configure_file_output procedure, public, pass(self) :: debug procedure, public, pass(self) :: error procedure, public, pass(self) :: info procedure, public, pass(self) :: log procedure, public, pass(self) :: performance procedure, public, pass(self) :: verbose procedure, public, pass(self) :: warning","tags":"","url":"module/pic_logger.html"},{"title":"pic_mpi – PIC","text":"General MPI interface module Uses pic_types module~~pic_mpi~~UsesGraph module~pic_mpi pic_mpi module~pic_types pic_types module~pic_mpi->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial type( pic_comm ), public :: world_comm our world comm Derived Types type, public :: pic_comm custom data type that holds the MPI communicators Components Type Visibility Attributes Name Initial integer(kind=default_int), public :: dummy_comm if we don’t use MPI use an integer for a comm integer(kind=default_int), public :: m_ierr integer(kind=default_int), public :: m_rank MPI rank integer(kind=default_int), public :: m_size MPI size Type-Bound Procedures procedure, public :: finalize => pic_comm_finalize procedure, public :: init => pic_comm_init","tags":"","url":"module/pic_mpi.html"},{"title":"pic_debugging_tools – PIC","text":"simple single include for printing routines Uses pic_string_utils pic_matrix_printer module~~pic_debugging_tools~~UsesGraph module~pic_debugging_tools pic_debugging_tools module~pic_matrix_printer pic_matrix_printer module~pic_debugging_tools->module~pic_matrix_printer module~pic_string_utils pic_string_utils module~pic_debugging_tools->module~pic_string_utils module~pic_matrix_printer->module~pic_string_utils module~pic_types pic_types module~pic_matrix_printer->module~pic_types module~pic_string_utils->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs.","tags":"","url":"module/pic_debugging_tools.html"},{"title":"pic_blas_interfaces – PIC","text":"pic_blas_interfaces.F90 provides the interfaces for the BLAS routines\nthe idea is to have a two level interface, first pic_blas_xyz which\nis the way programmers will use BLAS, it’ll do some checks and then\ncall the “overloaded” BLAS interfaces to call the correct BLAS routine Uses pic_types module~~pic_blas_interfaces~~UsesGraph module~pic_blas_interfaces pic_blas_interfaces module~pic_types pic_types module~pic_blas_interfaces->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface blas_asum explicit interface for BLAS ASUM routines private pure function dasum(n, x, incx) result(res_dasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function dzasum(n, x, incx) result(res_dzasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=dp) private pure function sasum(n, x, incx) result(res_sasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) private pure function scasum(n, x, incx) result(res_scasum) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value real(kind=sp) public        interface blas_axpy explicit interface for BLAS AXPY routines private pure subroutine caxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine daxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine saxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zaxpy(n, alpha, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy public        interface blas_copy explicit interface for BLAS COPY routines private pure subroutine ccopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine scopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zcopy(n, x, incx, y, incy) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy public        interface blas_dot explicit interface for BLAS DOT routines private pure function cdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=sp) private pure function ddot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=dp) private pure function sdot(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value real(kind=sp) private pure function zdotc(n, x, incx, y, incy) result(res) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: y (*) integer(kind=default_int), intent(in) :: incy Return Value complex(kind=dp) public        interface blas_gemm explicit interface for BLAS GEMM routines private pure subroutine cgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine dgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine sgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc private pure subroutine zgemm(transa, transb, m, n, k, alpha, a, lda, b, ldb, beta, c, ldc) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: transa character(len=1), intent(in) :: transb integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n integer(kind=default_int), intent(in) :: k complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: b (ldb,*) integer(kind=default_int), intent(in) :: ldb complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: c (ldc,*) integer(kind=default_int), intent(in) :: ldc public        interface blas_gemv explicit interface for BLAS GEMV routines private pure subroutine cgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=sp), intent(in) :: beta complex(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine dgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=dp), intent(in) :: beta real(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine sgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx real(kind=sp), intent(in) :: beta real(kind=sp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy private pure subroutine zgemv(trans, m, n, alpha, a, lda, x, incx, beta, y, incy) Arguments Type Intent Optional Attributes Name character(len=1), intent(in) :: trans integer(kind=default_int), intent(in) :: m integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(in) :: a (lda,*) integer(kind=default_int), intent(in) :: lda complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx complex(kind=dp), intent(in) :: beta complex(kind=dp), intent(inout) :: y (*) integer(kind=default_int), intent(in) :: incy public        interface blas_iamax explicit interface for BLAS IAMAX routines private pure function icamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function idamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function isamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) private pure function izamax(n, x, incx) result(idx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: x (*) integer(kind=default_int), intent(in) :: incx Return Value integer(kind=default_int) public        interface blas_scal explicit interface for BLAS SCAL routines private pure subroutine cscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=sp), intent(in) :: alpha complex(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine dscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=dp), intent(in) :: alpha real(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine sscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n real(kind=sp), intent(in) :: alpha real(kind=sp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx private pure subroutine zscal(n, alpha, x, incx) Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n complex(kind=dp), intent(in) :: alpha complex(kind=dp), intent(inout) :: x (*) integer(kind=default_int), intent(in) :: incx public        interface pic_asum general interface of the BLAS SASUM routines, will call xASUM private  function pic_sasum(x) result(res) interface for single precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dasum(x) result(res) interface for double precision absolute sum Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) private  function pic_scasum(x) result(res) interface for single precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value real(kind=sp) private  function pic_dzasum(x) result(res) interface for double precision complex absolute sum Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value real(kind=dp) public        interface pic_axpy general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY private  subroutine pic_saxpy(x, y, alpha) interface for single precision AXPY Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_daxpy(x, y, alpha) interface for double precision AXPY Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_caxpy(x, y, alpha) interface for single precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zaxpy(x, y, alpha) interface for double precision complex AXPY Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) complex(kind=dp), intent(in), optional :: alpha public        interface pic_copy general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY private  subroutine pic_scopy(x, y) interface for single precision copy Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) private  subroutine pic_dcopy(x, y) interface for double precision copy Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) private  subroutine pic_ccopy(x, y) interface for single precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(inout) :: y (:) private  subroutine pic_zcopy(x, y) interface for double precision complex copy Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(inout) :: y (:) public        interface pic_dot general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC private  function pic_sdot(x, y) result(res) interface for single precision dot product Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(in) :: y (:) Return Value real(kind=sp) private  function pic_ddot(x, y) result(res) interface for double precision dot product Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(in) :: y (:) Return Value real(kind=dp) private  function pic_cdotc(x, y) result(res) interface for single precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) complex(kind=sp), intent(in) :: y (:) Return Value complex(kind=sp) private  function pic_zdotc(x, y) result(res) interface for double precision complex dot product Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) complex(kind=dp), intent(in) :: y (:) Return Value complex(kind=dp) public        interface pic_gemm general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, or ZGEMM private pure subroutine pic_sgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: B (:,:) real(kind=sp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: B (:,:) real(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta private pure subroutine pic_zgemm(A, B, C, transa, transb, alpha, beta) interface for single precision matrix multiplication Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: A (:,:) complex(kind=dp), intent(in) :: B (:,:) complex(kind=dp), intent(inout) :: C (:,:) character(len=1), intent(in), optional :: transa character(len=1), intent(in), optional :: transb complex(kind=dp), intent(in), optional :: alpha complex(kind=dp), intent(in), optional :: beta public        interface pic_gemv general interface of the BLAS GEMV routines, will call SGEMV, DGEMV private pure subroutine pic_sgemv(A, x, y, trans_a, alpha, beta) interface for single precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: A (:,:) real(kind=sp), intent(in) :: x (:) real(kind=sp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=sp), intent(in), optional :: alpha real(kind=sp), intent(in), optional :: beta private pure subroutine pic_dgemv(A, x, y, trans_a, alpha, beta) interface for double precision matrix-vector multiplication Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: A (:,:) real(kind=dp), intent(in) :: x (:) real(kind=dp), intent(inout) :: y (:) character(len=1), intent(in), optional :: trans_a real(kind=dp), intent(in), optional :: alpha real(kind=dp), intent(in), optional :: beta public        interface pic_iamax general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX private  function pic_isamax(x) result(idx) interface for single precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_idamax(x) result(idx) interface for double precision index of maximum absolute value Arguments Type Intent Optional Attributes Name real(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_icamax(x) result(idx) interface for single precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(in) :: x (:) Return Value integer(kind=default_int) private  function pic_izamax(x) result(idx) interface for double precision complex index of maximum absolute value Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(in) :: x (:) Return Value integer(kind=default_int) public        interface pic_scal general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL private  subroutine pic_sscal(x, alpha) interface for single precision scaling Arguments Type Intent Optional Attributes Name real(kind=sp), intent(inout) :: x (:) real(kind=sp), intent(in), optional :: alpha private  subroutine pic_dscal(x, alpha) interface for double precision scaling Arguments Type Intent Optional Attributes Name real(kind=dp), intent(inout) :: x (:) real(kind=dp), intent(in), optional :: alpha private  subroutine pic_cscal(x, alpha) interface for single precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=sp), intent(inout) :: x (:) complex(kind=sp), intent(in), optional :: alpha private  subroutine pic_zscal(x, alpha) interface for double precision complex scaling Arguments Type Intent Optional Attributes Name complex(kind=dp), intent(inout) :: x (:) complex(kind=dp), intent(in), optional :: alpha","tags":"","url":"module/pic_blas_interfaces.html"},{"title":"pic_types – PIC","text":"main module for defining types for integer and double precision Uses iso_fortran_env module~~pic_types~~UsesGraph module~pic_types pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~pic_types~~UsedByGraph module~pic_types pic_types module~pic_blas_interfaces pic_blas_interfaces module~pic_blas_interfaces->module~pic_types module~pic_command_line pic_command_line module~pic_command_line->module~pic_types module~pic_flop_rate pic_flop_rate module~pic_flop_rate->module~pic_types module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_string_utils pic_string_utils module~pic_flop_rate->module~pic_string_utils module~pic_timers pic_timers module~pic_flop_rate->module~pic_timers module~pic_flop_recorder->module~pic_types module~pic_global_definitions pic_global_definitions module~pic_global_definitions->module~pic_types module~pic_logger pic_logger module~pic_logger->module~pic_types module~pic_logger->module~pic_global_definitions module~pic_matrix_printer pic_matrix_printer module~pic_matrix_printer->module~pic_types module~pic_matrix_printer->module~pic_string_utils module~pic_mpi pic_mpi module~pic_mpi->module~pic_types module~pic_output_helpers pic_output_helpers module~pic_output_helpers->module~pic_types module~pic_string_utils->module~pic_types module~pic_timers->module~pic_types module~pic_timers->module~pic_string_utils module~pic_debugging_tools pic_debugging_tools module~pic_debugging_tools->module~pic_matrix_printer module~pic_debugging_tools->module~pic_string_utils Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Visibility Attributes Name Initial integer, public, parameter :: default_complex = dp default complex is double precision integer, public, parameter :: default_int = int32 default integer kind, be careful if you are using fdefault-size=8 integer, public, parameter :: default_real = dp naturally, our default real is double precision integer, public, parameter :: dp = SELECTED_REAL_KIND(15, 307) double precision variable integer, public, parameter :: qp = SELECTED_REAL_KIND(33, 4931) quadruple precision variable integer, public, parameter :: sp = SELECTED_REAL_KIND(6, 37) single precision variable","tags":"","url":"module/pic_types.html"},{"title":"pic_output_helpers – PIC","text":"Assorted output helper routines Uses pic_types module~~pic_output_helpers~~UsesGraph module~pic_output_helpers pic_output_helpers module~pic_types pic_types module~pic_output_helpers->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Subroutines public  subroutine print_asterisk_row (n) prints a convenient row of asterisks of length n Arguments Type Intent Optional Attributes Name integer(kind=default_int), intent(in) :: n number of asterisks to print","tags":"","url":"module/pic_output_helpers.html"},{"title":"pic_flop_rate – PIC","text":"pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer\nit is used to measure the flop rate of a given operation, and report it Uses pic_flop_recorder pic_string_utils pic_types pic_timers module~~pic_flop_rate~~UsesGraph module~pic_flop_rate pic_flop_rate module~pic_flop_recorder pic_flop_recorder module~pic_flop_rate->module~pic_flop_recorder module~pic_string_utils pic_string_utils module~pic_flop_rate->module~pic_string_utils module~pic_timers pic_timers module~pic_flop_rate->module~pic_timers module~pic_types pic_types module~pic_flop_rate->module~pic_types module~pic_flop_recorder->module~pic_types module~pic_string_utils->module~pic_types module~pic_timers->module~pic_string_utils module~pic_timers->module~pic_types iso_fortran_env iso_fortran_env module~pic_types->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Derived Types type, public :: flop_rate_type derived type for flop rate, contains a timer and a flop recorder Type-Bound Procedures procedure, public :: add_flops => flop_rate_add_flops procedure, public :: get_flop_rate => flop_rate_get_flop_rate procedure, public :: get_flops => flop_rate_get_flops procedure, public :: get_time => flop_rate_get_time procedure, public :: report => flop_rate_report procedure, public :: reset => flop_rate_reset procedure, public :: start_time => flop_rate_start_time procedure, public :: stop_time => flop_rate_stop_time","tags":"","url":"module/pic_flop_rate.html"},{"title":"pic – PIC","text":"simple interface module that prints banner and other information about the library\nmostly here to verify installs, etc. Subroutines public  subroutine pic_print_banner () my cool banner, work in progress Arguments None","tags":"","url":"module/pic.html"},{"title":"pic_string_utils.f90 – PIC","text":"Life is easier when we have strings. This file\ncontains the necessary routines to transform key data\ntypes into strings This file depends on sourcefile~~pic_string_utils.f90~~EfferentGraph sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_string_utils.f90~~AfferentGraph sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Life is easier when we have strings. This file !! contains the necessary routines to transform key data !! types into strings module pic_string_utils !! General string utilities use pic_types , only : sp , dp , int32 , int64 implicit none ! Generic interface for to_string to handle different types private public :: to_string interface to_string !! public interface to transform variables to strings module procedure to_string_int32 module procedure to_string_int64 module procedure to_string_dp module procedure to_string_char module procedure to_string_logical end interface contains function to_string_int32 ( i ) result ( trimmed_str ) !! transform an int32 to a string integer ( kind = int32 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int32 function to_string_int64 ( i ) result ( trimmed_str ) !! transform an int64 to a string integer ( kind = int64 ), intent ( in ) :: i character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(I0)\" ) i ! Convert integer to string without leading spaces trimmed_str = trim ( str ) end function to_string_int64 function to_string_dp ( r ) result ( trimmed_str ) !! transform a real to a string real ( kind = dp ), intent ( in ) :: r character ( len = 50 ) :: str character ( len = :), allocatable :: trimmed_str write ( str , \"(F0.12)\" ) r ! Convert real to string with 3 decimal places trimmed_str = trim ( str ) end function to_string_dp function to_string_char ( c ) result ( trimmed_str ) !! transform a character to a string character ( len =* ), intent ( in ) :: c character ( len = 500 ) :: str character ( len = :), allocatable :: trimmed_str str = c trimmed_str = trim ( str ) end function to_string_char function to_string_logical ( l ) result ( trimmed_str ) !! tranform a logical to a string either true or false logical , intent ( in ) :: l character ( len = 5 ) :: str character ( len = :), allocatable :: trimmed_str if ( l ) then str = \"TRUE\" else str = \"FALSE\" end if trimmed_str = trim ( str ) end function to_string_logical end module pic_string_utils","tags":"","url":"sourcefile/pic_string_utils.f90.html"},{"title":"pic_global_definitions.f90 – PIC","text":"this is an experimental file that contains definitions\nthat will be uses across the program, for example input/output units\nthat PIC will use across things. This file depends on sourcefile~~pic_global_definitions.f90~~EfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_global_definitions.f90~~AfferentGraph sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this is an experimental file that contains definitions !! that will be uses across the program, for example input/output units !! that PIC will use across things. module pic_global_definitions !! Global definitions for input output use pic_types , only : default_int implicit none private public :: stdout , logfile_unit integer ( default_int ), parameter :: stdout = 6 !! assign output unit 6 for stdout integer ( default_int ), parameter :: logfile_unit = 99 !! assign output unit 99 for the logfile end module pic_global_definitions","tags":"","url":"sourcefile/pic_global_definitions.f90.html"},{"title":"pic_flop_recorder.f90 – PIC","text":"flop recorder This file depends on sourcefile~~pic_flop_recorder.f90~~EfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_flop_recorder.f90~~AfferentGraph sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop recorder module pic_flop_recorder !! general flop recorder module use pic_types , only : int64 implicit none private public :: flop_recorder_type type :: flop_recorder_type !! the flop recorder type simply contains a flop count !! this should be the largest possible integer in the planet !! currently this will overflow for zetta flops private integer ( int64 ) :: flop_count = 0_int64 contains procedure :: add => add_flops procedure :: get => get_flops procedure :: reset => reset_flop_counter end type flop_recorder_type contains subroutine add_flops ( self , flops ) !! add the FLOPs! class ( flop_recorder_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops self % flop_count = self % flop_count + flops end subroutine add_flops function get_flops ( self ) result ( flops ) !! return the FLOPs at a given point in time class ( flop_recorder_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % flop_count end function get_flops subroutine reset_flop_counter ( self ) !! reset the FLOP the counter class ( flop_recorder_type ), intent ( inout ) :: self self % flop_count = 0_int64 end subroutine reset_flop_counter end module pic_flop_recorder","tags":"","url":"sourcefile/pic_flop_recorder.f90.html"},{"title":"pic_timer.F90 – PIC","text":"timing routines in general This file depends on sourcefile~~pic_timer.f90~~EfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_timer.f90~~AfferentGraph sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! timing routines in general module pic_timers !! contains a simple timer module to measure and record time use pic_types , only : dp use pic_string_utils , only : to_string #ifdef _OPENMP use omp_lib , only : omp_get_wtime #endif implicit none private public :: pic_timer type :: pic_timer !! derived type for a timer, contains the start, stop, and count variables !! can work with or without omp private real ( dp ) :: start_time , stop_time real ( dp ) :: walltime logical :: is_running = . false . integer :: start_count , stop_count integer :: count_rate contains procedure :: start => timer_start procedure :: stop => timer_stop procedure :: print_time => timer_print_time procedure :: get_elapsed_time => timer_get_elapsed_time procedure :: set end type pic_timer contains subroutine timer_start ( self ) !! and away we go! class ( pic_timer ), intent ( inout ) :: self self % is_running = . true . #ifdef _OPENMP self % start_time = omp_get_wtime () #else call system_clock ( self % start_count , self % count_rate ) #endif end subroutine timer_start subroutine timer_stop ( self ) !! and we're done! class ( pic_timer ), intent ( inout ) :: self #ifdef _OPENMP self % stop_time = omp_get_wtime () #else call system_clock ( self % stop_count ) #endif ! if someone stops the timer, we stop ! self % is_running = . false . end subroutine timer_stop subroutine timer_print_time ( self ) !! print the time nicely class ( pic_timer ), intent ( in ) :: self real ( dp ) :: elapsed elapsed = self % get_elapsed_time () print * , \"Elapsed time: \" // to_string ( elapsed ) // \" seconds\" end subroutine timer_print_time function timer_get_elapsed_time ( self ) result ( elapsed ) !! get the elapsed time in seconds, the function is aware if you're asking for the time while the timer is running or not class ( pic_timer ), intent ( in ) :: self real ( dp ) :: elapsed integer :: current_count #ifdef _OPENMP if ( self % is_running ) then elapsed = omp_get_wtime () - self % start_time else elapsed = self % stop_time - self % start_time end if #else if ( self % is_running ) then call system_clock ( count = current_count ) elapsed = real ( current_count - self % start_count , dp ) / real ( self % count_rate , dp ) else elapsed = real ( self % stop_count - self % start_count , dp ) / real ( self % count_rate , dp ) end if #endif end function timer_get_elapsed_time subroutine set ( self , time ) !! set the walltime directly, useful for testing or when you want to set a specific time class ( pic_timer ), intent ( inout ) :: self real ( dp ), intent ( in ) :: time self % walltime = time end subroutine set end module pic_timers","tags":"","url":"sourcefile/pic_timer.f90.html"},{"title":"pic_matrix_printer.f90 – PIC","text":"Routines to print vectors and matrices, currently no support for higher\ndimensional arrays. Need to fix that! This file depends on sourcefile~~pic_matrix_printer.f90~~EfferentGraph sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~pic_matrix_printer.f90~~AfferentGraph sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! Routines to print vectors and matrices, currently no support for higher !! dimensional arrays. Need to fix that! module pic_matrix_printer !! Matrix printing module use pic_types , only : dp , default_int use pic_string_utils , only : to_string implicit none private public :: print_array , print_array_with_bounds interface print_array !! general interface for printing a one or two dimensional array module procedure print_vector module procedure print_matrix end interface print_array interface print_array_with_bounds !! general interface to print an array within certain bounds module procedure print_vector_n module procedure print_matrix_m_n end interface print_array_with_bounds character ( len =* ), parameter :: fmt_edge = \"(F14.10)\" !! no comma format character ( len =* ), parameter :: fmt_in = '(F14.10, \", \")' !! comma format for between arrays contains subroutine print_vector_n ( vec , n_elements , format_type ) !! print a vector from start up to n_elements real ( dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected integer ( kind = default_int ), intent ( in ) :: n_elements ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec , n_elements ) else call print_vector_in_format ( vec , format_selected , n_elements ) end if end subroutine print_vector_n subroutine print_vector ( vec , format_type ) !! print a vector real ( kind = dp ), intent ( in ) :: vec (:) ! 1D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_vector ( vec ) else call print_vector_in_format ( vec , format_selected ) end if end subroutine print_vector subroutine print_matrix_m_n ( mat , n_cols , n_rows , format_type ) !! Print a matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array integer ( kind = default_int ), intent ( in ) :: n_cols , n_rows character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat , n_cols , n_rows ) else call print_matrix_in_format ( mat , format_selected , n_cols , n_rows ) end if end subroutine print_matrix_m_n subroutine print_matrix ( mat , format_type ) !! print a matrix in a given format real ( kind = dp ), intent ( in ) :: mat (:, :) ! 2D array character ( len =* ), intent ( in ), optional :: format_type character ( len = 20 ) :: format_selected ! Determine the format: default to \"PLAIN\" if not specified if ( present ( format_type )) then format_selected = trim ( adjustl ( format_type )) else format_selected = \"PLAIN\" end if ! Handle plain format separately or delegate to print routine based on the format if ( format_selected == \"PLAIN\" ) then call print_plain_matrix ( mat ) else call print_matrix_in_format ( mat , format_selected ) end if end subroutine print_matrix subroutine print_plain_vector ( vec , n_elements ) !! private subroutine that prints a vector of n_elements real ( kind = dp ), intent ( in ) :: vec (:) integer ( kind = default_int ), intent ( in ), optional :: n_elements integer ( kind = default_int ) :: i , loop_bound if ( present ( n_elements )) then loop_bound = n_elements else loop_bound = size ( vec ) end if print * , \"Vector (Plain format):\" do i = 1 , loop_bound write ( * , fmt_edge ) vec ( i ) end do end subroutine print_plain_vector subroutine print_plain_matrix ( mat , n_cols , n_rows ) !! private subroutine that prints a plain matrix of n_cols by n_rows real ( kind = dp ), intent ( in ) :: mat (:, :) integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if print * , \"Matrix (Plain format):\" do i = 1 , loop_bound_i do j = 1 , loop_bound_j if ( j == loop_bound_j ) then write ( * , fmt_edge , advance = \"yes\" ) mat ( i , j ) ! Last element in the row, new line else write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) ! In-between elements end if end do end do end subroutine print_plain_matrix subroutine print_vector_in_format ( vec , format_type , n_elements ) !! private subroutine that prints a vector in a format real ( kind = dp ), intent ( in ) :: vec (:) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy integer ( kind = default_int ), intent ( in ), optional :: n_elements character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ) :: i , loop_bound_i if ( present ( n_elements )) then loop_bound_i = n_elements else loop_bound_i = size ( vec ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the vector in the selected format print * , \"Vector (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i if ( i == loop_bound_i ) then ! Last element in the vector write ( * , fmt_edge , advance = \"no\" ) vec ( i ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) vec ( i ) end if end do print * , close_bracket end subroutine print_vector_in_format subroutine print_matrix_in_format ( mat , format_type , n_cols , n_rows ) !! private subroutine to print a matrix in format real ( kind = dp ), intent ( in ) :: mat (:, :) character ( len =* ), intent ( in ) :: format_type !! format can be mathematica or numpy character ( len = 1 ) :: open_bracket , close_bracket integer ( kind = default_int ), intent ( in ), optional :: n_cols , n_rows integer ( kind = default_int ) :: i , j , loop_bound_i , loop_bound_j if ( present ( n_cols ) . and . present ( n_rows )) then loop_bound_i = n_cols loop_bound_j = n_rows else loop_bound_i = size ( mat , 1 ) loop_bound_j = size ( mat , 2 ) end if ! Select brackets based on format type if ( format_type == \"NUMPY\" ) then open_bracket = \"[\" close_bracket = \"]\" else if ( format_type == \"MATHEMATICA\" ) then open_bracket = \"{\" close_bracket = \"}\" else print * , \"Error: Unsupported format type. Defaulting to NumPy format.\" open_bracket = \"[\" close_bracket = \"]\" end if ! Print the matrix in the selected format print * , \"Matrix (\" , trim ( format_type ), \" format):\" print * , open_bracket do i = 1 , loop_bound_i write ( * , \"(A)\" , advance = \"no\" ) open_bracket ! Start of a row do j = 1 , loop_bound_j if ( j == loop_bound_j ) then ! Last element in the row write ( * , fmt_edge , advance = \"no\" ) mat ( i , j ) else ! Elements in between write ( * , fmt_in , advance = \"no\" ) mat ( i , j ) end if end do if ( i == loop_bound_i ) then print * , close_bracket ! Close bracket without a comma for the last row else print * , close_bracket , \",\" ! Close bracket with a comma for all other rows end if end do print * , close_bracket end subroutine print_matrix_in_format end module pic_matrix_printer","tags":"","url":"sourcefile/pic_matrix_printer.f90.html"},{"title":"pic_command_line.f90 – PIC","text":"The pic_command_line.f90 file will contain all routines that will interact with the command line This file depends on sourcefile~~pic_command_line.f90~~EfferentGraph sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! The pic_command_line.f90 file will contain all routines that will interact with the command line module pic_command_line !! command line interaction module use pic_types , only : default_int implicit none private public :: get_first_arg_from_command_line contains function get_first_arg_from_command_line () result ( filename ) !! obtain the first argument from the command line character ( len = 255 ) :: filename character ( len = 255 ) :: arg integer ( default_int ) :: num_args num_args = command_argument_count () if ( num_args < 1 ) then write ( * , \"(A)\" ) \"Usage: ./my_executable <filename>\" stop 1 end if call get_command_argument ( 1 , arg ) filename = trim ( adjustl ( arg )) end function get_first_arg_from_command_line end module pic_command_line","tags":"","url":"sourcefile/pic_command_line.f90.html"},{"title":"pic_logger.f90 – PIC","text":"the pic_logger.f90 is the base file that defines the logger function\nthis is heavily inspired by the logger from the standard library\nbut with some key changes for my purposes.\nThe logger will be the way in which the code interacts\nwith the output to console and files This file depends on sourcefile~~pic_logger.f90~~EfferentGraph sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! the pic_logger.f90 is the base file that defines the logger function !! this is heavily inspired by the logger from the standard library !! but with some key changes for my purposes. !! The logger will be the way in which the code interacts !! with the output to console and files module pic_logger !! this is the logger module use pic_types , only : default_int use pic_global_definitions , only : stdout , logfile_unit implicit none private public :: global_logger , logger_type character ( * ), parameter :: name = \"pic_logger\" integer ( default_int ), parameter , public :: & debug_level = 10 , & verbose_level = 9 , & info_level = 8 , & performance_level = 7 , & warning_level = 6 , & error_level = 5 type :: logger_type !! custom logger data type private integer ( default_int ), public :: log_level = info_level !! set default log level to info integer ( default_int ), public :: log_file_level = verbose_level !! set default log file log level to verbose integer ( default_int ), private :: log_file_unit = - 1 logical , private :: log_file_open = . false . contains procedure , public , pass ( self ) :: configuration procedure , public , pass ( self ) :: configure procedure , public , pass ( self ) :: configure_file_output procedure , public , pass ( self ) :: close_log_file procedure , public , pass ( self ) :: log procedure , public , pass ( self ) :: debug procedure , public , pass ( self ) :: verbose procedure , public , pass ( self ) :: info procedure , public , pass ( self ) :: performance procedure , public , pass ( self ) :: warning procedure , public , pass ( self ) :: error end type logger_type type ( logger_type ) :: global_logger contains pure subroutine configuration ( self , level ) class ( logger_type ), intent ( in ) :: self integer ( default_int ), intent ( out ), optional :: level if ( present ( level )) level = self % log_level end subroutine configuration pure subroutine configure ( self , level ) class ( logger_type ), intent ( inout ) :: self integer ( default_int ), intent ( in ), optional :: level if ( present ( level )) self % log_level = level end subroutine configure subroutine configure_file_output ( self , filename , level ) class ( logger_type ), intent ( inout ) :: self character ( * ), intent ( in ) :: filename integer ( default_int ), intent ( in ), optional :: level integer ( default_int ) :: ios if ( self % log_file_open ) call self % close_log_file () open ( unit = logfile_unit , file = trim ( filename ), status = \"replace\" , action = \"write\" , iostat = ios ) if ( ios /= 0 ) then write ( * , * ) \"ERROR: Failed to open log file: \" , trim ( filename ) return end if self % log_file_unit = logfile_unit self % log_file_open = . true . if ( present ( level )) self % log_file_level = level end subroutine configure_file_output subroutine close_log_file ( self ) class ( logger_type ), intent ( inout ) :: self if ( self % log_file_open ) then close ( self % log_file_unit ) self % log_file_open = . false . self % log_file_unit = - 1 end if end subroutine close_log_file subroutine debug ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"DEBUG\" , message , module , procedure ) end subroutine debug subroutine verbose ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"VERBOSE\" , message , module , procedure ) end subroutine verbose subroutine info ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"INFO\" , message , module , procedure ) end subroutine info subroutine warning ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"WARNING\" , message , module , procedure ) end subroutine warning subroutine performance ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"PERFORMANCE\" , message , module , procedure ) end subroutine performance subroutine error ( self , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure call self % log ( \"ERROR\" , message , module , procedure ) end subroutine error subroutine write_log_line ( unit , level , message , module , procedure ) integer ( default_int ), intent ( in ) :: unit character ( * ), intent ( in ) :: level , message character ( * ), intent ( in ), optional :: module , procedure if ( present ( module ) . and . present ( procedure )) then write ( unit , '(A, \": \", A, \".\", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( procedure ), trim ( message ) else if ( present ( module )) then write ( unit , '(A, \": \", A, \": \", A)' ) trim ( level ), trim ( module ), trim ( message ) else write ( unit , '(A, \": \", A)' ) trim ( level ), trim ( message ) end if end subroutine write_log_line subroutine log ( self , level , message , module , procedure ) class ( logger_type ), intent ( in ) :: self character ( * ), intent ( in ) :: level character ( * ), intent ( in ) :: message character ( * ), intent ( in ), optional :: module , procedure integer ( default_int ) :: log_level_value select case ( trim ( level )) case ( \"DEBUG\" ) log_level_value = debug_level case ( \"VERBOSE\" ) log_level_value = verbose_level case ( \"INFO\" ) log_level_value = info_level case ( \"WARNING\" ) log_level_value = warning_level case ( \"PERFORMANCE\" ) log_level_value = performance_level case ( \"ERROR\" ) log_level_value = error_level case default write ( * , * ) 'ERROR: Invalid log level \"' , trim ( level ), '\"' return end select ! Console logging if ( self % log_level >= log_level_value ) then call write_log_line ( stdout , level , message , module , procedure ) end if ! File logging if ( self % log_file_open . and . self % log_file_level >= log_level_value ) then call write_log_line ( self % log_file_unit , level , message , module , procedure ) end if end subroutine log end module pic_logger","tags":"","url":"sourcefile/pic_logger.f90.html"},{"title":"pic_mpi.F90 – PIC","text":"The pic_mpi.F90 file is the main interface to the MPI implementation, it should\nbe done in such a way that we can compile the library with and without MPI\nit will be a pain in general, but meh, let’s see what we can do This file depends on sourcefile~~pic_mpi.f90~~EfferentGraph sourcefile~pic_mpi.f90 pic_mpi.F90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_mpi.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! The pic_mpi.F90 file is the main interface to the MPI implementation, it should !! be done in such a way that we can compile the library with and without MPI !! it will be a pain in general, but meh, let's see what we can do module pic_mpi !! General MPI interface module use pic_types , only : default_int #ifdef USE_MPI use mpi_f08 , only : MPI_COMM , MPI_COMM_WORLD , MPI_Init , MPI_Finalize , & MPI_Comm_size , MPI_Comm_rank #endif implicit none private public :: pic_comm type :: pic_comm !! custom data type that holds the MPI communicators private #ifdef USE_MPI type ( MPI_COMM ), public :: comm !! use the MPI_COMM from the mpi_f08 module interface #else integer ( default_int ), public :: dummy_comm !! if we don't use MPI use an integer for a comm #endif integer ( default_int ), public :: m_rank !! MPI rank integer ( default_int ), public :: m_size !! MPI size integer ( default_int ), public :: m_ierr contains procedure :: init => pic_comm_init procedure :: finalize => pic_comm_finalize end type pic_comm type ( pic_comm ), public :: world_comm !! our world comm contains subroutine pic_comm_init ( self ) !! initilalize the MPI library and get the size and rank variables class ( pic_comm ), intent ( inout ) :: self #ifdef USE_MPI integer ( default_int ) :: ierr , rank , size call MPI_Init ( ierr ) self % m_ierr = ierr self % comm = MPI_COMM_WORLD call MPI_Comm_size ( self % comm , size , ierr ) call MPI_Comm_rank ( self % comm , rank , ierr ) self % m_size = size self % m_rank = rank #else self % m_size = 1 self % m_rank = 0 #endif end subroutine pic_comm_init subroutine pic_comm_finalize ( self ) !! finalize the MPI library class ( pic_comm ), intent ( inout ) :: self #ifdef USE_MPI integer ( default_int ) :: ierr call MPI_Finalize ( ierr ) self % m_ierr = ierr #else self % m_ierr = 0 #endif end subroutine pic_comm_finalize end module pic_mpi","tags":"","url":"sourcefile/pic_mpi.f90.html"},{"title":"pic_debugging_tools.f90 – PIC","text":"This file is intended to contain tools that can be useful when debugging\nlarge programs, simple printing routines, extracting data from an array etc. This file depends on sourcefile~~pic_debugging_tools.f90~~EfferentGraph sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! This file is intended to contain tools that can be useful when debugging !! large programs, simple printing routines, extracting data from an array etc. module pic_debugging_tools !! simple single include for printing routines use pic_matrix_printer , only : print_array , print_array_with_bounds use pic_string_utils , only : to_string implicit none private contains end module pic_debugging_tools","tags":"","url":"sourcefile/pic_debugging_tools.f90.html"},{"title":"pic_blas_interfaces.F90 – PIC","text":"this file contains the interfaces for the BLAS routines of all levels\nI might consider splitting them up later but alas, I don’t have the time now\nthe idea of this file is to provide something akin to\ninterface blas_gemm\n subroutine sgemm()\n subroutine dgemm()\n  … etc,\nend interface blas_gemm\nso that I can use the same interface for all BLAS routines This file depends on sourcefile~~pic_blas_interfaces.f90~~EfferentGraph sourcefile~pic_blas_interfaces.f90 pic_blas_interfaces.F90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_blas_interfaces.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains the interfaces for the BLAS routines of all levels !! I might consider splitting them up later but alas, I don't have the time now !! the idea of this file is to provide something akin to !! interface blas_gemm !!  subroutine sgemm() !!  subroutine dgemm() !!   ... etc, !! end interface blas_gemm !! so that I can use the same interface for all BLAS routines module pic_blas_interfaces !! pic_blas_interfaces.F90 provides the interfaces for the BLAS routines !! the idea is to have a two level interface, first pic_blas_xyz which !! is the way programmers will use BLAS, it'll do some checks and then !! call the \"overloaded\" BLAS interfaces to call the correct BLAS routine use pic_types , only : sp , dp , default_int implicit none private ! these are the generic interfaces to the BLAS library public :: blas_asum , blas_axpy , blas_copy , blas_dot , blas_scal , & blas_iamax , blas_gemv , blas_gemm ! these are the cool overloaded interfaces, the pic_xyz function ! has the procedures pic_(type)xyz which will call the correct BLAS routine ! depending on the data type of the arguments ! this _needs_ allocatable arrays since we deduce shapes from the arrays themselves public :: pic_gemm , pic_gemv , pic_asum , pic_axpy , pic_copy , pic_dot , pic_scal , pic_iamax ! tested interface pic_gemm !! general interface of the BLAS GEMM routines, will call SGEMM, DGEMM, or ZGEMM module procedure :: pic_sgemm module procedure :: pic_dgemm module procedure :: pic_zgemm end interface pic_gemm ! tested interface pic_gemv !! general interface of the BLAS GEMV routines, will call SGEMV, DGEMV module procedure :: pic_sgemv module procedure :: pic_dgemv end interface pic_gemv ! tested interface pic_asum !! general interface of the BLAS SASUM routines, will call xASUM module procedure :: pic_sasum module procedure :: pic_dasum module procedure :: pic_scasum module procedure :: pic_dzasum end interface pic_asum interface pic_axpy !! general interface of the BLAS AXPY routines, will call SAXPY, DAXPY, CAXPY, ZAXPY module procedure :: pic_saxpy module procedure :: pic_daxpy module procedure :: pic_caxpy ! not tested module procedure :: pic_zaxpy ! not tested end interface pic_axpy interface pic_copy !! general interface of the BLAS COPY routines, will call SCOPY, DCOPY, CCOPY, ZCOPY module procedure :: pic_scopy module procedure :: pic_dcopy module procedure :: pic_ccopy module procedure :: pic_zcopy end interface pic_copy interface pic_dot !! general interface of the BLAS DOT routines, will call SDOT, DDOT, CDOTC, ZDOTC module procedure :: pic_sdot module procedure :: pic_ddot module procedure :: pic_cdotc module procedure :: pic_zdotc end interface pic_dot interface pic_scal !! general interface of the BLAS SCAL routines, will call SSCAL, DSCAL, CSCAL, ZSCAL module procedure :: pic_sscal module procedure :: pic_dscal module procedure :: pic_cscal module procedure :: pic_zscal end interface pic_scal interface pic_iamax !! general interface of the BLAS IAMAX routines, will call ISAMAX, IDAMAX, ICAMAX, IZAMAX module procedure :: pic_isamax module procedure :: pic_idamax module procedure :: pic_icamax module procedure :: pic_izamax end interface pic_iamax interface blas_asum !! explicit interface for BLAS ASUM routines pure function sasum ( n , x , incx ) result ( res_sasum ) import :: sp , default_int implicit none real ( sp ) :: res_sasum real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function sasum pure function dasum ( n , x , incx ) result ( res_dasum ) import :: dp , default_int implicit none real ( dp ) :: res_dasum real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dasum pure function scasum ( n , x , incx ) result ( res_scasum ) import :: sp , default_int implicit none real ( sp ) :: res_scasum complex ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function scasum pure function dzasum ( n , x , incx ) result ( res_dzasum ) import :: dp , default_int implicit none real ( dp ) :: res_dzasum complex ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function dzasum end interface blas_asum interface blas_axpy !! explicit interface for BLAS AXPY routines pure subroutine saxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine saxpy pure subroutine daxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine daxpy pure subroutine caxpy ( n , alpha , x , incx , y , incy ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine caxpy pure subroutine zaxpy ( n , alpha , x , incx , y , incy ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine zaxpy end interface blas_axpy interface blas_copy !! explicit interface for BLAS COPY routines pure subroutine scopy ( n , x , incx , y , incy ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine scopy pure subroutine dcopy ( n , x , incx , y , incy ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine dcopy pure subroutine ccopy ( n , x , incx , y , incy ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine ccopy pure subroutine zcopy ( n , x , incx , y , incy ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end subroutine zcopy end interface blas_copy interface blas_dot !! explicit interface for BLAS DOT routines pure function sdot ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none real ( sp ) :: res real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function sdot pure function ddot ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none real ( dp ) :: res real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function ddot pure function cdotc ( n , x , incx , y , incy ) result ( res ) import :: sp , default_int implicit none complex ( sp ) :: res complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function cdotc pure function zdotc ( n , x , incx , y , incy ) result ( res ) import :: dp , default_int implicit none complex ( dp ) :: res complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( in ) :: y ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy integer ( default_int ), intent ( in ) :: n end function zdotc end interface blas_dot interface blas_scal !! explicit interface for BLAS SCAL routines pure subroutine sscal ( n , alpha , x , incx ) import :: sp , default_int implicit none real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine sscal pure subroutine dscal ( n , alpha , x , incx ) import :: dp , default_int implicit none real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine dscal pure subroutine cscal ( n , alpha , x , incx ) import :: sp , default_int implicit none complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine cscal pure subroutine zscal ( n , alpha , x , incx ) import :: dp , default_int implicit none complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( inout ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end subroutine zscal end interface blas_scal interface blas_iamax !! explicit interface for BLAS IAMAX routines pure function isamax ( n , x , incx ) result ( idx ) import :: sp , default_int implicit none integer ( default_int ) :: idx real ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function isamax pure function idamax ( n , x , incx ) result ( idx ) import :: dp , default_int implicit none integer ( default_int ) :: idx real ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function idamax pure function icamax ( n , x , incx ) result ( idx ) import :: sp , default_int implicit none integer ( default_int ) :: idx complex ( sp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function icamax pure function izamax ( n , x , incx ) result ( idx ) import :: dp , default_int implicit none integer ( default_int ) :: idx complex ( dp ), intent ( in ) :: x ( * ) integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: n end function izamax end interface blas_iamax interface blas_gemv !! explicit interface for BLAS GEMV routines pure subroutine sgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: x ( * ) real ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemv pure subroutine dgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: x ( * ) real ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemv pure subroutine cgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: x ( * ) complex ( sp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemv pure subroutine zgemv ( trans , m , n , alpha , a , lda , x , incx , beta , y , incy ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: incx integer ( default_int ), intent ( in ) :: incy complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: x ( * ) complex ( dp ), intent ( inout ) :: y ( * ) character ( len = 1 ), intent ( in ) :: trans complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemv end interface blas_gemv interface blas_gemm !! explicit interface for BLAS GEMM routines pure subroutine sgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( sp ), intent ( in ) :: a ( lda , * ) real ( sp ), intent ( in ) :: b ( ldb , * ) real ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( sp ), intent ( in ) :: alpha real ( sp ), intent ( in ) :: beta end subroutine sgemm pure subroutine dgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc real ( dp ), intent ( in ) :: a ( lda , * ) real ( dp ), intent ( in ) :: b ( ldb , * ) real ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb real ( dp ), intent ( in ) :: alpha real ( dp ), intent ( in ) :: beta end subroutine dgemm pure subroutine cgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: sp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( sp ), intent ( in ) :: a ( lda , * ) complex ( sp ), intent ( in ) :: b ( ldb , * ) complex ( sp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( sp ), intent ( in ) :: alpha complex ( sp ), intent ( in ) :: beta end subroutine cgemm pure subroutine zgemm ( transa , transb , m , n , k , alpha , a , lda , b , ldb , & & beta , c , ldc ) import :: dp , default_int implicit none integer ( default_int ), intent ( in ) :: m integer ( default_int ), intent ( in ) :: n integer ( default_int ), intent ( in ) :: k integer ( default_int ), intent ( in ) :: lda integer ( default_int ), intent ( in ) :: ldb integer ( default_int ), intent ( in ) :: ldc complex ( dp ), intent ( in ) :: a ( lda , * ) complex ( dp ), intent ( in ) :: b ( ldb , * ) complex ( dp ), intent ( inout ) :: c ( ldc , * ) character ( len = 1 ), intent ( in ) :: transa character ( len = 1 ), intent ( in ) :: transb complex ( dp ), intent ( in ) :: alpha complex ( dp ), intent ( in ) :: beta end subroutine zgemm end interface blas_gemm contains pure subroutine pic_sgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: B (:, :) real ( sp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( sp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_sgemm pure subroutine pic_dgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: B (:, :) real ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B real ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_dgemm pure subroutine pic_zgemm ( A , B , C , transa , transb , alpha , beta ) !! interface for single precision matrix multiplication complex ( dp ), intent ( in ) :: A (:, :) complex ( dp ), intent ( in ) :: B (:, :) complex ( dp ), intent ( inout ) :: C (:, :) character ( len = 1 ), intent ( in ), optional :: transa character ( len = 1 ), intent ( in ), optional :: transb complex ( dp ), intent ( in ), optional :: alpha complex ( dp ), intent ( in ), optional :: beta character ( len = 1 ) :: OP_A , OP_B complex ( dp ) :: l_alpha , l_beta integer ( default_int ) :: m , n , k , lda , ldb , ldc ! first check for the constants if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if ! check the OP options, maybe this should not be optional if ( present ( transa )) then OP_A = transa else OP_A = \"N\" end if if ( present ( transb )) then OP_B = transb else OP_B = \"N\" end if ! check for the dimensions now if (( OP_A == \"N\" . or . OP_A == \"n\" )) then k = size ( A , 2 ) else k = size ( A , 1 ) end if ! get LDA, LDB, and LDC lda = max ( 1 , size ( A , 1 )) ldb = max ( 1 , size ( B , 1 )) ldc = max ( 1 , size ( C , 1 )) m = size ( C , 1 ) n = size ( C , 2 ) call blas_gemm ( OP_A , OP_B , m , n , k , l_alpha , A , lda , B , ldb , l_beta , C , ldc ) end subroutine pic_zgemm pure subroutine pic_sgemv ( A , x , y , trans_a , alpha , beta ) !! interface for single precision matrix-vector multiplication real ( sp ), intent ( in ) :: A (:, :) real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( sp ), intent ( in ), optional :: alpha real ( sp ), intent ( in ), optional :: beta real ( sp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_sgemv pure subroutine pic_dgemv ( A , x , y , trans_a , alpha , beta ) !! interface for double precision matrix-vector multiplication real ( dp ), intent ( in ) :: A (:, :) real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) character ( len = 1 ), intent ( in ), optional :: trans_a real ( dp ), intent ( in ), optional :: alpha real ( dp ), intent ( in ), optional :: beta real ( dp ) :: l_alpha , l_beta character ( len = 1 ) :: l_trans_a integer ( default_int ) :: incx , incy , m , n , lda if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if if ( present ( beta )) then l_beta = beta else l_beta = 0.0_sp end if if ( present ( trans_a )) then l_trans_a = trans_a else l_trans_a = \"n\" end if incx = 1 incy = 1 lda = max ( 1 , size ( A , 1 )) m = size ( A , 1 ) n = size ( A , 2 ) call blas_gemv ( l_trans_a , m , n , l_alpha , A , lda , x , incx , l_beta , y , incy ) end subroutine pic_dgemv function pic_sasum ( x ) result ( res ) !! interface for single precision absolute sum real ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_sasum function pic_dasum ( x ) result ( res ) !! interface for double precision absolute sum real ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dasum function pic_scasum ( x ) result ( res ) !! interface for single precision complex absolute sum complex ( sp ), intent ( in ) :: x (:) real ( sp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_scasum function pic_dzasum ( x ) result ( res ) !! interface for double precision complex absolute sum complex ( dp ), intent ( in ) :: x (:) real ( dp ) :: res integer ( default_int ) :: n , incx n = size ( x ) incx = 1 res = blas_asum ( n , x , incx ) end function pic_dzasum subroutine pic_saxpy ( x , y , alpha ) !! interface for single precision AXPY real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_saxpy subroutine pic_daxpy ( x , y , alpha ) !! interface for double precision AXPY real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_daxpy subroutine pic_caxpy ( x , y , alpha ) !! interface for single precision complex AXPY complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_caxpy subroutine pic_zaxpy ( x , y , alpha ) !! interface for double precision complex AXPY complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_axpy ( n , l_alpha , x , incx , y , incy ) end subroutine pic_zaxpy subroutine pic_scopy ( x , y ) !! interface for single precision copy real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_scopy subroutine pic_dcopy ( x , y ) !! interface for double precision copy real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_dcopy subroutine pic_ccopy ( x , y ) !! interface for single precision complex copy complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_ccopy subroutine pic_zcopy ( x , y ) !! interface for double precision complex copy complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( inout ) :: y (:) integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 call blas_copy ( n , x , incx , y , incy ) end subroutine pic_zcopy function pic_sdot ( x , y ) result ( res ) !! interface for single precision dot product real ( sp ), intent ( in ) :: x (:) real ( sp ), intent ( in ) :: y (:) real ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_sdot function pic_ddot ( x , y ) result ( res ) !! interface for double precision dot product real ( dp ), intent ( in ) :: x (:) real ( dp ), intent ( in ) :: y (:) real ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_ddot function pic_cdotc ( x , y ) result ( res ) !! interface for single precision complex dot product complex ( sp ), intent ( in ) :: x (:) complex ( sp ), intent ( in ) :: y (:) complex ( sp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_cdotc function pic_zdotc ( x , y ) result ( res ) !! interface for double precision complex dot product complex ( dp ), intent ( in ) :: x (:) complex ( dp ), intent ( in ) :: y (:) complex ( dp ) :: res integer ( default_int ) :: n , incx , incy n = size ( x ) incx = 1 incy = 1 res = blas_dot ( n , x , incx , y , incy ) end function pic_zdotc subroutine pic_sscal ( x , alpha ) !! interface for single precision scaling real ( sp ), intent ( inout ) :: x (:) real ( sp ), intent ( in ), optional :: alpha real ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_sscal subroutine pic_dscal ( x , alpha ) !! interface for double precision scaling real ( dp ), intent ( inout ) :: x (:) real ( dp ), intent ( in ), optional :: alpha real ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_dscal subroutine pic_cscal ( x , alpha ) !! interface for single precision complex scaling complex ( sp ), intent ( inout ) :: x (:) complex ( sp ), intent ( in ), optional :: alpha complex ( sp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_sp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_cscal subroutine pic_zscal ( x , alpha ) !! interface for double precision complex scaling complex ( dp ), intent ( inout ) :: x (:) complex ( dp ), intent ( in ), optional :: alpha complex ( dp ) :: l_alpha integer ( default_int ) :: n , incx n = size ( x ) incx = 1 if ( present ( alpha )) then l_alpha = alpha else l_alpha = 1.0_dp end if call blas_scal ( n , l_alpha , x , incx ) end subroutine pic_zscal function pic_isamax ( x ) result ( idx ) !! interface for single precision index of maximum absolute value real ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_isamax function pic_idamax ( x ) result ( idx ) !! interface for double precision index of maximum absolute value real ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_idamax function pic_icamax ( x ) result ( idx ) !! interface for single precision complex index of maximum absolute value complex ( sp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_icamax function pic_izamax ( x ) result ( idx ) !! interface for double precision complex index of maximum absolute value complex ( dp ), intent ( in ) :: x (:) integer ( default_int ) :: idx integer ( default_int ) :: n , incx n = size ( x ) incx = 1 idx = blas_iamax ( n , x , incx ) end function pic_izamax end module pic_blas_interfaces","tags":"","url":"sourcefile/pic_blas_interfaces.f90.html"},{"title":"pic_types.F90 – PIC","text":"pic_types.F90 controls the standarized sizes for the datatypes across\npic, this is key for interfacing with other codes specially those that\nuse default sizes Files dependent on this one sourcefile~~pic_types.f90~~AfferentGraph sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_blas_interfaces.f90 pic_blas_interfaces.F90 sourcefile~pic_blas_interfaces.f90->sourcefile~pic_types.f90 sourcefile~pic_command_line.f90 pic_command_line.f90 sourcefile~pic_command_line.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_global_definitions.f90 pic_global_definitions.f90 sourcefile~pic_global_definitions.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90 pic_logger.f90 sourcefile~pic_logger.f90->sourcefile~pic_types.f90 sourcefile~pic_logger.f90->sourcefile~pic_global_definitions.f90 sourcefile~pic_matrix_printer.f90 pic_matrix_printer.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_types.f90 sourcefile~pic_matrix_printer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_mpi.f90 pic_mpi.F90 sourcefile~pic_mpi.f90->sourcefile~pic_types.f90 sourcefile~pic_output_helpers.f90 pic_output_helpers.f90 sourcefile~pic_output_helpers.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_debugging_tools.f90 pic_debugging_tools.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_matrix_printer.f90 sourcefile~pic_debugging_tools.f90->sourcefile~pic_string_utils.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! pic_types.F90 controls the standarized sizes for the datatypes across !! pic, this is key for interfacing with other codes specially those that !! use default sizes module pic_types !! main module for defining types for integer and double precision use , intrinsic :: iso_fortran_env , only : int32 , int64 implicit none private public :: int32 , int64 ! Define kinds for different data types ! int32 and int64 are defined in the iso_fortran_env, if you need to change things please do so here integer , parameter , public :: sp = SELECTED_REAL_KIND ( 6 , 37 ) !! single precision variable integer , parameter , public :: dp = SELECTED_REAL_KIND ( 15 , 307 ) !! double precision variable integer , parameter , public :: qp = SELECTED_REAL_KIND ( 33 , 4931 ) !! quadruple precision variable ! Define default types #ifdef USE_INT8 integer , parameter , public :: default_int = int64 #else integer , parameter , public :: default_int = int32 #endif !! default integer kind, be careful if you are using fdefault-size=8 integer , parameter , public :: default_real = dp !! naturally, our default real is double precision integer , parameter , public :: default_complex = dp !! default complex is double precision end module pic_types","tags":"","url":"sourcefile/pic_types.f90.html"},{"title":"pic_output_helpers.f90 – PIC","text":"this file contains “helper” routines, for example printing\na set amount of x characters to creates tables, etc. This file depends on sourcefile~~pic_output_helpers.f90~~EfferentGraph sourcefile~pic_output_helpers.f90 pic_output_helpers.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_output_helpers.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! this file contains \"helper\" routines, for example printing !! a set amount of x characters to creates tables, etc. module pic_output_helpers !! Assorted output helper routines use pic_types , only : default_int implicit none private public :: print_asterisk_row contains subroutine print_asterisk_row ( n ) !! prints a convenient row of asterisks of length n integer ( kind = default_int ), intent ( in ) :: n !! number of asterisks to print integer ( kind = default_int ) :: i do i = 1 , n write ( * , \"(A)\" , advance = \"no\" ) \"*\" end do write ( * , * ) end subroutine print_asterisk_row end module pic_output_helpers","tags":"","url":"sourcefile/pic_output_helpers.f90.html"},{"title":"pic_flop_rate.f90 – PIC","text":"flop rate handler modules This file depends on sourcefile~~pic_flop_rate.f90~~EfferentGraph sourcefile~pic_flop_rate.f90 pic_flop_rate.f90 sourcefile~pic_flop_recorder.f90 pic_flop_recorder.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_flop_recorder.f90 sourcefile~pic_string_utils.f90 pic_string_utils.f90 sourcefile~pic_flop_rate.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90 pic_timer.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_timer.f90 sourcefile~pic_types.f90 pic_types.F90 sourcefile~pic_flop_rate.f90->sourcefile~pic_types.f90 sourcefile~pic_flop_recorder.f90->sourcefile~pic_types.f90 sourcefile~pic_string_utils.f90->sourcefile~pic_types.f90 sourcefile~pic_timer.f90->sourcefile~pic_string_utils.f90 sourcefile~pic_timer.f90->sourcefile~pic_types.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code !! flop rate handler modules module pic_flop_rate !! pic_flop_rate is a convenient encapsulation of the flop_recorder and pic_timer !! it is used to measure the flop rate of a given operation, and report it use pic_types , only : dp , int64 use pic_timers , only : pic_timer use pic_flop_recorder , only : flop_recorder_type use pic_string_utils , only : to_string implicit none private public :: flop_rate_type type flop_rate_type !! derived type for flop rate, contains a timer and a flop recorder private type ( pic_timer ) :: m_timer type ( flop_recorder_type ) :: m_flops real ( dp ) :: m_flop_rate !! private by default so that people use the accessor functions contains procedure :: start_time => flop_rate_start_time procedure :: stop_time => flop_rate_stop_time procedure :: add_flops => flop_rate_add_flops procedure :: get_flops => flop_rate_get_flops procedure :: get_time => flop_rate_get_time procedure :: get_flop_rate => flop_rate_get_flop_rate procedure :: report => flop_rate_report procedure :: reset => flop_rate_reset end type flop_rate_type contains subroutine flop_rate_start_time ( self ) !! start the timer for the flop rate class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % start () end subroutine flop_rate_start_time subroutine flop_rate_stop_time ( self ) !! stop the timer for the flop rate class ( flop_rate_type ), intent ( inout ) :: self call self % m_timer % stop () end subroutine flop_rate_stop_time subroutine flop_rate_add_flops ( self , flops ) !! add flops to the flop rate class ( flop_rate_type ), intent ( inout ) :: self integer ( int64 ), intent ( in ) :: flops call self % m_flops % add ( flops ) end subroutine flop_rate_add_flops function flop_rate_get_flops ( self ) result ( flops ) !! get the number of flops recorded class ( flop_rate_type ), intent ( in ) :: self integer ( int64 ) :: flops flops = self % m_flops % get () end function flop_rate_get_flops function flop_rate_get_time ( self ) result ( time ) !! get the elapsed time for the timer through the flop rate type class ( flop_rate_type ), intent ( in ) :: self real ( dp ) :: time time = self % m_timer % get_elapsed_time () end function flop_rate_get_time function flop_rate_get_flop_rate ( self ) result ( flop_rate ) !! get the flop rate in GFLOP/s, return 0.0 if time is zero or negative class ( flop_rate_type ), intent ( inout ) :: self real ( dp ) :: flop_rate real ( dp ) :: time integer ( int64 ) :: flops flops = self % m_flops % get () time = self % m_timer % get_elapsed_time () if ( time <= 0.0_dp ) then print * , \"Warning: Time is zero or negative, setting flop rate to zero.\" self % m_flop_rate = 0.0_dp flop_rate = 0.0_dp return else self % m_flop_rate = flops / time / 1.0e9_dp flop_rate = self % m_flop_rate end if end function flop_rate_get_flop_rate subroutine flop_rate_report ( self ) !! report the flop rate in GFLOP/s !! this is a convenience function to print the flop rate class ( flop_rate_type ), intent ( inout ) :: self self % m_flop_rate = self % get_flop_rate () print * , \"Flop rate is \" // to_string ( self % m_flop_rate ) // \" GFLOP/s\" end subroutine flop_rate_report subroutine flop_rate_reset ( self ) !! reset the flop rate, this will reset the flops, this is mostly for testing class ( flop_rate_type ), intent ( inout ) :: self call self % m_flops % reset () end subroutine flop_rate_reset end module pic_flop_rate","tags":"","url":"sourcefile/pic_flop_rate.f90.html"},{"title":"pic.f90 – PIC","text":"the main pic module interface: versions, banners, random quotes etc will go here Source Code !! the main pic module interface: versions, banners, random quotes etc will go here module pic !! simple interface module that prints banner and other information about the library !! mostly here to verify installs, etc. implicit none private public :: pic_print_banner contains subroutine pic_print_banner !! my cool banner, work in progress print * , \"========================================\" print * , \"         _____  _____  _____ \" print * , \"        |  __ \\\\|_   _|/ ____|\" print * , \"        | |__) | | | | |     \" print * , \"        |  ___/  | | | |     \" print * , \"        | |     _| |_| |____ \" print * , \"        |_|    |_____|\\\\_____|\" print * , \"                                        \" print * , \"               PIC LIBRARY\" print * , \"========================================\" end subroutine pic_print_banner end module pic","tags":"","url":"sourcefile/pic.f90.html"}]}