#:set TYPES = ['int32', 'int64', 'sp', 'dp']

#:set FORTRAN_TYPES = { &
    'int32': 'integer(int32)',&
    'int64': 'integer(int64)', &
    'sp':    'real(sp)', &
    'dp':    'real(dp)' &
}


!! pic array contains L0.5 BLAS level routines, as in things that could be use in
!! lieu of blas if you don't have it but if you do, please don't use these routines
module pic_array
!! Please do not modify this file to implement new methods, please go look at tools/autogen/pic_array_cpu.fypp
!! and edit the generator.
  use pic_types, only: sp, dp, int32, int64, default_int
  use pic_string, only: to_string, to_upper
  use pic_optional_value, only: pic_optional
  implicit none
  private

  public :: fill, copy
  public :: pic_transpose, pic_sum
  public :: pic_scramble_array, pic_print_array
  public :: is_sorted
  public :: set_threading_mode, get_threading_mode

  logical :: use_threaded_default = .false.
  public :: ASCENDING, DESCENDING

  integer(default_int), parameter :: ASCENDING = 1
  integer(default_int), parameter :: DESCENDING = 2
  character(len=5), parameter :: default_format = "NUMPY"
  !! supported formats: NUMPY, MATHEMATICA, and PLAIN which resembles numpy

  character(len=*), parameter :: fmt_edge = "(A)"
  character(len=*), parameter :: fmt_in = '(A, ", ")'


     interface set_threading_mode
   !! set_threading sets the threading mode for the array routines
   !! this will set the use_threaded variable to true or false depending on the input
   !! Usage: call set_threading_mode(.true.) or call set_threading_mode(.false.)
      module procedure set_threading_mode
   end interface

   interface get_threading_mode
   !! get_threading_mode returns the current threading mode for the array routines
   !! Usage: mode = get_threading_mode()
      module procedure get_threading_mode
   end interface get_threading_mode


  interface fill
  !! fill provides a generic interface to assing a value
  !! alpha of types (int32, int64, sp, dp) as defined in pic_types.F90
  !! The inteface supports filling 1d and 2d arrays of the specified
  !! variables
  !!
  !! Usage: call fill(array, value, [optional] threaded)
  !!
  !! This subroutine is threaded for performance purposes if threaded is set to .true.
  !!
  !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism
  #:for T in TYPES
    module procedure fill_vector_${T}$
  #:endfor
  #:for T in TYPES
    module procedure fill_matrix_${T}$
  #:endfor
  end interface

  interface copy
  !! copy provides a blas-less implementation of xcopy where x is (i,s,d) icopy, scopy, dcopy
  !! if you built pic with BLAS use the copy interface provided there, I will not beat BLAS
  !! copy is implemented for (int32, int64, sp, dp) for 1 and 2d arrays of the same types
  !!
  !! Usage: call copy(destination, source, [optional] threaded)
  !!
  !! This subroutine is threaded for performance purposes if threaded is set to .true.
  !!
  !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism
  #:for T in TYPES
    module procedure copy_vector_${T}$
  #:endfor
  #:for T in TYPES
    module procedure copy_matrix_${T}$
  #:endfor
  end interface

  interface pic_transpose
  !! pic_transpose provides a blas-less, threaded alternative to the Fortran transpose intrinsic
  !! which will be slow for large matrix sizes. pic_transpose does not assume symmetric matrices
  !!
  !! pic_transpose is implemented for (int32, int64, sp, dp) 2d arrays
  !!
  !! Usage: call pic_transpose(matrix_to_transpose, result, [optional] threaded)
  !!
  !! This subroutine is threaded for performance purposes if threaded is set to true
  !!
  !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism
  !!
  #:for T in TYPES
    module procedure transpose_matrix_${T}$
  #:endfor
  end interface

  interface pic_sum
  !! pic_sum provides a threaded alternative to the sum(array) Fortran intrinsic which will
  !! be too slow for large sizes of vectors and matrices. Note that this provides the total
  !! sum. As opposed to the blas alternative XASUM which does the absolute sum
  !!
  !! pic_sum is implemented for (int32, int64, sp, dp) 1 and 2d arrays
  !!
  !! Usage: result = pic_sum(array, [optional] threaded)
  !!
  !! This subroutine is threaded for performance purposes if threaded is set to true
  !!
  !! @note If this subroutine is called inside a omp threaded region it will run serially because of nested parallelism
  !!
  #: for T in TYPES
    module procedure sum_vector_${T}$
  #:endfor
  #: for T in TYPES
    module procedure sum_matrix_${T}$
  #:endfor
  end interface

  interface is_sorted
    !! is_sorted provides a simple way to checking if a 1d array is sorted
    !! it is implemented for int32, int64, sp, and dp datatypes. The default
    !! is to check if an array is sorted in ascending fashion.
    !!
    !! Usage: result = is_sorted(array, [optional] ASCENDING/DESCENDING)
    #: for T in TYPES
      module procedure is_sorted_${T}$
    #:endfor
    module procedure is_sorted_char
    end interface

  interface pic_print_array
    !! Generic interface for printing arrays of different types
    !!
    !! Usage: call print_array_v2(array, [optional] format)
    !! Where format can be: NUMPY, PLAIN, MATHEMATICA (can use lower caps)
    !!
    !! Implemented types are:
    !!
    !! array(:)   -> int32, int64, sp, dp
    !!
    !! array(:,:) -> int32, int64, sp, dp
    !!
    !! array(:) (packed matrix) -> sp, dp
    !!
    !! array(:,:,:) -> sp, dp
    !!
    #: for T in TYPES
        module procedure print_vector_${T}$
    #: endfor
    #: for T in TYPES
        module procedure print_matrix_${T}$
    #: endfor
    #: for T in TYPES
        module procedure print_packed_matrix_${T}$
    #: endfor
    #: for T in TYPES
        module procedure print_3d_tensor_${T}$
    #: endfor

   end interface

   interface pic_scramble_array
    #: for T in TYPES
        module procedure scramble_array_${T}$
    #: endfor
          module procedure scramble_array_character
   end interface pic_scramble_array

  ! potentially implement a shallow copy? nah?
  integer(default_int), parameter :: block_size = 32
    !! This is the size to block over for matrices for performance purposes

contains

   subroutine set_threading_mode(threaded)
      !! set the threading mode for the array routines, this will set the use_threaded variable
      !! to true or false depending on the input
      !!
      !! Usage: call set_threading(.true.) or call set_threading(.false.)
      logical, intent(in) :: threaded
      use_threaded_default = threaded
   end subroutine set_threading_mode

   function get_threading_mode() result(mode)
      !! get the current threading mode for the array routines
      !! Usage: mode = get_threading_mode()
      logical :: mode
      mode = use_threaded_default
   end function get_threading_mode

   subroutine set_brackets(format_type, open_bracket, close_bracket)
   !! Set brackets based on output format type
      character(len=*), intent(in) :: format_type
      character(len=1), intent(out) :: open_bracket, close_bracket
      select case (trim(to_upper(adjustl(format_type))))
      case ("NUMPY")
         open_bracket = "["
         close_bracket = "]"
      case ("MATHEMATICA")
         open_bracket = "{"
         close_bracket = "}"
      case ("PLAIN")
         open_bracket = "["
         close_bracket = "]"
      case default
         print *, "Warning: Unsupported format type '"//trim(format_type)//"'. Defaulting to NumPy style."
         open_bracket = "["
         close_bracket = "]"
      end select
   end subroutine set_brackets

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine fill_vector_${T}$(vector, alpha, threaded)
    ${FTYPE}$, intent(inout) :: vector(:)
    ${FTYPE}$, intent(in)    :: alpha
    logical, intent(in), optional :: threaded
    logical :: use_threads
    integer(default_int) :: i

    use_threads = pic_optional(threaded, use_threaded_default)
    if(use_threads) then
      !$omp parallel do collapse(1) private(i)
        do i = 1, size(vector,1)
          vector(i) = alpha
        end do
      !$omp end parallel do
    else
      vector = alpha
    endif

  end subroutine fill_vector_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine fill_matrix_${T}$(matrix, alpha, threaded)
    ${FTYPE}$, intent(inout) :: matrix(:,:)
    ${FTYPE}$, intent(in)    :: alpha
    integer(default_int) :: i, j, rows, cols
    integer(default_int) :: ii, jj
    logical, intent(in), optional :: threaded
    logical :: use_threads
    rows = size(matrix, 1)
    cols = size(matrix, 2)
    use_threads = pic_optional(threaded, use_threaded_default)
    if(use_threads) then
    !$omp parallel do collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj + block_size - 1, cols)
          do i = ii, min(ii + block_size - 1, rows)
            matrix(i,j) = alpha
          end do
        end do
      end do
    end do
    !$omp end parallel do
    else
      matrix = alpha
    endif
  end subroutine fill_matrix_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  subroutine copy_vector_${T}$(dest, source, threaded)
    ${FTYPE}$, intent(inout) :: dest(:)
    ${FTYPE}$, intent(in)    :: source(:)
    logical, intent(in), optional :: threaded
    logical :: use_threads
    integer(default_int) :: i
    if (size(dest,1) /= size(source,1)) then
      error stop "Vector size mismatch"
    end if
    use_threads = pic_optional(threaded, use_threaded_default)
    if(use_threads) then
    !$omp parallel do collapse(1) private(i)
    do i = 1, size(dest,1)
      dest(i) = source(i)
    end do
    !$omp end parallel do
    else
      dest = source
    endif
  end subroutine copy_vector_${T}$

#:endfor
#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  subroutine copy_matrix_${T}$(dest, source, threaded)
    ${FTYPE}$, intent(inout) :: dest(:,:)
    ${FTYPE}$, intent(in)    :: source(:,:)
    logical, intent(in), optional :: threaded
    logical :: use_threads
    integer(default_int) :: i, j, rows, cols
    integer(default_int) :: ii, jj
    if (size(dest,1) /= size(source,1) .or. size(dest,2) /= size(source,2)) then
      error stop "Matrix size mismatch"
    end if
    rows = size(source, 1)
    cols = size(source, 2)
    use_threads = pic_optional(threaded, use_threaded_default)
    if(use_threads) then
    !$omp parallel do collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj + block_size - 1, cols)
          do i = ii, min(ii + block_size - 1, rows)
            dest(i,j) = source(i,j)
          end do
        end do
      end do
    end do
    !$omp end parallel do
    else
      dest = source
    endif
  end subroutine copy_matrix_${T}$

#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine transpose_matrix_${T}$(A, B, threaded)
    ${FTYPE}$, intent(in)  :: A(:,:)
    ${FTYPE}$, intent(out) :: B(:,:)
    logical, intent(in), optional :: threaded
    logical :: use_threads
    integer(default_int) :: i, j, ii, jj, rows, cols

    rows = size(A,1)
    cols = size(A,2)

    if (size(B,1) /= cols .or. size(B,2) /= rows) then
      error stop "transpose: size mismatch"
    end if

    use_threads = pic_optional(threaded, use_threaded_default)

    if(use_threads) then
    !$omp parallel do collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj+block_size-1, cols)
          do i = ii, min(ii+block_size-1, rows)
            B(j,i) = A(i,j)
          end do
        end do
      end do
    end do
    !$omp end parallel do
    else
      B = transpose(A)
    endif
  end subroutine transpose_matrix_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  function sum_vector_${T}$(vector, threaded) result(res)
    ${FTYPE}$, intent(in)  :: vector(:)
    logical, intent(in), optional :: threaded
    logical :: use_threads
    ${FTYPE}$ :: res
    integer(default_int) :: i
    res = 0_${T}$
    use_threads = pic_optional(threaded, use_threaded_default)
    if(use_threads) then
      !$omp parallel do private(i) collapse(1) reduction(+:res)
      do i = 1, size(vector,1)
        res = res + vector(i)
      end do
      !$omp end parallel do
    else
      res = sum(vector)
    endif
  end function sum_vector_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  function sum_matrix_${T}$(matrix, threaded) result(res)
    ${FTYPE}$, intent(in) :: matrix(:,:)
    logical, intent(in), optional :: threaded
    logical :: use_threads
    ${FTYPE}$ :: res
    integer(default_int) :: cols, rows, i, j, ii, jj

    rows = size(matrix,1)
    cols = size(matrix,2)

    use_threads = pic_optional(threaded, use_threaded_default)
    res = 0_${T}$
    if(use_threads) then
    !$omp parallel do collapse(2) private(i,j,ii,jj) reduction(+: res)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj+block_size-1, cols)
          do i = ii, min(ii+block_size-1, rows)
            res = res + matrix(i,j)
          end do
        end do
      end do
    end do
    !$omp end parallel do
    else
      res = sum(matrix)
    endif

  end function sum_matrix_${T}$

#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
   pure function is_sorted_${T}$(array, order) result(sorted)
    ${FTYPE}$, intent(in) :: array(:)
    integer(default_int), intent(in), optional :: order
    integer(default_int):: sort_order
    integer(default_int) :: i
    logical :: sorted


    sorted = .true.
    sort_order = pic_optional(order, ASCENDING)

    select case (sort_order)
    case (DESCENDING)
       do i = 1, size(array) - 1
          if (array(i + 1) > array(i)) then
             sorted = .false.
             return
          end if
       end do
    case default  ! ASCENDING or any other value
       do i = 1, size(array) - 1
          if (array(i + 1) < array(i)) then
             sorted = .false.
             return
          end if
       end do
    end select

   end function is_sorted_${T}$

#:endfor

   pure function is_sorted_char(array, order) result(sorted)
      character(len=*), intent(in) :: array(:)
      integer(default_int), intent(in), optional :: order
      integer(default_int) :: sort_order
      integer(default_int) :: i
      logical :: sorted

      sorted = .true.
      sort_order = pic_optional(order, ASCENDING)

      select case (sort_order)
      case (DESCENDING)
         do i = 1, size(array) - 1
            if (array(i + 1) > array(i)) then
               sorted = .false.
               return
            end if
         end do
      case default  ! ASCENDING or any other value
         do i = 1, size(array) - 1
            if (array(i + 1) < array(i)) then
               sorted = .false.
               return
            end if
         end do
      end select
   end function is_sorted_char


#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

     subroutine print_vector_${T}$(vector, format_type)
     !! print a vector of ${T} values
      ${FTYPE}$, intent(in) :: vector(:)
      character(len=*), intent(in), optional :: format_type
      character(len=20) :: print_format

      print_format = pic_optional(format_type, default_format)

      print: block
         character(len=1) :: open_bracket, close_bracket
         integer(default_int) :: i, loop_bound_i
         loop_bound_i = size(vector)
         call set_brackets(print_format, open_bracket, close_bracket)
         write (*, "(A)", advance="no") open_bracket
         do i = 1, loop_bound_i
            if (i == loop_bound_i) then  ! Last element in the vector
               write (*, fmt_edge, advance="no") to_string(vector(i))
            else  ! Elements in between
               write (*, fmt_in, advance="no") to_string(vector(i))
            end if
         end do
         print *, close_bracket

      end block print

   end subroutine print_vector_${T}$

#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

   subroutine print_matrix_${T}$(matrix, format_type)
    !! print a matrix of ${T} values
      ${FTYPE}$, intent(in) :: matrix(:, :)
      character(len=*), intent(in), optional :: format_type
      character(len=20) :: print_format

      print_format = pic_optional(format_type, default_format)

      print: block
         character(len=1) :: open_bracket, close_bracket
         integer(default_int) :: i, j, rows, cols
         rows = size(matrix, 1)
         cols = size(matrix, 2)
         call set_brackets(print_format, open_bracket, close_bracket)
         print *, open_bracket
         do i = 1, rows
            write (*, "(A)", advance="no") open_bracket
            do j = 1, cols
               if (j == cols) then  ! Last element in the row
                  write (*, fmt_edge, advance="no") to_string(matrix(i, j))
               else  ! Elements in between
                  write (*, fmt_in, advance="no") to_string(matrix(i, j))
               end if
            end do
            if (i == rows) then
               print *, close_bracket
            else
               print *, close_bracket, ","
            end if
         end do
         print *, close_bracket
      end block print

   end subroutine print_matrix_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

subroutine print_packed_matrix_${T}$(packed, n_elements, format_type)
   !! Print a packed lower triangular matrix of ${T} values
   ${FTYPE}$, intent(in) :: packed(:)
   integer(default_int), intent(in) :: n_elements
   character(len=*), intent(in), optional :: format_type
   character(len=20) :: print_format
   character(len=1) :: open_bracket, close_bracket
   integer(default_int) :: i, j, idx, n
   real(dp) :: n_real

   ! Determine format
   print_format = pic_optional(format_type, default_format)
   call set_brackets(print_format, open_bracket, close_bracket)

   ! Compute n from packed size using proper real arithmetic
   n_real = (-1.0_dp + sqrt(1.0_dp + 8.0_dp * real(n_elements, dp))) / 2.0_dp
   n = int(n_real + 0.5_dp, default_int)

   if (n*(n + 1)/2 /= n_elements) then
      print *, "Error: n_elements does not form a valid packed triangle"
      return
   end if

   ! Print lower triangle directly from packed array
   print *, open_bracket
   idx = 0
   do i = 1, n
      write (*, '(A)', advance="no") open_bracket
      do j = 1, i
         idx = idx + 1
         if (j == i) then
            write (*, '(A)', advance="no") to_string(packed(idx))
         else
            write (*, '(A)', advance="no") trim(to_string(packed(idx))//", ")
         end if
      end do
      if (i == n) then
         print *, close_bracket
      else
         print *, close_bracket, ","
      end if
   end do
   print *, close_bracket
end subroutine print_packed_matrix_${T}$

#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
   subroutine print_3d_tensor_${T}$(matrix, format_type)
    !! Print a 3D tensor of ${T} values
      ${FTYPE}$, intent(in) :: matrix(:, :, :)
      character(len=*), intent(in), optional :: format_type
      character(len=20) :: print_format

   print_format = pic_optional(format_type, default_format)

      print: block
         character(len=1) :: open_bracket, close_bracket
         integer(int32) :: i, j, k, rows, cols, depth
         rows = size(matrix, 1)
         cols = size(matrix, 2)
         depth = size(matrix, 3)
         call set_brackets(print_format, open_bracket, close_bracket)
         print *, open_bracket
         do k = 1, depth
            if (k > 1) print *, ","
            print *, open_bracket
            call pic_print_array(matrix(:, :, k), print_format)
            print *, close_bracket
         end do
         print *, close_bracket
      end block print

   end subroutine print_3d_tensor_${T}$

#:endfor


#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
   subroutine scramble_array_${T}$(array)
      ${FTYPE}$, intent(inout) :: array(:)
      integer(int32) :: i, j, n
      integer(int32) :: temp
      real(sp) :: rand_val

      n = size(array)
      do i = n, 2, -1
         call random_number(rand_val)
         j = int(rand_val*i) + 1
         temp = array(i)
         array(i) = array(j)
         array(j) = temp
      end do
   end subroutine scramble_array_${T}$

#:endfor

   subroutine scramble_array_character(array)
      character(len=*), intent(inout) :: array(:)
      integer(int32) :: i, j, n
      character(len=len(array)) :: temp
      real(sp) :: rand_val

      n = size(array)
      do i = n, 2, -1
         call random_number(rand_val)
         j = int(rand_val*i) + 1
         temp = array(i)
         array(i) = array(j)
         array(j) = temp
      end do
   end subroutine scramble_array_character
end module pic_array
