#:set REAL_KINDS = ["sp", "dp"]
#:set REAL_TYPES = ["real({})".format(k) for k in REAL_KINDS]
#:set REAL_KINDS_TYPES = list(zip(REAL_KINDS, REAL_TYPES))
#:set INT_KINDS = ["int32", "int64"]
#:set INT_TYPES = ["integer({})".format(k) for k in INT_KINDS]
#:set INT_KINDS_TYPES = list(zip(INT_KINDS, INT_TYPES))
#:set LOG_KINDS = ["fbool"]
#:set LOG_TYPES = ["logical({})".format(k) for k in LOG_KINDS]
#:set LOG_KINDS_TYPES = list(zip(LOG_KINDS, LOG_TYPES))

submodule(pic_stdlib_strings) pic_stdlib_strings_to_string
use pic_stdlib_string_type, only: string_type
implicit none

    integer, parameter :: buffer_len = 128
    character(len=*), parameter :: err_sym = "[*]"
        !!TODO: [*]?

contains

    #:for k1, t1 in REAL_KINDS_TYPES
    !> Format or transfer a ${t1}$ scalar as a string.
    pure module function to_string_${t1[0]}$_${k1}$(value, format) result(string)
        ${t1}$, intent(in) :: value
        character(len=*), intent(in), optional :: format
        character(len=:), allocatable :: string

        character(len=buffer_len) :: buffer
        integer :: stat

        write(buffer, '(' // pic_optional(format, "g0") // ')', iostat=stat) value
        if (stat == 0) then
            string = trim(buffer)
        else
            string = err_sym
        end if

    end function to_string_${t1[0]}$_${k1}$
    #:endfor

    #:for k1, t1 in INT_KINDS_TYPES
    !> Represent an integer of kind ${k1}$ as character sequence.
    pure module function to_string_1_${t1[0]}$_${k1}$(value) result(string)
        integer, parameter :: ik = ${k1}$
        integer(ik), intent(in) :: value
        character(len=:), allocatable :: string
        integer, parameter :: buffer_len = range(value)+2
        character(len=buffer_len) :: buffer
        integer :: pos
        integer(ik) :: n
        character(len=1), parameter :: numbers(-9:0) = &
            ["9", "8", "7", "6", "5", "4", "3", "2", "1", "0"]

        if (value == 0_ik) then
            string = numbers(0)
            return
        end if

        n = sign(value, -1_ik)
        buffer = ""
        pos = buffer_len + 1
        do while (n < 0_ik)
            pos = pos - 1
            buffer(pos:pos) = numbers(mod(n, 10_ik))
            n = n/10_ik
        end do

        if (value < 0_ik) then
            pos = pos - 1
            buffer(pos:pos) = '-'
        end if

        string = buffer(pos:)
    end function to_string_1_${t1[0]}$_${k1}$

    pure module function to_string_2_${t1[0]}$_${k1}$(value, format) result(string)
        ${t1}$, intent(in) :: value
        character(len=*), intent(in) :: format
        character(len=:), allocatable :: string
        character(len=:), allocatable :: adjusted_format

        character(len=buffer_len) :: buffer
        integer :: stat

#ifdef __NVCOMPILER_LLVM__
        adjusted_format = fix_nvhpc_octal_format(format)
#else
        adjusted_format = format
#endif
        write(buffer, "(" // adjusted_format // ")", iostat=stat) value
        if (stat == 0) then
            string = trim(buffer)
        else
            string = err_sym
        end if


    end function to_string_2_${t1[0]}$_${k1}$
    #:endfor
   pure function fix_nvhpc_octal_format(fmt) result(fixed)
      character(len=*), intent(in) :: fmt
      character(len=:), allocatable :: fixed
      integer :: pos, dot_pos
      character(len=10) :: precision_str

      ! Check if format contains "O0."
      pos = index(fmt, 'O0.')
      if (pos > 0) then
         ! Extract precision after the dot
         dot_pos = pos + 2  ! Position of '.'
         precision_str = fmt(dot_pos + 1:)
         ! Replace O0.w with Ow.w (where w is the precision)
         fixed = fmt(1:pos - 1)//'O'//trim(precision_str)//'.'//trim(precision_str)
      else
         fixed = fmt
      end if
   end function fix_nvhpc_octal_format

    #:for k1, t1 in LOG_KINDS_TYPES
    !> Represent an logical of kind ${k1}$ as character sequence.
    pure module function to_string_1_${t1[0]}$_${k1}$(value) result(string)
        ${t1}$, intent(in) :: value
        character(len=1) :: string

        string = merge("T", "F", value)

    end function to_string_1_${t1[0]}$_${k1}$

    pure module function to_string_2_${t1[0]}$_${k1}$(value, format) result(string)
        ${t1}$, intent(in) :: value
        character(len=*), intent(in) :: format
        character(len=:), allocatable :: string

        character(len=buffer_len) :: buffer
        integer :: stat

        write(buffer, "(" // format // ")", iostat=stat) value
        if (stat == 0) then
            string = trim(buffer)
        else
            string = err_sym
        end if

    end function to_string_2_${t1[0]}$_${k1}$
    #:endfor

end submodule pic_stdlib_strings_to_string
