#:set TYPES = ['int32', 'int64', 'sp', 'dp']

#:set FORTRAN_TYPES = { &
    'int32': 'integer(int32)',&
    'int64': 'integer(int64)', &
    'sp':    'real(sp)', &
    'dp':    'real(dp)' &
}

module pic_array
  use pic_types, only: sp, dp, int32, int64, default_int
  implicit none
  private

  public :: fill, copy, pic_transpose

  interface fill
  #:for T in TYPES
    module procedure fill_vector_${T}$
  #:endfor
  #:for T in TYPES
    module procedure fill_matrix_${T}$
  #:endfor
  end interface

  interface copy
  #:for T in TYPES
    module procedure copy_vector_${T}$
  #:endfor
  #:for T in TYPES
    module procedure copy_matrix_${T}$
  #:endfor
  end interface

  interface pic_transpose
  #:for T in TYPES
    module procedure transpose_matrix_${T}$
  #:endfor
  end interface

  ! potentially implement a shallow copy? nah?
  integer(default_int), parameter :: block_size = 32

contains

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine fill_vector_${T}$(vector, alpha)
    ${FTYPE}$, intent(inout) :: vector(:)
    ${FTYPE}$, intent(in)    :: alpha
    integer(default_int) :: i
    !$omp target teams loop collapse(2)
      do i = 1, size(vector,1)
        vector(i) = alpha
      end do
    !$omp end target teams loop
  end subroutine fill_vector_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine fill_matrix_${T}$(matrix, alpha)
    ${FTYPE}$, intent(inout) :: matrix(:,:)
    ${FTYPE}$, intent(in)    :: alpha
    integer(default_int) :: i, j, rows, cols
    integer(default_int) :: ii, jj
    rows = size(matrix, 1)
    cols = size(matrix, 2)
    !$omp target teams loop collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj + block_size - 1, cols)
          do i = ii, min(ii + block_size - 1, rows)
            matrix(i,j) = alpha
          end do
        end do
      end do
    end do
    !$omp end target teams loop
  end subroutine fill_matrix_${T}$
#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  subroutine copy_vector_${T}$(dest, source)
    ${FTYPE}$, intent(inout) :: dest(:)
    ${FTYPE}$, intent(in)    :: source(:)
    integer(default_int) :: i
    if (size(dest,1) /= size(source,1)) then
      error stop "Vector size mismatch"
    end if
    !$omp target teams loop collapse(2)
    do i = 1, size(dest,1)
      dest(i) = source(i)
    end do
    !$omp end target teams loop
  end subroutine copy_vector_${T}$

#:endfor
#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]
  subroutine copy_matrix_${T}$(dest, source)
    ${FTYPE}$, intent(inout) :: dest(:,:)
    ${FTYPE}$, intent(in)    :: source(:,:)
    integer(default_int) :: i, j, rows, cols
    integer(default_int) :: ii, jj
    if (size(dest,1) /= size(source,1) .or. size(dest,2) /= size(source,2)) then
      error stop "Matrix size mismatch"
    end if
    rows = size(source, 1)
    cols = size(source, 2)
    !$omp target teams loop collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj + block_size - 1, cols)
          do i = ii, min(ii + block_size - 1, rows)
            dest(i,j) = source(i,j)
          end do
        end do
      end do
    end do
    !$omp end target teams loop
  end subroutine copy_matrix_${T}$

#:endfor

#:for T in TYPES
  #:set FTYPE = FORTRAN_TYPES[T]

  subroutine transpose_matrix_${T}$(A, B)
    ${FTYPE}$, intent(in)  :: A(:,:)
    ${FTYPE}$, intent(out) :: B(:,:)
    integer(default_int) :: i, j, ii, jj, rows, cols

    rows = size(A,1)
    cols = size(A,2)

    if (size(B,1) /= cols .or. size(B,2) /= rows) then
      error stop "transpose: size mismatch"
    end if

    !$omp parallel do collapse(2) private(i,j,ii,jj)
    do jj = 1, cols, block_size
      do ii = 1, rows, block_size
        do j = jj, min(jj+block_size-1, cols)
          do i = ii, min(ii+block_size-1, rows)
            B(j,i) = A(i,j)
          end do
        end do
      end do
    end do
  end subroutine transpose_matrix_${T}$
#:endfor

end module pic_array
